load ../meta/narrowing.maude
load lmc.maude

set include BOOL off .

fmod LABELLED-GRAPH is

    sort Node .
    -----------
    vars N N' : Node .

    sorts Label LEdge NeLGraph LGraph .
    subsorts LEdge < NeLGraph < LGraph .
    ------------------------------------
    var L : Label . var NeLG : NeLGraph .

    op .LGraph : -> LGraph .
    op __      :   LGraph LGraph ->   LGraph [assoc comm id: .LGraph prec 55 format(d n d)] .
    op __      : NeLGraph LGraph -> NeLGraph [ditto] .
    --------------------------------------------------
    eq NeLG NeLG = NeLG .

    op _-[_]->_ : Node Label Node -> LEdge [prec 50] .
    --------------------------------------------------

    sorts Transition NeTransitionSet TransitionSet .
    subsorts Transition < NeTransitionSet < TransitionSet .
    -------------------------------------------------------
    var TS : TransitionSet . vars NeTS NeTS' : NeTransitionSet .

    op .TransitionSet : -> TransitionSet .
    op _,_ :   TransitionSet TransitionSet ->   TransitionSet [assoc comm id: .TransitionSet] .
    op _,_ : NeTransitionSet TransitionSet -> NeTransitionSet [ditto] .
    -------------------------------------------------------------------
    eq NeTS , NeTS = NeTS .

    op <_,_> : Label Node -> Transition .
    op _->_  : Node TransitionSet -> LGraph [prec 50] .
    ---------------------------------------------------
    eq N -> .TransitionSet = .LGraph .
    eq N -> < L , N' >     = N -[ L ]-> N' .
    eq N -> NeTS , NeTS'   = N -> NeTS N -> NeTS' .
endfm

fmod GRAPH-FOLDING-SEARCH is
   protecting INT .
   protecting BOUND .
    extending LABELLED-GRAPH .

    vars N N' N'' : Nat . vars D D' : Depth . var B : Bound .
    var L : Label . vars LG LG' LG'' LG''' : LGraph . vars NeLG NeLG' : NeLGraph .

    sorts Fold State NodeId .
    subsort Nat < NodeId .
    subsort State NodeId < Node .
    -----------------------------
    vars F F' : Fold . var F? : [Fold] .
    vars S S' : State . vars ND ND' : NodeId .

    op _[_] : Nat Fold      -> NodeId [right id: .Fold prec 20] .
    op _<_  : NodeId NodeId -> Bool   [ditto] .
    -------------------------------------------
   ceq N[F] < N'[F'] = F =/= .Fold and (F' =/= .Fold implies N < N')
    if F =/= .Fold or F' =/= .Fold .

    op .Fold : -> Fold .
    op fold  : State State -> [Fold] .
    ----------------------------------
    eq fold(S, S) = .Fold .

    op step : State -> [TransitionSet] .
    ------------------------------------

    sorts NodeAlias NeEnvironment Environment .
    subsort NodeAlias < NeEnvironment < Environment .
    -------------------------------------------------
    var NA : NodeAlias . vars ENV ENV' : Environment . vars NeENV NeENV' : NeEnvironment .

    op _|->_ : Nat Node -> NodeAlias [prec 55] .
    --------------------------------------------

    op .Environment : -> Environment .
    op __ : NeEnvironment Environment -> NeEnvironment [assoc id: .Environment prec 60] .
    op __ :   Environment Environment ->   Environment [ditto] .
    ------------------------------------------------------------

    op  insert : NodeAlias Environment             -> [Environment] .
    op #insert : NodeAlias Environment Environment -> [Environment] .
    op {_,_}   : NodeId    Environment             -> [Environment] .
    -----------------------------------------------------------------
    eq insert(NA, ENV) = #insert(NA, .Environment, ENV) .

    eq #insert(N |-> S , ENV , .Environment)   = { N , ENV N |-> S } .
   ceq #insert(N |-> S , ENV , N' |-> S' ENV') = if (F? :: Fold) then { N'[F?] , ENV N' |-> S' ENV' }
                                                                 else #insert(N |-> S, ENV N' |-> S', ENV')
                                                 fi
                                              if F? := fold(S,S') .

    sort Frontier BFS .
    -------------------

    op _[_]_ : LGraph Depth LGraph -> Frontier [prec 65] .
    ------------------------------------------------------

    op _|_|_|_ : LGraph Environment Nat Frontier -> BFS [prec 70] .
    ---------------------------------------------------------------
    eq LG | ENV | N | .LGraph [ D           ] NeLG
     = LG | ENV | N | NeLG    [ continue(D) ] .LGraph .

   ceq LG               | ENV  |   N | ND -[L]-> S' LG' [ D ] LG''
     = LG ND -[L]-> ND' | ENV' | s N |              LG' [ D ] LG'' LG'''
    if { ND' , ENV' } := insert(s N |-> S', ENV)
    /\          LG''' := if (ND' < s N) then .LGraph else ND' -> step(S') fi .

    op bfs : State       -> BFS .
    op bfs : State Bound -> BFS .
    -----------------------------
    eq bfs(S)    = bfs(S, unbounded) .
    eq bfs(S, B) = .LGraph | 1 |-> S | 1 | 1 -> step(S) [ 0 , B ] .LGraph .
endfm

fmod FVP-NARROWING-GRAPH is
   protecting NARROWING2 .
    extending GRAPH-FOLDING-SEARCH .
    extending META-LMC-PARAMETERS .

    var TYPE : Type . vars T T' : Term . var M : Module . var SUB : Substitution .
    vars SR SR' : StepResult . var SRS : StepResultSet . var RS : RuleSet .

    op label : RuleSet Substitution -> Label .
    ------------------------------------------

    op transition : StepResultSet -> [TransitionSet] .
    --------------------------------------------------
    eq transition({T , TYPE , SUB / RS }) = < label(RS, SUB) , state(T) > .
    eq transition(.StepResultSet)         = .TransitionSet .
    eq transition(SR || SR' || SRS)       = transition(SR) , transition(SR') , transition(SRS) .

    op state : Term         -> State .
    op fold  : Substitution -> Fold .
    ---------------------------------
    eq step(state(T))            = transition(metaNarrow2(##m##, T)) .
   ceq fold(state(T), state(T')) = fold(SUB) if SUB := metaMatch(##m##, T, T', nil, 0) .
endfm

eof

fmod FVP-NARROWING-MODULO-T-GRAPH is
    protecting SUBSTITUTIONSET .
    protecting NARROWING-GRAPH .
    protecting INTEGER .

    sorts Constraint CState .
    subsort State < CState .
    ------------------------
    vars NeTS NeTS' : NeTransitionSet . var T : Term . var N : Nat .
    vars C C' : Constraint . var M : Module . vars S S' : State .
    var SUBST : Substitution . var SUBSTS : SubstitutionSet .

    op downConstraintError : -> [Constraint] .
    op _<<_ : Constraint Substitution -> Constraint .
    -------------------------------------------------
   ceq C << SUBST = C'
    if T  := upTerm(C) << SUBST
    /\ C' := downTerm(T, downConstraintError) .

    op unsatis? : Constraint            -> [Bool] .
    op entails? : Constraint Constraint -> [Bool] .
    -----------------------------------------------

    op _|_ : State Constraint -> CState .
    op <_,_> : Step CState -> Transition .
    --------------------------------------

    op step : Module CState -> [TransitionSet] .
    --------------------------------------------
    eq step(M, S | C) = updateTransitions(C, step(M, S)) .

    op updateTransitions : Constraint TransitionSet -> [TransitionSet] .
    --------------------------------------------------------------------
    eq updateTransitions(C, .TransitionSet) = .TransitionSet .
    eq updateTransitions(C, (NeTS , NeTS')) = updateTransitions(C, NeTS) , updateTransitions(C, NeTS') .

   ceq updateTransitions(C, < SUBST , S >) = .TransitionSet             if C' := C << SUBST /\ unsatis?(C') .
    eq updateTransitions(C, < SUBST , S >) = < SUBST , S | C << SUBST > [owise] .

    op allMatches : Module State State Nat -> [SubstitutionSet] .
    -------------------------------------------------------------
    eq allMatches(M, S, S', N) = none [owise] .
   ceq allMatches(M, S, S', N) = SUBST | allMatches(M, S, S', N + 1)
    if SUBST := metaMatch(M, upTerm(S'), upTerm(S), nil, N) .

    op fold : Module CState CState -> [Fold] .
    ------------------------------------------
   ceq fold(M, S | C, S' | C') = SUBST
    if SUBST | SUBSTS := allMatches(M, S, S', 0)
    /\ entails?(C', C << SUBST) .
endfm
