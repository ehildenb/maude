set include BOOL off .

fmod LABELLED-GRAPH is

    sort Node .
    -----------
    vars N N' : Node .

    sorts Label LEdge NeLGraph LGraph .
    subsorts LEdge < NeLGraph < LGraph .
    ------------------------------------
    var L : Label . var NeLG : NeLGraph .

    op .LGraph : -> LGraph .
    op __      :   LGraph LGraph ->   LGraph [assoc comm id: .LGraph prec 55 format(d n d)] .
    op __      : NeLGraph LGraph -> NeLGraph [ditto] .
    --------------------------------------------------
    eq NeLG NeLG = NeLG .

    op _-[_]->_ : Node Label Node -> LEdge [prec 50] .
    --------------------------------------------------

    sorts Transition NeTransitionSet TransitionSet .
    subsorts Transition < NeTransitionSet < TransitionSet .
    -------------------------------------------------------
    var TS : TransitionSet . vars NeTS NeTS' : NeTransitionSet .

    op .TransitionSet : -> TransitionSet .
    op _,_ :   TransitionSet TransitionSet ->   TransitionSet [assoc comm id: .TransitionSet] .
    op _,_ : NeTransitionSet TransitionSet -> NeTransitionSet [ditto] .
    -------------------------------------------------------------------
    eq NeTS , NeTS = NeTS .

    op <_,_> : Label Node -> Transition .
    op _->_  : Node TransitionSet -> LGraph [prec 50] .
    ---------------------------------------------------
    eq N -> .TransitionSet = .LGraph .
    eq N -> < L , N' >     = N -[ L ]-> N' .
    eq N -> NeTS , NeTS'   = N -> NeTS N -> NeTS' .
endfm

fmod GRAPH-FOLDING-SEARCH is
   protecting INT .
   protecting BOUND .
    extending LABELLED-GRAPH .

    vars N N' N'' : Nat . vars D D' : Depth . var B : Bound .
    var L : Label . vars LG LG' LG'' LG''' : LGraph . vars NeLG NeLG' : NeLGraph .

    sorts Fold State NodeId .
    subsort Nat < NodeId .
    subsort State NodeId < Node .
    -----------------------------
    vars F F' : Fold . var F? : [Fold] .
    vars S S' : State . vars ND ND' : NodeId .

    op _[_] : Nat Fold      -> NodeId [right id: .Fold prec 20] .
    op _<_  : NodeId NodeId -> Bool   [ditto] .
    -------------------------------------------
   ceq N[F] < N'[F'] = F =/= .Fold and (F' =/= .Fold implies N < N')
    if F =/= .Fold or F' =/= .Fold .

    op .Fold : -> Fold .
    op fold  : State State -> [Fold] .
    ----------------------------------
    eq fold(S, S) = .Fold .

    op step : State -> [TransitionSet] .
    ------------------------------------

    sorts NodeAlias NeEnvironment Environment .
    subsort NodeAlias < NeEnvironment < Environment .
    -------------------------------------------------
    var NA : NodeAlias . vars ENV ENV' : Environment . vars NeENV NeENV' : NeEnvironment .

    op _|->_ : Nat Node -> NodeAlias [prec 55] .
    --------------------------------------------

    op .Environment : -> Environment .
    op __ : NeEnvironment Environment -> NeEnvironment [assoc id: .Environment prec 60] .
    op __ :   Environment Environment ->   Environment [ditto] .
    ------------------------------------------------------------

    op  insert : NodeAlias Environment             -> [Environment] .
    op #insert : NodeAlias Environment Environment -> [Environment] .
    op {_,_}   : NodeId    Environment             -> [Environment] .
    -----------------------------------------------------------------
    eq insert(NA, ENV) = #insert(NA, .Environment, ENV) .

    eq #insert(N |-> S , ENV , .Environment)   = { N , ENV N |-> S } .
   ceq #insert(N |-> S , ENV , N' |-> S' ENV') = if (F? :: Fold) then { N'[F?] , ENV N' |-> S' ENV' }
                                                                 else #insert(N |-> S, ENV N' |-> S', ENV')
                                                 fi
                                              if F? := fold(S,S') .

    sort Frontier BFS .
    -------------------

    op _[_]_ : LGraph Depth LGraph -> Frontier [prec 65] .
    ------------------------------------------------------

    op _|_|_|_ : LGraph Environment Nat Frontier -> BFS [prec 70] .
    ---------------------------------------------------------------
    eq LG | ENV | N | .LGraph [ D           ] NeLG
     = LG | ENV | N | NeLG    [ continue(D) ] .LGraph .

   ceq LG               | ENV  |   N | ND -[L]-> S' LG' [ D ] LG''
     = LG ND -[L]-> ND' | ENV' | s N |              LG' [ D ] LG'' LG'''
    if { ND' , ENV' } := insert(s N |-> S', ENV)
    /\          LG''' := if (ND' < s N) then .LGraph else ND' -> step(S') fi .

    op bfs : State       -> BFS .
    op bfs : State Bound -> BFS .
    -----------------------------
    eq bfs(S)    = bfs(S, unbounded) .
    eq bfs(S, B) = .LGraph | 1 |-> S | 1 | 1 -> step(S) [ 0 , B ] .LGraph .
endfm
