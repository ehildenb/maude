set include BOOL off .

fmod LABELLED-GRAPH is

    sort Node .
    -----------
    vars N N' : Node .

    sorts Label LEdge NeLGraph LGraph .
    subsorts LEdge < NeLGraph < LGraph .
    ------------------------------------
    var L : Label . var NeLG : NeLGraph .

    op .LGraph : -> LGraph .
    op __      :   LGraph LGraph ->   LGraph [assoc comm id: .LGraph prec 55 format(d n d)] .
    op __      : NeLGraph LGraph -> NeLGraph [ditto] .
    --------------------------------------------------
    eq NeLG NeLG = NeLG .

    op _-[_]->_ : Node Label Node -> LEdge [prec 50] .
    --------------------------------------------------

    sorts Transition NeTransitionSet TransitionSet .
    subsorts Transition < NeTransitionSet < TransitionSet .
    -------------------------------------------------------
    var TS : TransitionSet . vars NeTS NeTS' : NeTransitionSet .

    op .TransitionSet : -> TransitionSet .
    op _,_ :   TransitionSet TransitionSet ->   TransitionSet [assoc comm id: .TransitionSet] .
    op _,_ : NeTransitionSet TransitionSet -> NeTransitionSet [ditto] .
    -------------------------------------------------------------------
    eq NeTS , NeTS = NeTS .

    op <_,_> : Label Node -> Transition .
    op _->_  : Node TransitionSet -> LGraph [prec 50] .
    ---------------------------------------------------
    eq N -> .TransitionSet = .LGraph .
    eq N -> < L , N' >     = N -[ L ]-> N' .
    eq N -> NeTS , NeTS'   = N -> NeTS N -> NeTS' .
endfm

fmod GRAPH-FOLDING-SEARCH is
    protecting INT .
    extending LABELLED-GRAPH .

    vars N N' N'' : Nat . var ND : Node . var L : Label .
    var LE : LEdge . var LG : LGraph . vars NeLG NeLG' : NeLGraph .

    sorts Fold State FState .
    subsort Nat < FState .
    subsort State FState < Node .
    -----------------------------
    vars F F' : Fold . var F? : [Fold] . vars S S' : State . vars FS FS' : FState .

    op _[_] : Nat Fold -> FState [right id: .Fold] .
    ------------------------------------------------

    op .Fold : -> Fold .
    op fold : State State -> [Fold] .
    ---------------------------------
    eq fold(S, S) = .Fold .

    op step : State -> [TransitionSet] .
    ------------------------------------
    eq step(FS) = .TransitionSet .

    sorts NeFrontier Frontier .
    subsorts Node < NeFrontier < Frontier .
    ---------------------------------------
    var FT : Frontier .

    op .Frontier : -> Frontier .
    op _,_       : Frontier   Frontier -> Frontier   [assoc id: .Frontier prec 45] .
    op _,_       : NeFrontier Frontier -> NeFrontier [ditto] .
    ----------------------------------------------------------

    sorts NeEnvironment Environment .
    subsort NeEnvironment < Environment .
    -------------------------------------
    vars ENV ENV' : Environment . var NeENV : NeEnvironment .

    op _|->_ : Nat State -> NeEnvironment [prec 55] .
    -------------------------------------------------

    op .Environment : -> Environment .
    op _,_ :   Environment Environment ->   Environment [assoc id: .Environment prec 60] .
    op _,_ : NeEnvironment Environment -> NeEnvironment [ditto] .
    -------------------------------------------------------------
    eq NeENV , NeENV = NeENV .

    op  insertState : State Environment             -> [Environment] .
    op #insertState : State Environment Environment -> [Environment] .
    op {_,_}        : Node  Environment             -> [Environment] .
    ------------------------------------------------------------------
    eq insertState(S, ENV) = #insertState(S, .Environment, ENV) .

    eq #insertState(S, ENV, .Environment)  = { S , ENV } .
   ceq #insertState(S, ENV, (N |-> S' , ENV')) = if (F? :: Fold)
                                                    then { N[F?] , (ENV , N |-> S' , ENV') }
                                                    else #insertState(S, (ENV , N |-> S'), ENV')
                                                 fi
                                              if F? := fold(S,S') .

    op [_:_] : Nat LGraph -> Environment .
    --------------------------------------
    eq [ N : .LGraph    ] = .Environment .
    eq [ N : NeLG NeLG' ] = [ N : NeLG ] , [ N : NeLG' ] .

    eq N |-> S , [ N' : LE ] = [ max(N, N') : LE ] , N |-> S [owise] .

    eq NeENV , [ N : FS -[L]-> FS' ] = [ N : FS -[L]-> FS' ] , NeENV .

    eq N |-> S , [ N' : (S  -[ L ]-> ND) ] = N |-> S , [ N' : N  -[ L ]-> ND   ] .
   ceq N |-> S , [ N' : (ND -[ L ]-> S') ] = N |-> S , [ N' : ND -[ L ]-> N[F] ] if F := fold(S', S) .

    sort BFS .
    ----------

    op _|_|_ : LGraph Environment Frontier -> BFS [prec 70] .
    ---------------------------------------------------------
    eq LG | ENV | S , FT = LG | ENV , [ 0 : S -> step(S) ] | FT .

    eq LG | [   N :   S -[L]-> ND ]             , ENV | FT
     = LG | [ s N : s N -[L]-> ND ] , s N |-> S , ENV | FT .

    eq LG               | [ N : FS -[L]-> FS' ] , ENV | FT
     = LG FS -[L]-> FS' |                         ENV | FT .

    eq LG               | [ N : FS -[L]-> S ] , ENV | FT
     = LG FS -[L]-> s N | s N |-> S           , ENV | FT , S .

    op bfs : State -> BFS .
    -----------------------
    eq bfs(S) = .LGraph | .Environment | S .
endfm
