load ../meta/narrowing.maude
load ../meta/cterms.maude
load ../meta/mtransform.maude
load lmc.maude

set include BOOL off .

fmod LABELLED-GRAPH is

    sort Node .
    -----------
    vars N N' : Node .

    sorts Label LEdge NeLGraph LGraph .
    subsorts LEdge < NeLGraph < LGraph .
    ------------------------------------
    var L : Label . var NeLG : NeLGraph .

    op .LGraph : -> LGraph .
    op __      :   LGraph LGraph ->   LGraph [assoc comm id: .LGraph prec 55 format(d n d)] .
    op __      : NeLGraph LGraph -> NeLGraph [ditto] .
    --------------------------------------------------
    eq NeLG NeLG = NeLG .

    op _-[_]->_ : Node Label Node -> LEdge [prec 50] .
    --------------------------------------------------

    sorts Transition NeTransitionSet TransitionSet .
    subsorts Transition < NeTransitionSet < TransitionSet .
    -------------------------------------------------------
    var TS : TransitionSet . vars NeTS NeTS' : NeTransitionSet .

    op .TransitionSet : -> TransitionSet .
    op _,_ :   TransitionSet TransitionSet ->   TransitionSet [assoc comm id: .TransitionSet] .
    op _,_ : NeTransitionSet TransitionSet -> NeTransitionSet [ditto] .
    -------------------------------------------------------------------
    eq NeTS , NeTS = NeTS .

    op <_,_> : Label Node -> Transition .
    op _->_  : Node TransitionSet -> LGraph [prec 50] .
    ---------------------------------------------------
    eq N -> .TransitionSet = .LGraph .
    eq N -> < L , N' >     = N -[ L ]-> N' .
    eq N -> NeTS , NeTS'   = N -> NeTS N -> NeTS' .
endfm

fmod GRAPH-FOLDING-SEARCH is
   protecting NAT .
   protecting BOUND .
    extending LABELLED-GRAPH .

    vars N N' N'' : Nat . var NID : NodeId . vars D D' : Depth . var B : Bound .
    var L : Label . vars LG LG' LG'' LG''' : LGraph . vars NeLG NeLG' : NeLGraph .

    sorts State NeStateSet StateSet .
    ---------------------------------
    subsort State < NeStateSet < StateSet .

    vars NeSS NeSS' : NeStateSet . var SS : StateSet .

    op .StateSet : -> StateSet .
    op _;;_      : StateSet   StateSet ->   StateSet [assoc comm id: .StateSet] .
    op _;;_      : StateSet NeStateSet -> NeStateSet [ditto] .
    ----------------------------------------------------------
    eq S ;; S = S .

    sort Fold .
    -----------
    vars F F' : Fold . var F? : [Fold] .

    op .Fold : -> Fold .
    op fold  : State State -> [Fold] .
    ----------------------------------
    eq fold(S, S) = .Fold .

    op subsumes : StateSet StateSet -> [Bool] .
    -------------------------------------------
    eq subsumes(.StateSet, NeSS)   = false .
    eq subsumes(SS, .StateSet)     = true .
    eq subsumes(SS, NeSS ;; NeSS') = subsumes(SS, NeSS) and subsumes(SS, NeSS') .
   ceq subsumes(S ;; SS, S')       = true
                                  if F := fold(S', S) .

    sort NodeId .
    subsort Nat < NodeId .
    subsort State NodeId < Node .
    -----------------------------
    vars S S' : State . vars ND ND' : NodeId .

    op _[_] : Nat Fold      -> NodeId [right id: .Fold prec 20] .
    op _<_  : NodeId NodeId -> Bool   [ditto] .
    -------------------------------------------
   ceq N[F] < N'[F'] = F =/= .Fold and (F' =/= .Fold implies N < N')
    if F =/= .Fold or F' =/= .Fold .

    op step : State -> [TransitionSet] .
    ------------------------------------

    sorts NodeAlias NeEnvironment Environment .
    subsort NodeAlias < NeEnvironment < Environment .
    -------------------------------------------------
    var NA : NodeAlias . vars ENV ENV' : Environment . vars NeENV NeENV' : NeEnvironment .

    op _|->_ : Nat Node -> NodeAlias [prec 55] .
    --------------------------------------------

    op .Environment : -> Environment .
    op __ : NeEnvironment Environment -> NeEnvironment [assoc id: .Environment prec 60 format(d n d)] .
    op __ :   Environment Environment ->   Environment [ditto] .
    ------------------------------------------------------------

    op  insert : NodeAlias Environment             -> [Environment] .
    op #insert : NodeAlias Environment Environment -> [Environment] .
    op {_,_}   : NodeId    Environment             -> [Environment] .
    -----------------------------------------------------------------
    eq insert(NA, ENV) = #insert(NA, .Environment, ENV) .

    eq #insert(N |-> S , ENV , .Environment)   = { N , ENV N |-> S } .
   ceq #insert(N |-> S , ENV , N' |-> S' ENV') = if (F? :: Fold) then { N'[F?] , ENV N' |-> S' ENV' }
                                                                 else #insert(N |-> S, ENV N' |-> S', ENV')
                                                 fi
                                              if F? := fold(S,S') .

    op states : Environment -> [StateSet] .
    ---------------------------------------
    eq states(.Environment) = .StateSet .
    eq states(N |-> NID)    = .StateSet .
    eq states(N |-> S)      = S .
    eq states(NeENV NeENV') = states(NeENV) ;; states(NeENV') .

    op _[_] : Environment NodeId -> [Node] .
    ----------------------------------------
    eq (NID |-> ND ENV) [ NID ] = ND .

    op _|_|_ : LGraph Environment Nat -> BFS [prec 70 format(n n d n d d)] .
    ------------------------------------------------------------------------

    sorts Frontier BFS .
    --------------------
    subsort LGraph < BFS .

    var BFS : BFS .

    op .Frontier : -> Frontier .
    op _[_]_     : LGraph Depth LGraph -> Frontier [prec 65 format(d n d d n d)] .
    ------------------------------------------------------------------------------
    eq .LGraph [ D ] .LGraph = .Frontier .
    eq .LGraph [ D ] NeLG    = NeLG [ continue(D) ] .LGraph .

    op _|_ : LGraph Frontier -> BFS [right id: .Frontier prec 75 format(d n d d)] .
    -------------------------------------------------------------------------------
   ceq LG               | ENV  |   N | ND -[L]-> S LG' [ D ] LG''
     = LG ND -[L]-> ND' | ENV' | s N |             LG' [ D ] LG'' LG'''
    if { ND' , ENV' } := insert(s N |-> S, ENV)
    /\          LG''' := if (ND' < s N) then .LGraph else ND' -> step(S) fi .

    op insert-states : StateSet BFS Bound -> [BFS] .
    ------------------------------------------------
    eq insert-states(.StateSet, BFS, B)     = BFS .
    eq insert-states(NeSS ;; NeSS', BFS, B) = insert-states(NeSS', insert-states(NeSS, BFS, B), B) .
   ceq insert-states(S, LG | ENV | N, B) = LG | ENV' | s N | LG' [ 0 , B ] .LGraph
    if { ND , ENV' } := insert(s N |-> S, ENV)
    /\           LG' := if (ND < s N) then .LGraph else ND -> step(S) fi .

    op bfs : StateSet       -> BFS .
    op bfs : StateSet Bound -> BFS .
    --------------------------------
    eq bfs(SS)    = bfs(SS, unbounded) .
    eq bfs(SS, B) = insert-states(SS, .LGraph | .Environment | 0, B) .
endfm

fmod GRAPH-ANALYSIS is
   protecting GRAPH-FOLDING-SEARCH .
   protecting EXT-BOOL .

    var B : Bound . vars SS SS' : StateSet .
    var LG : LGraph . var ENV : Environment . var N : Nat .

    op check     _stable in_ :       StateSet StateSet -> [Bool] .
    op check [_] _stable in_ : Bound StateSet StateSet -> [Bool] .
    ----------------------------------------------------------------
    eq check       SS stable in SS' = check [ 1 ] SS stable in SS' .
   ceq check [ B ] SS stable in SS' = subsumes(SS', SS) and-then subsumes(states(ENV), SS')
                                   if LG | ENV | N := bfs(SS', B) .
endfm

fmod FVP-NARROWING-GRAPH is
   protecting NARROWING2 .
    extending GRAPH-FOLDING-SEARCH .
    extending META-LMC-PARAMETERS .

    var TYPE : Type . vars T T' : Term . var M : Module . var SUB : Substitution .
    vars SR SR' : StepResult . var SRS : StepResultSet . var RS : RuleSet .

    op label : RuleSet Substitution -> Label .
    ------------------------------------------

    op transition : StepResultSet -> [TransitionSet] .
    --------------------------------------------------
    eq transition({T , TYPE , SUB / RS }) = < label(RS, SUB) , state(T) > .
    eq transition(.StepResultSet)         = .TransitionSet .
    eq transition(SR || SR' || SRS)       = transition(SR) , transition(SR') , transition(SRS) .

    op state : Term         -> State .
    op fold  : Substitution -> Fold .
    ---------------------------------
    eq step(state(T))            = transition(metaNarrow2(##m##, T)) .
   ceq fold(state(T), state(T')) = fold(SUB) if SUB := metaMatch(##m##, T', T, nil, 0) .
endfm

fmod FVP-NARROWING-MODULO-T-GRAPH is
   protecting CTERM-SET .
   protecting SUBSTITUTIONSET .
   protecting FVP-NARROWING-GRAPH .
   protecting UNCONDITIONALIZE .

    vars T T' : Term . vars F F' : FOForm . var C : Condition . var AS : AttrSet . var Q : Qid .
    var TYPE : Type . var SUB : Substitution . var RS : RuleSet . vars SR SR' : StepResult . var SRS : StepResultSet .

    op side-condition : Condition -> FOForm .

    op ##m-stripped## : ~> SModule [memo] .
    ---------------------------------------
    eq ##m-stripped## = fromTemplate(qid(string(getName(##m##)) + "-NO-CONDITIONS"), stripConditions(asTemplate(##m##))) .

    op getLabel : RuleSet -> Qid .
    ------------------------------
    eq getLabel( rl T => T'      [label(Q) AS] .) = Q .
    eq getLabel(crl T => T' if C [label(Q) AS] .) = Q .

    op getCondition : RuleSet -> FOForm .
    -------------------------------------
    eq getCondition( rl T => T'      [AS] .) = tt .
    eq getCondition(crl T => T' if C [AS] .) = side-condition(C) .

    op lookupCondition : RuleSet -> FOForm .
    ----------------------------------------
    eq lookupCondition(RS) = getCondition(getRls(getLabel(RS), ##m##)) .

    op transition : StepResultSet FOForm -> [TransitionSet] .
    ---------------------------------------------------------
    eq transition({T , TYPE , SUB / RS }, F) = < label(RS, SUB) , state(T | F /\ getCondition(RS)) > .
    eq transition(.StepResultSet,         F) = .TransitionSet .
    eq transition(SR || SR' || SRS,       F) = transition(SR, F) , transition(SR', F) , transition(SRS, F) .

    op state : CTerm -> State .
    ---------------------------
    eq step(state(T | F)) = transition(metaNarrow2(##m-stripped##, T), F) .
   --- ceq fold(state(T | C), state(T' | C')) = fold(SUB) if SUB := metaMatch(##m##, T', T, nil, 0) .
endfm

eof

    sorts Constraint CState .
    subsort State < CState .
    ------------------------
    vars NeTS NeTS' : NeTransitionSet . var T : Term . var N : Nat .
    vars C C' : Constraint . var M : Module . vars S S' : State .
    var SUBST : Substitution . var SUBSTS : SubstitutionSet .

    op downConstraintError : -> [Constraint] .
    op _<<_ : Constraint Substitution -> Constraint .
    -------------------------------------------------
   ceq C << SUBST = C'
    if T  := upTerm(C) << SUBST
    /\ C' := downTerm(T, downConstraintError) .

    op unsatis? : Constraint            -> [Bool] .
    op entails? : Constraint Constraint -> [Bool] .
    -----------------------------------------------

    op _|_ : State Constraint -> CState .
    op <_,_> : Step CState -> Transition .
    --------------------------------------

    op step : Module CState -> [TransitionSet] .
    --------------------------------------------
    eq step(M, S | C) = updateTransitions(C, step(M, S)) .

    op updateTransitions : Constraint TransitionSet -> [TransitionSet] .
    --------------------------------------------------------------------
    eq updateTransitions(C, .TransitionSet) = .TransitionSet .
    eq updateTransitions(C, (NeTS , NeTS')) = updateTransitions(C, NeTS) , updateTransitions(C, NeTS') .

   ceq updateTransitions(C, < SUBST , S >) = .TransitionSet             if C' := C << SUBST /\ unsatis?(C') .
    eq updateTransitions(C, < SUBST , S >) = < SUBST , S | C << SUBST > [owise] .

    op allMatches : Module State State Nat -> [SubstitutionSet] .
    -------------------------------------------------------------
    eq allMatches(M, S, S', N) = none [owise] .
   ceq allMatches(M, S, S', N) = SUBST | allMatches(M, S, S', N + 1)
    if SUBST := metaMatch(M, upTerm(S'), upTerm(S), nil, N) .

    op fold : Module CState CState -> [Fold] .
    ------------------------------------------
   ceq fold(M, S | C, S' | C') = SUBST
    if SUBST | SUBSTS := allMatches(M, S, S', 0)
    /\ entails?(C', C << SUBST) .
endfm
