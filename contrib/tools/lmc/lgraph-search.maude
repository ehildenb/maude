set include BOOL off .

fmod LABELLED-GRAPH is

    sort State .
    ------------
    vars S S' : State .

    sorts Label LEdge NeLGraph LGraph .
    subsorts LEdge < NeLGraph < LGraph .
    ------------------------------------
    var L : Label . var NeLG : NeLGraph .

    op .LGraph : -> LGraph .
    op __      :   LGraph LGraph ->   LGraph [assoc comm id: .LGraph prec 55 format(d n d)] .
    op __      : NeLGraph LGraph -> NeLGraph [ditto] .
    --------------------------------------------------
    eq NeLG NeLG = NeLG .

    op _-[_]->_ : State Label State -> LEdge [prec 50] .
    ----------------------------------------------------

    sorts Transition NeTransitionSet TransitionSet .
    subsorts Transition < NeTransitionSet < TransitionSet .
    -------------------------------------------------------
    var TS : TransitionSet . vars NeTS NeTS' : NeTransitionSet .

    op .TransitionSet : -> TransitionSet .
    op _,_ :   TransitionSet TransitionSet ->   TransitionSet [assoc comm id: .TransitionSet] .
    op _,_ : NeTransitionSet TransitionSet -> NeTransitionSet [ditto] .
    -------------------------------------------------------------------
    eq NeTS , NeTS = NeTS .

    op <_,_> : Label State -> Transition .
    op _->_ : State TransitionSet -> LGraph [prec 50] .
    ---------------------------------------------------
    eq S -> .TransitionSet = .LGraph .
    eq S -> < L , S' >     = S -[ L ]-> S' .
    eq S -> NeTS , NeTS'   = S -> NeTS S -> NeTS' .
endfm

fmod GRAPH-FOLDING-SEARCH is
    protecting INT .
    extending LABELLED-GRAPH .

    vars N N' N'' : Nat . vars S S' S'' : State . var L : Label .
    var LE : LEdge . var LG : LGraph . vars NeLG NeLG' : NeLGraph .

    sorts Fold FState .
    subsort FState < State .
    ------------------------
    vars F F' : Fold . vars FS FS' : FState .

    op _[_] : Nat Fold  -> FState .
    -------------------------------

    op id : -> Fold .
    op fold : State State -> [Fold] .
    ---------------------------------
    eq fold(S, S) = id .

    op step : State -> [TransitionSet] .
    ------------------------------------
    eq step(FS) = .TransitionSet .

    sorts NeFrontier Frontier .
    subsort State < NeFrontier < Frontier .
    ---------------------------------------
    var FT : Frontier .

    op .Frontier : -> Frontier .
    op _,_       : Frontier   Frontier -> Frontier   [assoc id: .Frontier prec 45] .
    op _,_       : NeFrontier Frontier -> NeFrontier [ditto] .
    ----------------------------------------------------------

    sorts NeEnvironment Environment .
    subsort NeEnvironment < Environment .
    -------------------------------------
    var ENV : Environment . var NeENV : NeEnvironment .

    op _|->_ : Nat State -> NeEnvironment [prec 55] .
    -------------------------------------------------

    op .Environment : -> Environment .
    op _,_ :   Environment Environment ->   Environment [assoc id: .Environment prec 60] .
    op _,_ : NeEnvironment Environment -> NeEnvironment [ditto] .
    -------------------------------------------------------------
    eq NeENV , NeENV = NeENV .

    op [_:_] : Nat LGraph -> Environment .
    --------------------------------------
    eq [ N : .LGraph ]    = .Environment .
    eq [ N : NeLG NeLG' ] = [ N : NeLG ] , [ N : NeLG' ] .

    eq N |-> S , [ N' : LE ] = [ max(N, N') : LE ] , N |-> S [owise] .

    eq NeENV , [ N : FS -[L]-> FS' ] = [ N : FS -[L]-> FS' ] , NeENV .

    eq N |-> S , [ N' : (S  -[ L ]-> S')  ] = N |-> S , [ N' : N[id] -[ L ]-> S'    ] .
    eq N |-> S , [ N' : (S' -[ L ]-> S)   ] = N |-> S , [ N' : S'    -[ L ]-> N[id] ] .
   ceq N |-> S , [ N' : (S' -[ L ]-> S'') ] = N |-> S , [ N' : S'    -[ L ]-> N[F]  ] if F := fold(S'', S) .

    sort BFS .
    ----------

    op _|_|_ : LGraph Environment Frontier -> BFS [prec 70] .
    ---------------------------------------------------------
    eq LG | ENV | S , FT = LG | ENV , [ 0 : S -> step(S) ] | FT .

    eq LG | [ N'' : FS -[L]-> FS' ] , ENV | FT = LG FS -[L]-> FS'         |               ENV | FT .
    eq LG | [ N'' : FS -[L]-> S   ] , ENV | FT = LG FS -[L]-> (s N'')[id] | s N'' |-> S , ENV | FT , S [owise] .

    op bfs : State -> BFS .
    -----------------------
    eq bfs(S) = .LGraph | .Environment | S .

--- ;    op {_|_} : LGraph Environment -> BFS .
--- ;    --------------------------------------
--- ;    eq { LG N -[ L ]-> N' | ENV N |-> S }
--- ;     = { LG S -[ L ]-> N' | ENV N |-> S } .
--- ;
--- ;    eq { LG N -[ L ]-> N' | ENV N' |-> S }
--- ;     = { LG N -[ L ]-> S  | ENV N' |-> S } .
--- ;
--- ;    eq { LG | ENV } = LG [owise] .
--- ;
--- ;    op [_|_|_|_] : LGraph NodeList Environment Nat -> BFS .
--- ;    op {_|_|_|_} : LGraph NodeList Environment Nat -> BFS .
--- ;    -------------------------------------------------------
--- ;   ceq [ LG                | N , NL | (N |-> S) (N' |-> S') ENV | M? ]
--- ;     = [ LG N -[ FL ]-> N' |     NL | (N |-> S) (N' |-> S') ENV | M? ]
--- ;    if FL := fold(S, S') .
--- ;
--- ;    eq [ LG | NL | ENV | M? ] = { LG | NL | ENV | M? } [owise] .
--- ;
--- ;    eq { LG | .NodeList | ENV | M? } = { LG | ENV } .
--- ;
--- ;    op {_|_:_|_|_|_} : LGraph Node TransitionSet NodeList Environment Nat -> BFS .
--- ;    ------------------------------------------------------------------------------
--- ;    eq { LG | N : .TransitionSet | NL | ENV | M? } = [ LG | NL | ENV | M? ] .
--- ;
--- ;    eq { LG               | N , NL | ENV N |-> S | M? }
--- ;     = { LG | N : step(S) |     NL | ENV N |-> S | M? } .
--- ;
--- ;    eq { LG                | N : TS , < SL , S > | NL | ENV N' |-> S | M? }
--- ;     = { LG N -[ SL ]-> N' | N : TS              | NL | ENV N' |-> S | M? } .
--- ;
--- ;    eq { LG               | N : TS , < SL , S > | NL     | ENV         | M     }
--- ;     = { LG N -[ SL ]-> M | N : TS              | NL , M | ENV M |-> S | M - 1 } [owise] .
--- ;
--- ;    op bfs : State NzNat -> BFS .
--- ;    -----------------------------
--- ;    eq bfs(S, M) = { .LGraph | M | M |-> S | M - 1 } .
endfm
