--- The Maude Logical Bounded Model Checker Interface
--- Author: Kyungmin Bae <kbae4@illinois.edu>

load ../base/model-checker.maude

****************************************
***          Basic Interface         ***
****************************************

fmod RULE-NAME is
    extending QID .

    sort RuleName .
    ---------------
    subsort Qid < RuleName .

    ops unlabeled deadlock : -> RuleName .
    --------------------------------------
endfm

fmod SYMBOLIC-CHECKER is
   protecting RULE-NAME .
   protecting SATISFACTION .
    including LTL .

    subsort Prop < Formula .

    --- generic substitution for counter example
    sorts CEAssignment CESubstitution .
    -----------------------------------
    subsort CEAssignment < CESubstitution .

    op _<-_ : Qid Universal -> CEAssignment [ctor poly (2) prec 63] .
    -----------------------------------------------------------------

    op none :                               -> CESubstitution .
    op _;_  : CESubstitution CESubstitution -> CESubstitution [ctor assoc comm id: none prec 65] .
    ----------------------------------------------------------------------------------------------
    eq CA:CEAssignment ; CA:CEAssignment = CA:CEAssignment .

    sorts Transition TransitionList .
    ---------------------------------
    subsort Transition < TransitionList .

    op {_,_,_} : State CESubstitution RuleName -> Transition [ctor] .
    -----------------------------------------------------------------

    op nil :                               -> TransitionList [ctor] .
    op __  : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .
    -----------------------------------------------------------------------------------------------

    sort ModelCheckResult .
    -----------------------
    subsort Bool < ModelCheckResult .

    op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .
    ----------------------------------------------------------------------------------------------------
endfm

**************************************************
***    Logical Model Checker on META-LEVEL     ***
**************************************************

--- core maude search function (using META-LEVEL)
fmod BOUNDED-FOLDING-MODEL-CHECKER is
   protecting RULE-NAME .
   protecting META-LEVEL .
   protecting SATISFACTION .
    including LTL .

    --- meta transition
    sorts MetaEdge MetaConf .
    -------------------------

    op <_>   : State          -> MetaConf [ctor] .
    op _|=>_ : MetaEdge State -> MetaConf [ctor] .
    ----------------------------------------------

    op deadlock :                      -> MetaEdge [ctor] .
    op _/_      : RuleSet Substitution -> MetaEdge [ctor] .
    -------------------------------------------------------

    --- propositions
    subsort Prop < Formula .
    ------------------------

    op prop : Term -> Prop [ctor] .
    -------------------------------

    --- folding relation
    op _>=_ : State State -> Bool .
    op _~=_ : State State -> Bool .
    -------------------------------

    op _~_  : MetaEdge MetaEdge -> Bool .
    -------------------------------------
    eq deadlock ~ deadlock = true .

    --- print state during model checking (debugging purpose)
    op prettyPrint : State    ~> QidList .
    op prettyPrint : MetaEdge ~> QidList .
    --------------------------------------

    --- transitions
    sort Transition TransitionList .
    --------------------------------
    subsort Transition < TransitionList .

    op {_,_} : State MetaEdge                -> Transition [ctor] .
    ---------------------------------------------------------------

    op nil   :                               -> TransitionList [ctor] .
    op __    : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .
    -------------------------------------------------------------------------------------------------

    --- model checking results
    sorts ModelCheckResult .
    ------------------------
    subsort Bool < ModelCheckResult .

    op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .
    ----------------------------------------------------------------------------------------------------

    --- bounded model checker report
    sort BoundedModelCheckReport .
    ------------------------------

    op result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool -> BoundedModelCheckReport [ctor] .
    -------------------------------------------------------------------------------------------------------

    --- model checker
    --- (InitState,Formula,SubsumptionFolding,Bound)
    op symbolicModelCheck : State Formula Bool Bound ~> BoundedModelCheckReport
     [ special ( id-hook SymbolicModelCheckerSymbol

                 --- temporal operators
                 op-hook trueSymbol              (True : ~> Formula)
                 op-hook falseSymbol             (False : ~> Formula)
                 op-hook notSymbol               (~_ : Formula ~> Formula)
                 op-hook nextSymbol              (O_ : Formula ~> Formula)
                 op-hook andSymbol               (_/\_ : Formula Formula ~> Formula)
                 op-hook orSymbol                (_\/_ : Formula Formula ~> Formula)
                 op-hook untilSymbol             (_U_ : Formula Formula ~> Formula)
                 op-hook releaseSymbol           (_R_ : Formula Formula ~> Formula)

                 --- for Bound attribute
                 op-hook succSymbol              (s_ : Nat ~> NzNat)
                 op-hook unboundedSymbol         (unbounded : ~> Bound)

                 --- state propositions
                 op-hook satisfiesSymbol         (_|=_ : State Formula ~> Bool)
                 term-hook trueTerm              (true)

                 --- folding graph stuff
                 op-hook subsumeFoldingRelSymbol (_>=_ : State State ~> Bool)
                 op-hook renameFoldingRelSymbol  (_~=_ : State State ~> Bool)
                 op-hook compatibleTransSymbol   (_~_  : MetaEdge MetaEdge ~> Bool)

                 op-hook prettyPrintStateSymbol  (prettyPrint : State ~> QidList)
                 op-hook prettyPrintTransSymbol  (prettyPrint : MetaEdge ~> QidList)

                 --- meta graph
                 op-hook metaStateSymbol         (<_> : State ~> MetaConf)
                 op-hook metaTransitionSymbol    (_|=>_ : MetaEdge State ~> MetaConf)

                 --- counterexamples
                 term-hook falseTerm             (false)
                 term-hook deadlockTerm          ((deadlock).MetaEdge)

                 op-hook transitionSymbol        ({_,_} : State MetaEdge ~> Transition)
                 op-hook transitionListSymbol    (__ : TransitionList TransitionList ~> TransitionList)
                 op-hook nilTransitionListSymbol (nil : ~> TransitionList)
                 op-hook counterexampleSymbol    (prefix_loop_ : TransitionList TransitionList ~> ModelCheckResult)

                 --- result report
                 op-hook resultreportSymbol      (result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool ~> BoundedModelCheckReport)
               )
     ] .
endfm


****************************************
***  Full Maude Narrowing Connector  ***
****************************************

load ../meta/unification.maude

fmod META-LMC-PARAMETERS is
   protecting META-MODULE .

    --- empty! the user module shoule define them.
    op ##m## : ~> SModule  [memo] .
    op ##f## : ~> TermList [memo] .
endfm

fmod LMC-RESULT-SET is
   protecting RESULT-CONTEXT-SET .

    sort StepResult StepResult? .
    -----------------------------
    subsort StepResult < StepResult? .

    op failure   : -> StepResult? [ctor] .
    op {_,_,_/_} : Term Type Substitution RuleSet -> StepResult [ctor] .
    --------------------------------------------------------------------

    sort StepResultSet .
    --------------------
    subsort StepResult < StepResultSet .

    var M : Module . vars NextVar : Nat . vars S S' : Substitution .
    vars T TS CtTS : Term . var TL : TermList . var TP : Type . var R : Rule .
    var Tr : TraceNarrow . var B : Flags . vars Ct CtS : Context .
    var SR : StepResult . var RTS : ResultContextSet . var SRS : StepResultSet .

    op empty :                             -> StepResultSet [ctor] .
    op _||_  : StepResultSet StepResultSet -> StepResultSet [ctor assoc comm id: empty prec 65] .
    ---------------------------------------------------------------------------------------------
    eq SR || SR = SR .

    op to4Tuple : Module ResultContextSet -> StepResult .
    -----------------------------------------------------
    eq to4Tuple(M, empty ) = empty .
    eq to4Tuple(M, {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr,B} | RTS )
     = {CtTS, leastSort(M,CtTS), S .. S' / getRuleSet(Tr)} || to4Tuple(M, RTS) .

    op _|>_ : StepResult TermList -> StepResult .
    ---------------------------------------------
    eq (empty).StepResult    |> TL = (empty).StepResult .
    eq ({T,TP,S / R} || SRS) |> TL = {T,TP,S |> TL / R} || (SRS |> TL) .
    eq (failure      || SRS) |> TL = failure || (SRS |> TL) .

    op getRuleSet : TraceNarrow -> RuleSet .
    ----------------------------------------
    eq getRuleSet(nil)           = none .
    eq getRuleSet({T,S,TP,R} Tr) = R getRuleSet(Tr) .

    sort VariantSet .
    -----------------
    subsort Variant < VariantSet .

    op emptyVariantSet :                       -> VariantSet [ctor] .
    op _#_             : VariantSet VariantSet -> VariantSet [ctor assoc comm id: emptyVariantSet prec 65 format (d d n d)] .
    -------------------------------------------------------------------------------------------------------------------------
    eq X:Variant # X:Variant = X:Variant .
endfm

mod META-LMC-THEORY is
   protecting LMC-RESULT-SET .
   protecting META-LMC-PARAMETERS .
   protecting BOUNDED-FOLDING-MODEL-CHECKER .

    vars T1 T2 ST ST' : Term . vars SUB SUB' : Substitution .
    var RS : RuleSet . var CD : Condition . var Q : Qid .
    var TP : Type .  var SRS : StepResultSet .

    ops init mid : Term -> State [ctor] .
    -------------------------------------

    --- functions
    ops next variant : Term -> StepResultSet .
    ------------------------------------------

    --- meta rules
    crl [init] :
        < init(ST) >
     => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')))
     if {ST',TP,SUB' / RS} || SRS := variant(ST) .

    crl [mid] :
        < mid(ST) >
     => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')))
     if {ST',TP,SUB' / RS} || SRS := next(ST) .
endm

fmod META-NARROWING-INTERFACE is
   protecting META-LMC-PARAMETERS .
   protecting LMC-RESULT-SET .
   protecting META-NARROWING-SEARCH .

    var M : Module . var RS : RuleSet .
    vars T T' T1 T2 ST PT : Term .  var TL : TermList .  var C : Constant .
    var TP : Type . vars SUB SUB1 SUB2 : Substitution .
    vars NextVar NextVar' N : Nat . var VR : Variant . var VS : VariantSet .
    var P : Parent . var B : Bool .
    var SR : StepResult . var SRS : StepResultSet .
    var TYPE : Type . var RL : Qid .
    var H : Header . var IL : ImportList . var SS : SortSet . var SSDS : SubsortDeclSet .
    var ODS : OpDeclSet . var MAS : MembAxSet . var EQS : EquationSet . var RLS : RuleSet .
    var AS : AttrSet . var CTX : Context . var Q : Qid .

    op metaNarrow2 : Module Term -> StepResult .
    --------------------------------------------
    eq metaNarrow2(M,T) = to4Tuple(M,metaENarrowShowAll(M,T,1,full noStrategy BuiltIn-unify)) |> T .

    op allNarrowSteps : Module Term     -> [StepResultSet] .
    op allNarrowSteps : Module Term Nat -> [StepResultSet] .
    --------------------------------------------------------
    eq allNarrowSteps(M, T) = allNarrowSteps(M, T, 0) .

    eq allNarrowSteps(M, T, N) = empty [owise] .
   ceq allNarrowSteps(M, T, N) = { T' , TYPE , SUB1 / getRls(RL, M) } || allNarrowSteps(M, T, N + 1)
    if { T' , TYPE , CTX , RL , SUB1 , SUB2 , Q } := metaNarrowingApply(M, T, empty, '#, N) .

    op metaGenVariant : Module Term -> VariantSet .
    -----------------------------------------------
    eq metaGenVariant(M, T) = metaGenVariant(M, T, highestVar(T)) .

    op metaGenVariant : Module Term Nat -> VariantSet .
    ---------------------------------------------------
    eq metaGenVariant(M, T, NextVar) = metaGenVariant2(M, T, NextVar, 0) .

    op metaGenVariant2 : Module Term Nat Nat -> VariantSet .
    --------------------------------------------------------
    eq metaGenVariant2(M, T, NextVar, N) = emptyVariantSet [owise] .
   ceq metaGenVariant2(M, T, NextVar, N) = VR # metaGenVariant2(M,T,NextVar,s N)
    if VR := metaGetVariant(M,T,empty,NextVar,N) .

    --- variant narrowing prop instantiations.
    --- compute the PI-instantated states of the given state.

    --- StateSet PropSet -> StateSet
    op propSetInstSet : StepResultSet TermList ~> StepResultSet .
    -------------------------------------------------------------
    eq propSetInstSet(SRS, empty)   = SRS .
    eq propSetInstSet(SRS, (PT,TL)) = propSetInstSet(propInstSet(SRS, PT), TL) .

    --- StateSet Prop -> StateSet
    op propInstSet : StepResultSet Term ~> StepResultSet .
    ------------------------------------------------------
    eq propInstSet(empty, PT) = empty .
    eq propInstSet({ST,TP,SUB / RS} || SRS, PT)
     = filterPropVars({ST,TP,SUB / RS}, metaGenVariant(##m##, '_|=_[ST, PT])) || propInstSet(SRS, PT) .

    op filterPropVars : StepResult VariantSet ~> StepResultSet .
    ------------------------------------------------------------
    eq filterPropVars(SR, emptyVariantSet) = empty .
    eq filterPropVars({ST,TP,SUB / RS}, {T,SUB1,N,P,B} # VS)
     = if inst?(T) then {ST << SUB1,TP, SUB .. SUB1 / RS} else empty fi || filterPropVars({ST,TP,SUB / RS}, VS) .

    --- TODO: by not filtering, we may allow more patterns that are not reduced
    --- to true/false. However, it easily generates spurious counter examples..
    --- We may adopt this with abstract refinement techniques..
    --- But with filtering, the |= equations should be total...

    op inst? : Term ~> Bool .
    -------------------------
    eq inst?('true.Bool)  = true .
    eq inst?('false.Bool) = true .
    eq inst?(T)           = false [owise] .
endfm

mod META-SYMBOLIC-CONNECTOR is
   protecting META-LMC-THEORY .
   protecting BOUNDED-FOLDING-MODEL-CHECKER .
   protecting META-NARROWING-INTERFACE .
   protecting DECL-META-PRETTY-PRINT * ( op addOps to addOpsSE
                                       , op addEqs to addEqsSE
                                       , op addSorts to addSortsSE
                                       ) .

    var M : Module .  vars T T' T1 T2 ST ST' PT CT : Term .
    var RN : RuleName . var RS : RuleSet . var TL : TermList .
    var V : Variable . var TP : Type . vars SUB SUB' SUB'' : Substitution .
    var B : Bool . var N : Nat . var D : Bound . var A : Assignment .
    var RT : ResultTriple .  var RTS : ResultTripleSet .

    --- meta prop and state
    eq mid(ST) |= prop(PT) = getTerm(metaReduce(##m##, '_|=_[ST, PT])) == 'true.Bool .

    --- state folding
    eq init(ST) >= init(ST) = true .
    eq  mid(ST) >= mid(ST') = metaMatch(##m##, ST, ST', nil, 0) :: Substitution .
    eq S1:State >= S2:State = false [owise] .

    --- renaming folding
    eq init(ST) ~= init(ST) = true .
    eq  mid(ST) ~= mid(ST') = mid(ST) >= mid(ST') and-then mid(ST') >= mid(ST) .
    eq S1:State ~= S2:State = false [owise] .

    --- compute the next states
    --- TODO: keep both a state and a substitution for a counter example..
    eq    next(ST) = propSetInstSet(metaNarrow2(##m##, ST), ##f##) .
    eq variant(ST) = propSetInstSet({ST,leastSort(##m##,ST),none / none}, ##f##) .

    --- run LMC model check : State Formula -> Result
    op lmc-check : Term Term Bool Bound ~> BoundedModelCheckReport .
    ----------------------------------------------------------------
   ceq lmc-check(ST, PT, B, D) = symbolicModelCheck(init(ST), O tilde(##m##,PT), B, D)
    if sortLeq(##m##, leastSort(##m##,ST), 'State)
    /\ sortLeq(##m##, leastSort(##m##,PT), 'Formula) .

    --- meta formula
    op tilde : Module Term -> Formula .
    -----------------------------------
   ceq tilde(M, PT)             = prop(PT) if sortLeq(M,leastSort(M,PT),'Prop) .
    eq tilde(M, 'True.Formula)  = True .
    eq tilde(M, 'False.Formula) = False .
    eq tilde(M, '~_[T])         = ~ tilde(M, T) .
    eq tilde(M, '_/\_[T, T'])   = tilde(M, T) /\ tilde(M, T') .
    eq tilde(M, '_\/_[T, T'])   = tilde(M, T) \/ tilde(M, T') .
    eq tilde(M, 'O_[T])         = O tilde(M, T) .
    eq tilde(M, '_U_[T, T'])    = tilde(M, T) U tilde(M, T') .
    eq tilde(M, '_R_[T, T'])    = tilde(M, T) R tilde(M, T') .

    --- pretty print (for debugging)
    eq prettyPrint(init(ST)) = eMetaPrettyPrint(##m##, ST) .
    eq prettyPrint(mid(ST))  = eMetaPrettyPrint(##m##, ST) .
    eq prettyPrint(RS / SUB) = eMetaPrettyPrint(##m##, RS) '/ prettyPrintSub(SUB) .

    op prettyPrintSub : Substitution -> QidList .
    ---------------------------------------------
    eq prettyPrintSub(none)             = 'none .
    eq prettyPrintSub(V <- T)           = V '<- eMetaPrettyPrint(##m##,T) .
    eq prettyPrintSub(V <- T ; A ; SUB) = V '<- eMetaPrettyPrint(##m##,T) '; prettyPrintSub(A ; SUB) .
endm

*****************************************************
***  Full Maude Narrowing Connector  (Condition)  ***
*****************************************************

--- NOTE: currently, only considering "T = true"

mod META-LMC-COND-THEORY is
   protecting META-LMC-THEORY .

   ops init mid : Term EqCondition -> State [ctor] .
    ------------------------------------------------
endm

fmod META-NARROWING-COND-INTERFACE is
   protecting META-NARROWING-INTERFACE .

   vars T T1 T2 ST PT : Term .  var TL : TermList .
    var C : Constant . var CD : EqCondition . var RS : RuleSet .
    var TP : Type . vars SUB SUB1 SUB2 : Substitution .  var N : Nat .
    var SR : StepResult . var SRS : StepResultSet . var VS : VariantSet .
    var P : Parent . var B : Bool .

    --- variant narrowing condition instantiations.

    --- StateSet EqCondition -> StateSet
    op condSetInstSet : StepResultSet EqCondition ~> StepResultSet .
    ----------------------------------------------------------------
    eq condSetInstSet(SRS, nil)                  = SRS .
    eq condSetInstSet(SRS, T = 'true.Bool /\ CD) = condSetInstSet(condInstSet(SRS, T), CD) .

    --- StateSet Prop -> StateSet
    op condInstSet : StepResultSet Term ~> StepResultSet .
    ------------------------------------------------------
    eq condInstSet(empty, T)                   = empty .
   ceq condInstSet({ST,TP,SUB / RS} || SRS, T) = filterCondVars({ST,TP,SUB / RS}, VS) || condInstSet(SRS, T)
    if VS := metaGenVariant(##m##, T << SUB) .

    --- only true instances (hence the conditions should be complete and FVP)
    op filterCondVars : StepResult VariantSet ~> StepResultSet .
    ------------------------------------------------------------
    eq filterCondVars(SR, VS) = empty [owise] .
    eq filterCondVars({ST,TP,SUB / RS}, {'true.Bool,SUB1,N,P,B} # VS)
     = {ST << SUB1, TP, SUB .. SUB1 / RS} || filterCondVars({ST,TP,SUB / RS}, VS) .

    --- applying substitution to condition
    op _<<_ : EqCondition Substitution ~> EqCondition .
    ---------------------------------------------------
    eq nil << SUB = (nil).EqCondition .
    eq (T1  = T2   /\ CD) << SUB = ((T1 << SUB) = (T2 << SUB)) /\ (CD << SUB) .
    eq (T1 := T2   /\ CD) << SUB = ((T1 << SUB) = (T2 << SUB)) /\ (CD << SUB) .
    eq (T : S:Sort /\ CD) << SUB = ((T << SUB) : S:Sort)       /\ (CD << SUB) .
endfm

mod META-SYMBOLIC-COND-CONNECTOR-BASE is
   protecting META-LMC-COND-THEORY .
   protecting META-SYMBOLIC-CONNECTOR .
   protecting META-NARROWING-COND-INTERFACE .

    var M : Module .  vars T T' T1 T2 ST ST' PT CT : Term .
    var TL : TermList .  var V : Variable .
    var TP : Type . vars SUB SUB' SUB'' : Substitution .
    var B : Bool . var N : Nat . var D : Bound .
    var RT : ResultTriple .  var RTS : ResultTripleSet .
   vars CD CD' : EqCondition .

    --- meta prop and state
    eq mid(ST,CD) |= prop(PT) = getTerm(metaReduce(##m##, '_|=_[ST, PT])) == 'true.Bool .

    --- with condition
    op lmc-check : Term Term EqCondition Bool Bound ~> BoundedModelCheckReport .
    ----------------------------------------------------------------------------
   ceq lmc-check(ST, PT, CD, B, D)
     = if CD == nil
       then symbolicModelCheck(init(ST), O tilde(##m##,PT), B, D)
       else symbolicModelCheck(init(ST,CD), O tilde(##m##,PT), B, D)
       fi
    if sortLeq(##m##, leastSort(##m##,ST), 'State)
    /\ sortLeq(##m##, leastSort(##m##,PT), 'Formula) .

    --- normalize conditions (modulo equation)
    --- NOTE: metaNormalize vs. metaReduce??  metaNormalize generates slightly
    --- more states for (state,condition) pairs if there exists equaltional
    --- abstraction, but it will be more correct since we do not worry about
    --- whether some variables is removed by such equations...
    op condNorm : EqCondition ~> EqCondition .
    ------------------------------------------
    eq condNorm(nil)                  = nil .
    eq condNorm(T = 'true.Bool /\ CD) = getTerm(metaNormalize(##m##,T)) = 'true.Bool /\ condNorm(CD) .

    --- pretty print (for debugging)
    eq prettyPrint(init(ST,CD)) = prettyPrint(init(ST)) '\n '\t eMetaPrettyPrint(##m##, CD) .
    eq prettyPrint(mid(ST,CD))  = prettyPrint(mid(ST)) '\n '\t eMetaPrettyPrint(##m##, CD) .
endm

--- Conditions are solved for generating states by variant narrowing
mod META-SYMBOLIC-COND-CONNECTOR is
   protecting META-SYMBOLIC-COND-CONNECTOR-BASE .

    var M : Module .  vars T T' T1 T2 ST ST' PT CT : Term .
    var TL : TermList .  var V : Variable .
    var TP : Type . vars SUB SUB' SUB'' : Substitution .  var N : Nat .
    var SR : StepResult .  var SRS : StepResultSet .
   vars CD CD' : EqCondition . var RS : RuleSet .

   --- meta rules
   crl [init-cond] :
       < init(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := variant(ST,CD) .

   crl [mid-cond] :
       < mid(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := next(ST,CD) .

   ops next variant : Term EqCondition -> StepResultSet .
    -----------------------------------------------------
    eq next(ST,CD)    = propSetInstSet(condSetInstSet(metaNarrow2(##m##, ST),CD), ##f##) .
    eq variant(ST,CD) = propSetInstSet(condSetInstSet({ST,leastSort(##m##,ST),none / none},CD), ##f##) .

    --- condition should be already considered by variant narrowing
    eq mid(ST,CD) >= mid(ST',CD') = mid(ST)    >= mid(ST') .
    eq mid(ST,CD) ~= mid(ST',CD') = mid(ST,CD) >= mid(ST',CD') and-then mid(ST',CD') >= mid(ST,CD) .
endm

--- Folding conditions C >= C' by checking C' => \rho(C) using variant narrowing
mod META-SYMBOLIC-COND-CONNECTOR2 is
   protecting META-SYMBOLIC-COND-CONNECTOR-BASE .

   vars T T' T1 T2 ST ST' PT CT : Term .
    var TL : TermList .  var V : Variable .
    var TP : Type . vars SUB SUB' SUB'' : Substitution .
    var N : Nat . var B : Bool . var RS : RuleSet .
    var SR : StepResult .  var SRS : StepResultSet .
    vars CD CD' : EqCondition .  var VS : VariantSet .
    var P : Parent .

    --- meta rules
   crl [init-cond] :
       < init(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := variant(ST) /\ condOK(CD << SUB') .

   crl [mid-cond]  :
       < mid(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := next(ST) /\ condOK(CD << SUB') .

    --- Another method to check a condition.
    op condOK : EqCondition ~> Bool .
    ---------------------------------
    eq condOK(nil)                   = true .
    eq condOK(T1 = 'true.Bool /\ CD) = (not getTerm(metaReduce(##m##, T1)) == 'false.Bool) and-then condOK(CD) .

    --- folding with conditions
    eq mid(ST,CD) >= mid(ST',CD') = condFold(ST, CD, ST', CD', 0) .
    eq mid(ST,CD) ~= mid(ST',CD') = mid(ST,CD) >= mid(ST',CD') and-then mid(ST',CD') >= mid(ST,CD) .

    op condFold : Term EqCondition Term EqCondition Nat -> Bool .
    -------------------------------------------------------------
    eq condFold(ST, CD, ST', CD', 0)    = false [owise] .
    eq condFold(ST, CD, ST', CD', s(N)) = true  [owise] .
   ceq condFold(ST, CD, ST', CD', N)    = implyOK(CD', CD << SUB) and-then condFold(ST, CD, ST', CD', s(N))
    if SUB := metaMatch(##m##, ST, ST', nil, N) .

    --- check if the implecation (C1 /\ not C2) has no "true" solution
    op implyOK : EqCondition EqCondition ~> Bool .
    ----------------------------------------------
   ceq implyOK(CD, CD') = implyOKsub(VS)
    if VS := metaGenVariant(##m##,'_and_[condList(CD,true), '_or_[condList(CD',false)]]) .

    op implyOKsub : VariantSet ~> Bool .
    ------------------------------------
    eq implyOKsub(emptyVariantSet)    = true .
   ceq implyOKsub({T,SUB,N,P,B} # VS) = T' =/= 'true.Bool and-then implyOKsub(VS)
    if T' := getTerm(metaReduce(##m##,T)) .

    op condList : EqCondition Bool ~> TermList .
    --------------------------------------------
    eq condList(nil, B)                  = if B then 'true.Bool else 'false.Bool fi .
    eq condList(T = 'true.Bool /\ CD, B) = if B then T else 'not_[T] fi, condList(CD, B) .
endm
