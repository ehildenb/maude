--- The Maude Logical Bounded Model Checker Interface
--- Author: Kyungmin Bae <kbae4@illinois.edu>

load ../base/model-checker.maude

****************************************
***          Basic Interface         ***
****************************************

fmod RULE-NAME is
    extending QID .

    sort RuleName .
    ---------------
    subsort Qid < RuleName .

    ops unlabeled deadlock : -> RuleName .
    --------------------------------------
endfm

fmod SYMBOLIC-CHECKER is
   protecting RULE-NAME .
   protecting SATISFACTION .
    including LTL .

    subsort Prop < Formula .

    --- generic substitution for counter example
    sorts CEAssignment CESubstitution .
    -----------------------------------
    subsort CEAssignment < CESubstitution .

    op _<-_ : Qid Universal -> CEAssignment [ctor poly (2) prec 63] .
    -----------------------------------------------------------------

    op none :                               -> CESubstitution .
    op _;_  : CESubstitution CESubstitution -> CESubstitution [ctor assoc comm id: none prec 65] .
    ----------------------------------------------------------------------------------------------
    eq CA:CEAssignment ; CA:CEAssignment = CA:CEAssignment .

    sorts Transition TransitionList .
    ---------------------------------
    subsort Transition < TransitionList .

    op {_,_,_} : State CESubstitution RuleName -> Transition [ctor] .
    -----------------------------------------------------------------

    op nil :                               -> TransitionList [ctor] .
    op __  : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .
    -----------------------------------------------------------------------------------------------

    sort ModelCheckResult .
    -----------------------
    subsort Bool < ModelCheckResult .

    op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .
    ----------------------------------------------------------------------------------------------------
endfm

**************************************************
***    Logical Model Checker on META-LEVEL     ***
**************************************************

--- core maude search function (using META-LEVEL)
fmod BOUNDED-FOLDING-MODEL-CHECKER is
   protecting RULE-NAME .
   protecting META-LEVEL .
   protecting SATISFACTION .
    including LTL .

    --- meta transition
    sorts MetaEdge MetaConf .
    -------------------------

    op <_>   : State          -> MetaConf [ctor] .
    op _|=>_ : MetaEdge State -> MetaConf [ctor] .
    ----------------------------------------------

    op deadlock :                      -> MetaEdge [ctor] .
    op _/_      : RuleSet Substitution -> MetaEdge [ctor] .
    -------------------------------------------------------

    --- propositions
    subsort Prop < Formula .
    ------------------------

    op prop : Term -> Prop [ctor] .
    -------------------------------

    --- folding relation
    op _>=_ : State State -> Bool .
    op _~=_ : State State -> Bool .
    -------------------------------

    op _~_  : MetaEdge MetaEdge -> Bool .
    -------------------------------------
    eq deadlock ~ deadlock = true .

    --- print state during model checking (debugging purpose)
    op prettyPrint : State    ~> QidList .
    op prettyPrint : MetaEdge ~> QidList .
    --------------------------------------

    --- transitions
    sort Transition TransitionList .
    --------------------------------
    subsort Transition < TransitionList .

    op {_,_} : State MetaEdge                -> Transition [ctor] .
    ---------------------------------------------------------------

    op nil   :                               -> TransitionList [ctor] .
    op __    : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .
    -------------------------------------------------------------------------------------------------

    --- model checking results
    sorts ModelCheckResult .
    ------------------------
    subsort Bool < ModelCheckResult .

    op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .
    ----------------------------------------------------------------------------------------------------

    --- bounded model checker report
    sort BoundedModelCheckReport .
    ------------------------------

    op result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool -> BoundedModelCheckReport [ctor] .
    -------------------------------------------------------------------------------------------------------

    --- model checker
    --- (InitState,Formula,SubsumptionFolding,Bound)
    op symbolicModelCheck : State Formula Bool Bound ~> BoundedModelCheckReport
     [ special ( id-hook SymbolicModelCheckerSymbol

                 --- temporal operators
                 op-hook trueSymbol              (True : ~> Formula)
                 op-hook falseSymbol             (False : ~> Formula)
                 op-hook notSymbol               (~_ : Formula ~> Formula)
                 op-hook nextSymbol              (O_ : Formula ~> Formula)
                 op-hook andSymbol               (_/\_ : Formula Formula ~> Formula)
                 op-hook orSymbol                (_\/_ : Formula Formula ~> Formula)
                 op-hook untilSymbol             (_U_ : Formula Formula ~> Formula)
                 op-hook releaseSymbol           (_R_ : Formula Formula ~> Formula)

                 --- for Bound attribute
                 op-hook succSymbol              (s_ : Nat ~> NzNat)
                 op-hook unboundedSymbol         (unbounded : ~> Bound)

                 --- state propositions
                 op-hook satisfiesSymbol         (_|=_ : State Formula ~> Bool)
                 term-hook trueTerm              (true)

                 --- folding graph stuff
                 op-hook subsumeFoldingRelSymbol (_>=_ : State State ~> Bool)
                 op-hook renameFoldingRelSymbol  (_~=_ : State State ~> Bool)
                 op-hook compatibleTransSymbol   (_~_  : MetaEdge MetaEdge ~> Bool)

                 op-hook prettyPrintStateSymbol  (prettyPrint : State ~> QidList)
                 op-hook prettyPrintTransSymbol  (prettyPrint : MetaEdge ~> QidList)

                 --- meta graph
                 op-hook metaStateSymbol         (<_> : State ~> MetaConf)
                 op-hook metaTransitionSymbol    (_|=>_ : MetaEdge State ~> MetaConf)

                 --- counterexamples
                 term-hook falseTerm             (false)
                 term-hook deadlockTerm          ((deadlock).MetaEdge)

                 op-hook transitionSymbol        ({_,_} : State MetaEdge ~> Transition)
                 op-hook transitionListSymbol    (__ : TransitionList TransitionList ~> TransitionList)
                 op-hook nilTransitionListSymbol (nil : ~> TransitionList)
                 op-hook counterexampleSymbol    (prefix_loop_ : TransitionList TransitionList ~> ModelCheckResult)

                 --- result report
                 op-hook resultreportSymbol      (result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool ~> BoundedModelCheckReport)
               )
     ] .
endfm


****************************************
***  Full Maude Narrowing Connector  ***
****************************************

load ../meta/narrowing.maude

fmod META-LMC-PARAMETERS is
   protecting META-MODULE .

    --- empty! the user module shoule define them.
    op ##m## : ~> SModule  [memo] .
    op ##f## : ~> TermList [memo] .
endfm

mod META-LMC-THEORY is
   protecting NARROWING-STEP-SET .
   protecting META-LMC-PARAMETERS .
   protecting BOUNDED-FOLDING-MODEL-CHECKER .

    vars T1 T2 ST ST' : Term . vars SUB SUB' : Substitution .
    var RS : RuleSet . var CD : Condition . var Q : Qid .
    var TP : Type .  var SRS : StepResultSet .

    ops init mid : Term -> State [ctor] .
    -------------------------------------

    --- functions
    ops next variant : Term -> StepResultSet .
    ------------------------------------------

    --- meta rules
    crl [init] :
        < init(ST) >
     => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')))
     if {ST',TP,SUB' / RS} || SRS := variant(ST) .

    crl [mid] :
        < mid(ST) >
     => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')))
     if {ST',TP,SUB' / RS} || SRS := next(ST) .
endm

fmod META-NARROWING-INTERFACE is
   protecting META-LMC-PARAMETERS .
   protecting NARROWING-STEP-SET .
   protecting META-NARROWING-SEARCH .

    var M : Module . var RS : RuleSet .
    vars T T' T1 T2 ST PT : Term .  var TL : TermList .  var C : Constant .
    var TP : Type . vars SUB SUB1 SUB2 : Substitution .
    vars NextVar NextVar' N : Nat . var VR : Variant . var VS : VariantSet .
    var P : Parent . var B : Bool .
    var SR : StepResult . var SRS : StepResultSet .
    var TYPE : Type . var RL : Qid .
    var H : Header . var IL : ImportList . var SS : SortSet . var SSDS : SubsortDeclSet .
    var ODS : OpDeclSet . var MAS : MembAxSet . var EQS : EquationSet . var RLS : RuleSet .
    var AS : AttrSet . var CTX : Context . var Q : Qid .

    op metaNarrow2 : Module Term -> StepResult .
    --------------------------------------------
    eq metaNarrow2(M,T) = to4Tuple(M,metaENarrowShowAll(M,T,1,full noStrategy BuiltIn-unify)) |> T .

    op allNarrowSteps : Module Term     -> [StepResultSet] .
    op allNarrowSteps : Module Term Nat -> [StepResultSet] .
    --------------------------------------------------------
    eq allNarrowSteps(M, T) = allNarrowSteps(M, T, 0) .

    eq allNarrowSteps(M, T, N) = empty [owise] .
   ceq allNarrowSteps(M, T, N) = { T' , TYPE , SUB1 / getRls(RL, M) } || allNarrowSteps(M, T, N + 1)
    if { T' , TYPE , CTX , RL , SUB1 , SUB2 , Q } := metaNarrowingApply(M, T, empty, '#, N) .

    op metaGenVariant : Module Term -> VariantSet .
    -----------------------------------------------
    eq metaGenVariant(M, T) = metaGenVariant(M, T, highestVar(T)) .

    op metaGenVariant : Module Term Nat -> VariantSet .
    ---------------------------------------------------
    eq metaGenVariant(M, T, NextVar) = metaGenVariant2(M, T, NextVar, 0) .

    op metaGenVariant2 : Module Term Nat Nat -> VariantSet .
    --------------------------------------------------------
    eq metaGenVariant2(M, T, NextVar, N) = emptyVariantSet [owise] .
   ceq metaGenVariant2(M, T, NextVar, N) = VR # metaGenVariant2(M,T,NextVar,s N)
    if VR := metaGetVariant(M,T,empty,NextVar,N) .

    --- variant narrowing prop instantiations.
    --- compute the PI-instantated states of the given state.

    --- StateSet PropSet -> StateSet
    op propSetInstSet : StepResultSet TermList ~> StepResultSet .
    -------------------------------------------------------------
    eq propSetInstSet(SRS, empty)   = SRS .
    eq propSetInstSet(SRS, (PT,TL)) = propSetInstSet(propInstSet(SRS, PT), TL) .

    --- StateSet Prop -> StateSet
    op propInstSet : StepResultSet Term ~> StepResultSet .
    ------------------------------------------------------
    eq propInstSet(empty, PT) = empty .
    eq propInstSet({ST,TP,SUB / RS} || SRS, PT)
     = filterPropVars({ST,TP,SUB / RS}, metaGenVariant(##m##, '_|=_[ST, PT])) || propInstSet(SRS, PT) .

    op filterPropVars : StepResult VariantSet ~> StepResultSet .
    ------------------------------------------------------------
    eq filterPropVars(SR, emptyVariantSet) = empty .
    eq filterPropVars({ST,TP,SUB / RS}, {T,SUB1,N,P,B} # VS)
     = if inst?(T) then {ST << SUB1,TP, SUB .. SUB1 / RS} else empty fi || filterPropVars({ST,TP,SUB / RS}, VS) .

    --- TODO: by not filtering, we may allow more patterns that are not reduced
    --- to true/false. However, it easily generates spurious counter examples..
    --- We may adopt this with abstract refinement techniques..
    --- But with filtering, the |= equations should be total...

    op inst? : Term ~> Bool .
    -------------------------
    eq inst?('true.Bool)  = true .
    eq inst?('false.Bool) = true .
    eq inst?(T)           = false [owise] .
endfm
