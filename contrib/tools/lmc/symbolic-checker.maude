--- The Maude Logical Bounded Model Checker Interface
--- Author: Kyungmin Bae <kbae4@illinois.edu>

load ../base/model-checker.maude
load ../meta/narrowing.maude

****************************************
***          Basic Interface         ***
****************************************

fmod RULE-NAME is
    extending QID .

    sort RuleName .
    ---------------
    subsort Qid < RuleName .

    ops unlabeled deadlock : -> RuleName .
    --------------------------------------
endfm

fmod SYMBOLIC-CHECKER is
   protecting RULE-NAME .
   protecting SATISFACTION .
    including LTL .

    subsort Prop < Formula .

    --- generic substitution for counter example
    sorts CEAssignment CESubstitution .
    -----------------------------------
    subsort CEAssignment < CESubstitution .

    op _<-_ : Qid Universal -> CEAssignment [ctor poly (2) prec 63] .
    -----------------------------------------------------------------

    op none :                               -> CESubstitution .
    op _;_  : CESubstitution CESubstitution -> CESubstitution [ctor assoc comm id: none prec 65] .
    ----------------------------------------------------------------------------------------------
    eq CA:CEAssignment ; CA:CEAssignment = CA:CEAssignment .

    sorts Transition TransitionList .
    ---------------------------------
    subsort Transition < TransitionList .

    op {_,_,_} : State CESubstitution RuleName -> Transition [ctor] .
    -----------------------------------------------------------------

    op nil :                               -> TransitionList [ctor] .
    op __  : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .
    -----------------------------------------------------------------------------------------------

    sort ModelCheckResult .
    -----------------------
    subsort Bool < ModelCheckResult .

    op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .
    ----------------------------------------------------------------------------------------------------
endfm

**************************************************
***    Logical Model Checker on META-LEVEL     ***
**************************************************

--- core maude search function (using META-LEVEL)
fmod BOUNDED-FOLDING-MODEL-CHECKER is
   protecting RULE-NAME .
   protecting META-LEVEL .
   protecting SATISFACTION .
    including LTL .

    --- meta transition
    sorts MetaEdge MetaConf .
    -------------------------

    op <_>   : State          -> MetaConf [ctor] .
    op _|=>_ : MetaEdge State -> MetaConf [ctor] .
    ----------------------------------------------

    op deadlock :                      -> MetaEdge [ctor] .
    op _/_      : RuleSet Substitution -> MetaEdge [ctor] .
    -------------------------------------------------------

    --- propositions
    subsort Prop < Formula .
    ------------------------

    op prop : Term -> Prop [ctor] .
    -------------------------------

    --- folding relation
    op _>=_ : State State -> Bool .
    op _~=_ : State State -> Bool .
    -------------------------------

    op _~_  : MetaEdge MetaEdge -> Bool .
    -------------------------------------
    eq deadlock ~ deadlock = true .

    --- print state during model checking (debugging purpose)
    op prettyPrint : State    ~> QidList .
    op prettyPrint : MetaEdge ~> QidList .
    --------------------------------------

    --- transitions
    sort Transition TransitionList .
    --------------------------------
    subsort Transition < TransitionList .

    op {_,_} : State MetaEdge -> Transition [ctor] .
    ------------------------------------------------

    op nil :                               -> TransitionList [ctor] .
    op __  : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .
    -----------------------------------------------------------------------------------------------

    --- model checking results
    sorts ModelCheckResult .
    ------------------------
    subsort Bool < ModelCheckResult .

    op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .
    ----------------------------------------------------------------------------------------------------

    --- bounded model checker report
    sort BoundedModelCheckReport .
    ------------------------------

    op result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool -> BoundedModelCheckReport [ctor] .
    -------------------------------------------------------------------------------------------------------

    --- model checker
    --- (InitState,Formula,SubsumptionFolding,Bound)
    op symbolicModelCheck : State Formula Bool Bound ~> BoundedModelCheckReport
     [ special ( id-hook SymbolicModelCheckerSymbol

                 --- temporal operators
                 op-hook trueSymbol              (True : ~> Formula)
                 op-hook falseSymbol             (False : ~> Formula)
                 op-hook notSymbol               (~_ : Formula ~> Formula)
                 op-hook nextSymbol              (O_ : Formula ~> Formula)
                 op-hook andSymbol               (_/\_ : Formula Formula ~> Formula)
                 op-hook orSymbol                (_\/_ : Formula Formula ~> Formula)
                 op-hook untilSymbol             (_U_ : Formula Formula ~> Formula)
                 op-hook releaseSymbol           (_R_ : Formula Formula ~> Formula)

                 --- for Bound attribute
                 op-hook succSymbol              (s_ : Nat ~> NzNat)
                 op-hook unboundedSymbol         (unbounded : ~> Bound)

                 --- state propositions
                 op-hook satisfiesSymbol         (_|=_ : State Formula ~> Bool)
                 term-hook trueTerm              (true)

                 --- folding graph stuff
                 op-hook subsumeFoldingRelSymbol (_>=_ : State State ~> Bool)
                 op-hook renameFoldingRelSymbol  (_~=_ : State State ~> Bool)
                 op-hook compatibleTransSymbol   (_~_  : MetaEdge MetaEdge ~> Bool)

                 op-hook prettyPrintStateSymbol  (prettyPrint : State ~> QidList)
                 op-hook prettyPrintTransSymbol  (prettyPrint : MetaEdge ~> QidList)

                 --- meta graph
                 op-hook metaStateSymbol         (<_> : State ~> MetaConf)
                 op-hook metaTransitionSymbol    (_|=>_ : MetaEdge State ~> MetaConf)

                 --- counterexamples
                 term-hook falseTerm             (false)
                 term-hook deadlockTerm          ((deadlock).MetaEdge)

                 op-hook transitionSymbol        ({_,_} : State MetaEdge ~> Transition)
                 op-hook transitionListSymbol    (__ : TransitionList TransitionList ~> TransitionList)
                 op-hook nilTransitionListSymbol (nil : ~> TransitionList)
                 op-hook counterexampleSymbol    (prefix_loop_ : TransitionList TransitionList ~> ModelCheckResult)

                 --- result report
                 op-hook resultreportSymbol      (result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool ~> BoundedModelCheckReport)
               )
     ] .
endfm


****************************************
***  Full Maude Narrowing Connector  ***
****************************************

fmod META-LMC-PARAMETERS is
   protecting META-MODULE .

    --- empty! the user module shoule define them.
    op ##m## : ~> SModule  [memo] .
    op ##f## : ~> TermList [memo] .
endfm

mod META-LMC-THEORY is
   protecting NARROWING-STEP-SET .
   protecting META-LMC-PARAMETERS .
   protecting BOUNDED-FOLDING-MODEL-CHECKER .

    vars T1 T2 ST ST' : Term . vars SUB SUB' : Substitution .
    var RS : RuleSet . var CD : Condition . var Q : Qid .
    var TP : Type .  var SRS : StepResultSet .

    ops init mid : Term -> State [ctor] .
    -------------------------------------

    --- functions
    ops next variant : Term -> StepResultSet .
    ------------------------------------------

    --- meta rules
    crl [init] :
        < init(ST) >
     => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')))
     if {ST',TP,SUB' / RS} || SRS := variant(ST) .

    crl [mid] :
        < mid(ST) >
     => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')))
     if {ST',TP,SUB' / RS} || SRS := next(ST) .
endm

fmod META-NARROWING-INTERFACE is
   protecting META-LMC-PARAMETERS .
   protecting NARROWING .

    var N : Nat . var B : Bool . var P : Parent .
    vars T ST PT : Term .  var TL : TermList .
    var TP : Type . vars SUB SUB1 : Substitution .
    var RS : RuleSet . var VS : VariantSet .
    var SR : StepResult . var SRS : StepResultSet .

    --- variant narrowing prop instantiations.
    --- compute the PI-instantated states of the given state.

    --- StateSet PropSet -> StateSet
    op propSetInstSet : StepResultSet TermList ~> StepResultSet .
    -------------------------------------------------------------
    eq propSetInstSet(SRS, empty)   = SRS .
    eq propSetInstSet(SRS, (PT,TL)) = propSetInstSet(propInstSet(SRS, PT), TL) .

    --- StateSet Prop -> StateSet
    op propInstSet : StepResultSet Term ~> StepResultSet .
    ------------------------------------------------------
    eq propInstSet(.StepResultSet, PT) = .StepResultSet .
    eq propInstSet({ST,TP,SUB / RS} || SRS, PT)
     = filterPropVars({ST,TP,SUB / RS}, metaGenVariant(##m##, '_|=_[ST, PT])) || propInstSet(SRS, PT) .

    op filterPropVars : StepResult VariantSet ~> StepResultSet .
    ------------------------------------------------------------
    eq filterPropVars(SR, .VariantSet) = .StepResultSet .
    eq filterPropVars({ST,TP,SUB / RS}, {T,SUB1,N,P,B} # VS)
     = if inst?(T) then {ST << SUB1,TP, SUB .. SUB1 / RS} else .StepResultSet fi || filterPropVars({ST,TP,SUB / RS}, VS) .

    --- TODO: by not filtering, we may allow more patterns that are not reduced
    --- to true/false. However, it easily generates spurious counter examples..
    --- We may adopt this with abstract refinement techniques..
    --- But with filtering, the |= equations should be total...

    op inst? : Term ~> Bool .
    -------------------------
    eq inst?('true.Bool)  = true .
    eq inst?('false.Bool) = true .
    eq inst?(T)           = false [owise] .
endfm

mod META-SYMBOLIC-CONNECTOR is
   protecting META-LMC-THEORY .
   protecting BOUNDED-FOLDING-MODEL-CHECKER .
   protecting META-NARROWING-INTERFACE .

    var M : Module .  vars T T' T1 T2 ST ST' PT CT : Term .
    var RN : RuleName . var RS : RuleSet . var TL : TermList .
    var V : Variable . var TP : Type . vars SUB SUB' SUB'' : Substitution .
    var B : Bool . var N : Nat . var D : Bound . var A : Assignment .

    --- meta prop and state
    eq mid(ST) |= prop(PT) = getTerm(metaReduce(##m##, '_|=_[ST, PT])) == 'true.Bool .

    --- state folding
    eq init(ST) >= init(ST) = true .
    eq  mid(ST) >= mid(ST') = metaMatch(##m##, ST, ST', nil, 0) :: Substitution .
    eq S1:State >= S2:State = false [owise] .

    --- renaming folding
    eq init(ST) ~= init(ST) = true .
    eq  mid(ST) ~= mid(ST') = mid(ST) >= mid(ST') and-then mid(ST') >= mid(ST) .
    eq S1:State ~= S2:State = false [owise] .

    --- compute the next states
    --- TODO: keep both a state and a substitution for a counter example..
    eq    next(ST) = propSetInstSet(metaNarrow2(##m##, ST), ##f##) .
    eq variant(ST) = propSetInstSet({ST,leastSort(##m##,ST),none / none}, ##f##) .

    --- run LMC model check : State Formula -> Result
    op lmc-check : Term Term Bool Bound ~> BoundedModelCheckReport .
    ----------------------------------------------------------------
   ceq lmc-check(ST, PT, B, D) = symbolicModelCheck(init(ST), O tilde(##m##,PT), B, D)
    if sortLeq(##m##, leastSort(##m##,ST), 'State)
    /\ sortLeq(##m##, leastSort(##m##,PT), 'Formula) .

    --- meta formula
    op tilde : Module Term -> Formula .
    -----------------------------------
   ceq tilde(M, PT)             = prop(PT) if sortLeq(M,leastSort(M,PT),'Prop) .
    eq tilde(M, 'True.Formula)  = True .
    eq tilde(M, 'False.Formula) = False .
    eq tilde(M, '~_[T])         = ~ tilde(M, T) .
    eq tilde(M, '_/\_[T, T'])   = tilde(M, T) /\ tilde(M, T') .
    eq tilde(M, '_\/_[T, T'])   = tilde(M, T) \/ tilde(M, T') .
    eq tilde(M, 'O_[T])         = O tilde(M, T) .
    eq tilde(M, '_U_[T, T'])    = tilde(M, T) U tilde(M, T') .
    eq tilde(M, '_R_[T, T'])    = tilde(M, T) R tilde(M, T') .
endm
