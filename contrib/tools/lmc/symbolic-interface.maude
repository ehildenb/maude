--- The Maude Logical Bounded Model Checker Interface
--- Author: Kyungmin Bae <kbae4@illinois.edu>

load symbolic-checker.maude
load ../base/full-maude.maude

mod META-SYMBOLIC-CONNECTOR is
   protecting META-LMC-THEORY .
   protecting BOUNDED-FOLDING-MODEL-CHECKER .
   protecting META-NARROWING-INTERFACE .
   protecting DECL-META-PRETTY-PRINT * ( op addOps to addOpsSE
                                       , op addEqs to addEqsSE
                                       , op addSorts to addSortsSE
                                       ) .

    var M : Module .  vars T T' T1 T2 ST ST' PT CT : Term .
    var RN : RuleName . var RS : RuleSet . var TL : TermList .
    var V : Variable . var TP : Type . vars SUB SUB' SUB'' : Substitution .
    var B : Bool . var N : Nat . var D : Bound . var A : Assignment .
    var RT : ResultTriple .  var RTS : ResultTripleSet .

    --- meta prop and state
    eq mid(ST) |= prop(PT) = getTerm(metaReduce(##m##, '_|=_[ST, PT])) == 'true.Bool .

    --- state folding
    eq init(ST) >= init(ST) = true .
    eq  mid(ST) >= mid(ST') = metaMatch(##m##, ST, ST', nil, 0) :: Substitution .
    eq S1:State >= S2:State = false [owise] .

    --- renaming folding
    eq init(ST) ~= init(ST) = true .
    eq  mid(ST) ~= mid(ST') = mid(ST) >= mid(ST') and-then mid(ST') >= mid(ST) .
    eq S1:State ~= S2:State = false [owise] .

    --- compute the next states
    --- TODO: keep both a state and a substitution for a counter example..
    eq    next(ST) = propSetInstSet(metaNarrow2(##m##, ST), ##f##) .
    eq variant(ST) = propSetInstSet({ST,leastSort(##m##,ST),none / none}, ##f##) .

    --- run LMC model check : State Formula -> Result
    op lmc-check : Term Term Bool Bound ~> BoundedModelCheckReport .
    ----------------------------------------------------------------
   ceq lmc-check(ST, PT, B, D) = symbolicModelCheck(init(ST), O tilde(##m##,PT), B, D)
    if sortLeq(##m##, leastSort(##m##,ST), 'State)
    /\ sortLeq(##m##, leastSort(##m##,PT), 'Formula) .

    --- meta formula
    op tilde : Module Term -> Formula .
    -----------------------------------
   ceq tilde(M, PT)             = prop(PT) if sortLeq(M,leastSort(M,PT),'Prop) .
    eq tilde(M, 'True.Formula)  = True .
    eq tilde(M, 'False.Formula) = False .
    eq tilde(M, '~_[T])         = ~ tilde(M, T) .
    eq tilde(M, '_/\_[T, T'])   = tilde(M, T) /\ tilde(M, T') .
    eq tilde(M, '_\/_[T, T'])   = tilde(M, T) \/ tilde(M, T') .
    eq tilde(M, 'O_[T])         = O tilde(M, T) .
    eq tilde(M, '_U_[T, T'])    = tilde(M, T) U tilde(M, T') .
    eq tilde(M, '_R_[T, T'])    = tilde(M, T) R tilde(M, T') .

    --- pretty print (for debugging)
    eq prettyPrint(init(ST)) = eMetaPrettyPrint(##m##, ST) .
    eq prettyPrint(mid(ST))  = eMetaPrettyPrint(##m##, ST) .
    eq prettyPrint(RS / SUB) = eMetaPrettyPrint(##m##, RS) '/ prettyPrintSub(SUB) .

    op prettyPrintSub : Substitution -> QidList .
    ---------------------------------------------
    eq prettyPrintSub(none)             = 'none .
    eq prettyPrintSub(V <- T)           = V '<- eMetaPrettyPrint(##m##,T) .
    eq prettyPrintSub(V <- T ; A ; SUB) = V '<- eMetaPrettyPrint(##m##,T) '; prettyPrintSub(A ; SUB) .
endm

*****************************************************
***  Full Maude Narrowing Connector  (Condition)  ***
*****************************************************

--- NOTE: currently, only considering "T = true"

mod META-LMC-COND-THEORY is
   protecting META-LMC-THEORY .

   ops init mid : Term EqCondition -> State [ctor] .
    ------------------------------------------------
endm

fmod META-NARROWING-COND-INTERFACE is
   protecting META-NARROWING-INTERFACE .

   vars T T1 T2 ST PT : Term .  var TL : TermList .
    var C : Constant . var CD : EqCondition . var RS : RuleSet .
    var TP : Type . vars SUB SUB1 SUB2 : Substitution .  var N : Nat .
    var SR : StepResult . var SRS : StepResultSet . var VS : VariantSet .
    var P : Parent . var B : Bool .

    --- variant narrowing condition instantiations.

    --- StateSet EqCondition -> StateSet
    op condSetInstSet : StepResultSet EqCondition ~> StepResultSet .
    ----------------------------------------------------------------
    eq condSetInstSet(SRS, nil)                  = SRS .
    eq condSetInstSet(SRS, T = 'true.Bool /\ CD) = condSetInstSet(condInstSet(SRS, T), CD) .

    --- StateSet Prop -> StateSet
    op condInstSet : StepResultSet Term ~> StepResultSet .
    ------------------------------------------------------
    eq condInstSet(empty, T)                   = empty .
   ceq condInstSet({ST,TP,SUB / RS} || SRS, T) = filterCondVars({ST,TP,SUB / RS}, VS) || condInstSet(SRS, T)
    if VS := metaGenVariant(##m##, T << SUB) .

    --- only true instances (hence the conditions should be complete and FVP)
    op filterCondVars : StepResult VariantSet ~> StepResultSet .
    ------------------------------------------------------------
    eq filterCondVars(SR, VS) = empty [owise] .
    eq filterCondVars({ST,TP,SUB / RS}, {'true.Bool,SUB1,N,P,B} # VS)
     = {ST << SUB1, TP, SUB .. SUB1 / RS} || filterCondVars({ST,TP,SUB / RS}, VS) .

    --- applying substitution to condition
    op _<<_ : EqCondition Substitution ~> EqCondition .
    ---------------------------------------------------
    eq nil << SUB = (nil).EqCondition .
    eq (T1  = T2   /\ CD) << SUB = ((T1 << SUB) = (T2 << SUB)) /\ (CD << SUB) .
    eq (T1 := T2   /\ CD) << SUB = ((T1 << SUB) = (T2 << SUB)) /\ (CD << SUB) .
    eq (T : S:Sort /\ CD) << SUB = ((T << SUB) : S:Sort)       /\ (CD << SUB) .
endfm

mod META-SYMBOLIC-COND-CONNECTOR-BASE is
   protecting META-LMC-COND-THEORY .
   protecting META-SYMBOLIC-CONNECTOR .
   protecting META-NARROWING-COND-INTERFACE .

    var M : Module .  vars T T' T1 T2 ST ST' PT CT : Term .
    var TL : TermList .  var V : Variable .
    var TP : Type . vars SUB SUB' SUB'' : Substitution .
    var B : Bool . var N : Nat . var D : Bound .
    var RT : ResultTriple .  var RTS : ResultTripleSet .
   vars CD CD' : EqCondition .

    --- meta prop and state
    eq mid(ST,CD) |= prop(PT) = getTerm(metaReduce(##m##, '_|=_[ST, PT])) == 'true.Bool .

    --- with condition
    op lmc-check : Term Term EqCondition Bool Bound ~> BoundedModelCheckReport .
    ----------------------------------------------------------------------------
   ceq lmc-check(ST, PT, CD, B, D)
     = if CD == nil
       then symbolicModelCheck(init(ST), O tilde(##m##,PT), B, D)
       else symbolicModelCheck(init(ST,CD), O tilde(##m##,PT), B, D)
       fi
    if sortLeq(##m##, leastSort(##m##,ST), 'State)
    /\ sortLeq(##m##, leastSort(##m##,PT), 'Formula) .

    --- normalize conditions (modulo equation)
    --- NOTE: metaNormalize vs. metaReduce??  metaNormalize generates slightly
    --- more states for (state,condition) pairs if there exists equaltional
    --- abstraction, but it will be more correct since we do not worry about
    --- whether some variables is removed by such equations...
    op condNorm : EqCondition ~> EqCondition .
    ------------------------------------------
    eq condNorm(nil)                  = nil .
    eq condNorm(T = 'true.Bool /\ CD) = getTerm(metaNormalize(##m##,T)) = 'true.Bool /\ condNorm(CD) .

    --- pretty print (for debugging)
    eq prettyPrint(init(ST,CD)) = prettyPrint(init(ST)) '\n '\t eMetaPrettyPrint(##m##, CD) .
    eq prettyPrint(mid(ST,CD))  = prettyPrint(mid(ST)) '\n '\t eMetaPrettyPrint(##m##, CD) .
endm

--- Conditions are solved for generating states by variant narrowing
mod META-SYMBOLIC-COND-CONNECTOR is
   protecting META-SYMBOLIC-COND-CONNECTOR-BASE .

    var M : Module .  vars T T' T1 T2 ST ST' PT CT : Term .
    var TL : TermList .  var V : Variable .
    var TP : Type . vars SUB SUB' SUB'' : Substitution .  var N : Nat .
    var SR : StepResult .  var SRS : StepResultSet .
   vars CD CD' : EqCondition . var RS : RuleSet .

   --- meta rules
   crl [init-cond] :
       < init(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := variant(ST,CD) .

   crl [mid-cond] :
       < mid(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := next(ST,CD) .

   ops next variant : Term EqCondition -> StepResultSet .
    -----------------------------------------------------
    eq next(ST,CD)    = propSetInstSet(condSetInstSet(metaNarrow2(##m##, ST),CD), ##f##) .
    eq variant(ST,CD) = propSetInstSet(condSetInstSet({ST,leastSort(##m##,ST),none / none},CD), ##f##) .

    --- condition should be already considered by variant narrowing
    eq mid(ST,CD) >= mid(ST',CD') = mid(ST)    >= mid(ST') .
    eq mid(ST,CD) ~= mid(ST',CD') = mid(ST,CD) >= mid(ST',CD') and-then mid(ST',CD') >= mid(ST,CD) .
endm

--- Folding conditions C >= C' by checking C' => \rho(C) using variant narrowing
mod META-SYMBOLIC-COND-CONNECTOR2 is
   protecting META-SYMBOLIC-COND-CONNECTOR-BASE .

   vars T T' T1 T2 ST ST' PT CT : Term .
    var TL : TermList .  var V : Variable .
    var TP : Type . vars SUB SUB' SUB'' : Substitution .
    var N : Nat . var B : Bool . var RS : RuleSet .
    var SR : StepResult .  var SRS : StepResultSet .
    vars CD CD' : EqCondition .  var VS : VariantSet .
    var P : Parent .

    --- meta rules
   crl [init-cond] :
       < init(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := variant(ST) /\ condOK(CD << SUB') .

   crl [mid-cond]  :
       < mid(ST,CD) >
    => RS / SUB' |=> mid(getTerm(metaReduce(##m##,ST')),condNorm(CD << SUB'))
    if {ST',TP,SUB' / RS} || SRS := next(ST) /\ condOK(CD << SUB') .

    --- Another method to check a condition.
    op condOK : EqCondition ~> Bool .
    ---------------------------------
    eq condOK(nil)                   = true .
    eq condOK(T1 = 'true.Bool /\ CD) = (not getTerm(metaReduce(##m##, T1)) == 'false.Bool) and-then condOK(CD) .

    --- folding with conditions
    eq mid(ST,CD) >= mid(ST',CD') = condFold(ST, CD, ST', CD', 0) .
    eq mid(ST,CD) ~= mid(ST',CD') = mid(ST,CD) >= mid(ST',CD') and-then mid(ST',CD') >= mid(ST,CD) .

    op condFold : Term EqCondition Term EqCondition Nat -> Bool .
    -------------------------------------------------------------
    eq condFold(ST, CD, ST', CD', 0)    = false [owise] .
    eq condFold(ST, CD, ST', CD', s(N)) = true  [owise] .
   ceq condFold(ST, CD, ST', CD', N)    = implyOK(CD', CD << SUB) and-then condFold(ST, CD, ST', CD', s(N))
    if SUB := metaMatch(##m##, ST, ST', nil, N) .

    --- check if the implecation (C1 /\ not C2) has no "true" solution
    op implyOK : EqCondition EqCondition ~> Bool .
    ----------------------------------------------
   ceq implyOK(CD, CD') = implyOKsub(VS)
    if VS := metaGenVariant(##m##,'_and_[condList(CD,true), '_or_[condList(CD',false)]]) .

    op implyOKsub : VariantSet ~> Bool .
    ------------------------------------
    eq implyOKsub(emptyVariantSet)    = true .
   ceq implyOKsub({T,SUB,N,P,B} # VS) = T' =/= 'true.Bool and-then implyOKsub(VS)
    if T' := getTerm(metaReduce(##m##,T)) .

    op condList : EqCondition Bool ~> TermList .
    --------------------------------------------
    eq condList(nil, B)                  = if B then 'true.Bool else 'false.Bool fi .
    eq condList(T = 'true.Bool /\ CD, B) = if B then T else 'not_[T] fi, condList(CD, B) .
endm

*****************************************
***       Extending Full Maude        ***
*****************************************

--- REDEFINED
fmod BANNER is
    pr STRING .
    op banner : -> String .
    eq banner = "Logical Model Checker January 10th 2012" .
endfm

fmod LMC-COMMANDS is
    inc COMMANDS .
    op lmc_|=_. : @Bubble@ @Bubble@ -> @Command@ [ctor] .
    op lfmc_|=_. : @Bubble@ @Bubble@ -> @Command@ [ctor] .
endfm

--- REDEFINED
fmod FULL-MAUDE-SIGN is
    including VIEWS .
    inc LMC-COMMANDS .
    sort @Input@ .
    subsorts @Command@ @Module@ @View@ < @Input@ .
endfm

fmod META-PROP-SET is
    pr META-LEVEL .

    var M : Module . vars T T' : Term .

    op props : Module Term -> TermList .
    eq props(M, T) = #props(M, getTerm(metaReduce(M, T))) .

    op #props : Module Term -> TermList .   --- Formula -> PropList .
   ceq #props(M, T)            = T if sortLeq(M, leastSort(M, T), 'Prop) .
    eq #props(M, '~_[T])       = #props(M, T) .
    eq #props(M, '_/\_[T, T']) = #props(M, T), #props(M, T') .
    eq #props(M, '_\/_[T, T']) = #props(M, T), #props(M, T') .
    eq #props(M, 'O_[T])       = #props(M, T) .
    eq #props(M, '_U_[T, T'])  = #props(M, T), #props(M, T') .
    eq #props(M, '_R_[T, T'])  = #props(M, T), #props(M, T') .
    eq #props(M, T)            = empty [owise] .
endfm

mod META-LMC-COUNTEREXAMPLE-TRANSFORMER is
    pr META-LMC-THEORY .
    pr META-LMC-COND-THEORY .
    pr BOUNDED-FOLDING-MODEL-CHECKER .

    vars Q F : Qid . var M : Module .  var V : Variable . var C : Constant .
    var CD : Condition . vars T T' ST PT : Term . var TL : TermList .
    var TR : Transition . var TRL TRL' : TransitionList .
    var RS : RuleSet . var RN : RuleName .  var AtS : AttrSet .
    var SUB : Substitution . var ME : MetaEdge .
    var D : Bound . vars B BC BR : Bool . var MR : ModelCheckResult .

    --- meta counterexample
    op transRes : ModelCheckResult -> Term .
    eq transRes(B) = upTerm(B:Bool) .
    eq transRes(prefix TRL loop TRL')
     = 'prefix_loop_[wrapTL('__,'nil.TransitionList,transTRs(TRL)),
                           wrapTL('__,'nil.TransitionList,transTRs(TRL'))] .

    op transTRs : TransitionList -> TermList .
    eq transTRs(TR TRL) = transTR(TR), transTRs(TRL) .
    eq transTRs(nil)    = empty .

    --- transition (including conditions)
    op transTR : Transition -> TermList .
    eq transTR({mid(ST), RS / SUB})
     = '`{_`,_`,_`}[ST, wrapTL('_;_,'none.CESubstitution,transSUB(SUB)),
                  upRuleName(getRuleName(RS))] .
    eq transTR({mid(ST), deadlock})
     = '`{_`,_`,_`}[ST, 'none.CESubstitution, upRuleName(deadlock)] .
    eq transTR({init(ST), ME}) = empty  .

    eq transTR({mid(ST,CD),ME})  = transTR({mid(ST),ME}) .
    eq transTR({init(ST,CD),ME}) = empty  .

    --- substitution
    op transSUB : Substitution -> TermList .
    eq transSUB(none) = empty .
    eq transSUB(V <- T ; SUB)
     = '_<-_[qid("'" + string(getName(V)) + ".Qid"), T], transSUB(SUB) .

    op wrapTL : Qid Constant TermList -> Term .
    eq wrapTL(F, C, T) = T .
    eq wrapTL(F, C, (T,T',TL)) = F[T,T',TL] .
    eq wrapTL(F, C, empty) = C .

    op upRuleName : RuleName -> Constant .
    eq upRuleName(Q) = qid("'" + string(Q) + ".Qid") .
    eq upRuleName(RN) = upTerm(RN) [owise] .

    op getRuleName : RuleSet -> RuleName .
    eq getRuleName((rl T => T' [label(Q) AtS] .) RS) = Q .
    eq getRuleName((crl T => T' if CD [label(Q) AtS] .) RS) = Q .
    eq getRuleName(RS) = unlabeled [owise] .
endm

mod LMC-COMMAND-PROCESSING is
    pr COMMAND-PROCESSING .
    pr META-PROP-SET .

    vars T T1 T2 T3 T4 T5 T6 : Term .
    var TL TL1 : TermList .
    vars DB DB1 : Database .
    vars M U M1 M2 : Module .
    vars ME ME1 : ModuleExpression .
    vars  B BC : Bool .
    var D : Bound .
    var CD : Condition .
    var  QIL : QidList .
    vars VS VDS : OpDeclSet .
    vars QI QI' F V O : Qid .  var TY : Type .
    var  TDM : Tuple{Database,ModuleExpression} .
    var  TMVB : [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
    var RP : ResultPair . var  RP? : [ResultPair] .

    --- command condition type
    op lmcCmdCond : Qid -> Type? .
    eq lmcCmdCond('lmc_|=_.)  = 'Formula .
    eq lmcCmdCond('lfmc_|=_.) = 'Formula .
    eq lmcCmdCond(QI) = anyType [owise] . --- no condition

    --- process lmc commands
    op procLMCComd : Term ModuleExpression Database -> Tuple{Database,QidList} .

    --- no argument
    eq procLMCComd(QI, ME, DB)
     = if compiledModule(ME, DB)
       then procLMC(QI, empty, nil, unbounded,
                    getFlatModule(ME,DB), getVars(ME,DB), DB)
       else procLMC(QI, empty, nil, unbounded,
                    getFlatModule(modExp(evalModExp(ME,DB)),
                                  database(evalModExp(ME,DB))),
                    getVars(modExp(evalModExp(ME,DB)),
                            database(evalModExp(ME,DB))),
                    database(evalModExp(ME,DB)))
       fi .

    --- there exist arguments
   ceq procLMCComd(F[TL], ME, DB)
     = if compiledModule(ME, DB)
       then procLMCComd(F, TL, getFlatModule(ME,DB), B, unbounded,
                        getVars(ME,DB), DB, empty)
       else procLMCComd(F, TL,
                        getFlatModule(modExp(evalModExp(ME,DB)),
                                      database(evalModExp(ME,DB))),
                        B, unbounded,
                        getVars(modExp(evalModExp(ME,DB)),
                                database(evalModExp(ME,DB))),
                        database(evalModExp(ME,DB)), empty)
       fi
    if B := included('META-MODULE, getImports(getTopModule(ME,DB)), DB) .

    -------------------------------------
    --- parse arguments
    ---
    op procLMCComd : Qid TermList Module Bool Bound OpDeclSet Database TermList
                -> Tuple{Database,QidList} .

    eq procLMCComd(F, TL, unitError(QIL), B, D, VDS, DB, TL1) = << DB ; QIL >> .

    --- the first argument
   ceq procLMCComd(F, (T,TL), M, B, D, VDS, DB, empty)
     = if getModule(TMVB) :: Module and-then getTerm(TMVB) :: Term
       then procLMCComd(F, TL, getModule(TMVB), B, getBound(TMVB),
                        getVars(TMVB), getDatabase(TMVB), getTerm(TMVB))
       else << DB ; getMsg(getTerm(metaReduce(getModule(TMVB), getTerm(TMVB)))) >>
       fi
    if TMVB := solveBubblesRew(T, M, B, unbounded, VDS, DB) . --- "[1] in MOD :"

    --- intermediate arguments
   ceq procLMCComd(F, (T1,T2,TL), M, B, D, VDS, DB, TL1)
     = if T?:[Term] :: Term
       then procLMCComd(F, (T2,TL), M, B, D, VDS, DB, (TL1,T?:[Term]))
       else << DB ; getMsg(T?:[Term]) >> fi
    if T?:[Term] := solveBubbles(T1,M,B,VDS,DB) .

    --- the last argument (no condition)
   ceq procLMCComd(F, 'bubble[QI], M, B, D, VDS, DB, TL1)
     = if T?:[Term] :: Term
       then procLMC(F, (TL1,T?:[Term]), nil, D, M, VDS,DB)
       else << DB ; getMsg(T?:[Term]) >> fi
    if T?:[Term] := solveBubbles('bubble[QI],M,B,VDS,DB) .

    --- the last argument (may have condition)
   ceq procLMCComd(F, 'bubble['__[TL]], M, B, D, VDS, DB, TL1)
     = if T?:[Term] :: Term
       then procLMC(F, (TL1,T?:[Term]), nil, D, M, VDS,DB)
       else
         if lmcCmdCond(F) :: Type
         then parseLMCCondArg1(F,'bubble['__[TL]],lmcCmdCond(F),D,M,VDS,DB,TL1)
         else << DB ; getMsg(T?:[Term]) >> fi
       fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

    --- parse lmc command args: procLMCComd(BUBBLES,MOD,HasMetaLv?,HasCond?,...)
    op parseLMCCondArg1 : Qid Term Type Bound Module OpDeclSet Database TermList
                    -> Tuple{Database,QidList} .
    op parseLMCCondArg2 : Qid Term Bound Module OpDeclSet Database TermList
                    -> Tuple{Database,QidList} .

    --- the last argument (with condition)
   ceq parseLMCCondArg1(F, 'bubble['__[TL]], TY, D, M, VDS, DB, TL1)
     = if RP? :: ResultPair
       then parseLMCCondArg2(F, getTerm(RP?), D, M, VDS, DB, TL1)
       else << DB ; ('\r 'Error: '\o 'no 'parse 'for
                      downQidList('__[TL,''..Qid]) '\n) >> fi
    if M1 := addOps(
       op '_s.t._. : TY '@Condition@ -> 'PatternCondition [prec(122)] .
       op '_such`that_. : TY '@Condition@ -> 'PatternCondition [prec(122)] .,
       addSorts('PatternCondition, addInfoConds(M)))
    /\ RP? := metaParse(M1, downQidList('__[TL,''..Qid]), 'PatternCondition) .

    --- parse conditions
    eq parseLMCCondArg2(F, QI[T1,T2], D, M, VDS, DB, TL1)
     = if QI == '_s.t._. or QI == '_such`that_.
       then procLMC(F, (TL1,T1), parseCond(T2,VDS), D, M, VDS, DB)
       else procLMC(F, (TL1,constsToVars(QI[T1,T2],VDS)), nil, D, M, VDS, DB)
       fi .
    eq parseLMCCondArg2(F, T, D, M, VDS, DB, TL1)
     = procLMC(F, (TL1,constsToVars(T,VDS)), nil, D, M, VDS, DB) [owise] .

    --- error handling
    eq getTerm({T, M, B, VDS, DB}) = T .
    eq getTerm(tupleTMBOBDerror(QIL)) = qidError(QIL) .
    eq getModule({T, M, B, VDS, DB}) = M .
    eq getModule(tupleTMBOBDerror(QIL)) = unitError(QIL) .
    eq getVars({T, M, B, VDS, DB}) = VDS .
    eq getVars(tupleTMBOBDerror(QIL)) = opDeclError(QIL) .
    eq getBool({T, M, B, VDS, DB}) = B .
    eq getBool(tupleTMBOBDerror(QIL)) = false .
    eq getDatabase({T, M, B, VDS, DB}) = DB .
    eq getDatabase(tupleTMBOBDerror(QIL)) = emptyDatabase .

    -------------------------------------
    --- execute commands
    ---
    op procLMC : Qid TermList Condition Bound Module OpDeclSet Database -> Tuple{Database,QidList} .

    eq procLMC('lfmc_|=_., (T1,T2), CD, D, M, VDS, DB)
     = procLMCExec(T1, T2, CD, true, D, M, DB) .
    eq procLMC('lmc_|=_., (T1,T2), CD, D, M, VDS, DB)
     = procLMCExec(T1, T2, CD, false, D, M, DB) .

    op procLMCExec : Term Term Condition Bool Bound Module Database -> Tuple{Database,QidList} .
   ceq procLMCExec(T1, T2, CD, B, D, M, DB)
     = if RP? :: ResultPair
       then << DB ; printLMCInfo(M,B,T1,T2,CD) printLMCOutput(M,getTerm(RP?)) >>
       else << DB ; getMsg(getTerm(RP?)) >>
       fi
    if U := addEqs(
       (eq '##m##.Module = up(M) [none] .
        eq '##f##.TermList = upTerm(props(M,T2)) [none] .),
       upModule('META-SYMBOLIC-COND-CONNECTOR2, false)) /\
    T3  := up(getTerm(metaReduce(M,T1))) /\
    T4 := up(getTerm(metaReduce(M,T2))) /\
    RP? := metaReduce(U, 'lmc-check[T3,T4,upTerm(CD),upTerm(B),upTerm(D)]) .

    op printLMCInfo : Module Bool Term Term Condition -> QidList .
    eq printLMCInfo(M, B, T1, T2, CD)
     = '\b 'logical (if B then 'folding else nil fi) 'model 'check 'in
       '\o eMetaPrettyPrint(getName(M)) '\b ': '\o '\n '\s '\s
       eMetaPrettyPrint(M,T1) '\b '\s '|= '\s '\o eMetaPrettyPrint(M,T2)
       (if CD == nil then nil
       else '\n '\b 'under 'the 'condition ': '\o '\n '\s '\s
       eMetaPrettyPrint(M,CD) fi) '\n .

    op printLMCOutput : Module Term -> QidList .
    eq printLMCOutput(M, 'result:_real:_bound:_complete:_[T1,T2,T3,T4])
     = '\b 'result: '\o '\n '\s '\s
       (if T1 == 'true.Bool then
          if T4 == 'true.Bool then
            'true '\s '`( 'complete 'with 'depth eMetaPrettyPrint(M,T3) '`)
          else
            'no 'counterexample 'found 'within 'bound eMetaPrettyPrint(M,T3)
          fi
        else
          if T2 == 'true.Bool then nil else 'possibly 'spurious fi
          'counterexample 'found 'at 'depth eMetaPrettyPrint(M,T3) '\n '\s '\s
          printLMCCE(M, T1)
        fi) '\n .

    eq printLMCOutput(M, T)
     = '\b 'error: '\o '\n '\s '\s
       'model 'checker 'internal 'error '\n [owise] .

    op printLMCCE : Module Term -> QidList .
   ceq printLMCCE(M, T)
     = eMetaPrettyPrint(M, downTerm(getTerm(RP)))
    if RP := metaReduce(upModule('META-LMC-COUNTEREXAMPLE-TRANSFORMER,false),
                      'transRes[T]) .
    eq printLMCCE(M, T)
     = 'invalid 'counterexample 'term [owise] .
endm

mod LMC-DATABASE-HANDLING is
    inc DATABASE-HANDLING .
    pr LMC-COMMAND-PROCESSING .

    var Atts : AttributeSet . var X@DatabaseClass : DatabaseClass .
    var F : Qid . var O : Oid .  var ME : ModuleExpression . var DB : Database .
    var TL : TermList . var T T' : Term . var QIL : QidList .

   crl [LMC] :
       < O : X@DatabaseClass |
          db : DB, input : (F[TL]), output : QIL, default : ME, Atts >
    =>
       < O : X@DatabaseClass |
          db : getDatabase(procLMCComd(F[TL], ME, DB)),
          input : nilTermList,
          output : getQidList(procLMCComd(F[TL], ME, DB)),
          default : ME, Atts >
    if (F == 'lmc_|=_.) or-else (F == 'lfmc_|=_.) .
endm

mod LMC-FULL-MAUDE is
    pr FULL-MAUDE .
    pr LMC-DATABASE-HANDLING .
endm

set trace off .
set break off .
set profile off .

loop init .
