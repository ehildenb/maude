







load mtemplate.maude

fmod MODULE-CONSTRUCTION is
    protecting MODULE-TEMPLATE .

    sorts NeModuleConstruction ModuleConstruction .
    -----------------------------------------------
    subsort NeModuleConstruction < ModuleConstruction .

    vars SU SU' : Substitution . var SUBSTS : SubstitutionSet . var MOD : Module . var ME : ModuleExpression .
    vars MDS MDS' MDS'' : ModuleDeclSet . vars MTS MTS' : ModuleTemplateSet . vars MC MC' MC'' : ModuleConstruction . vars NeMC NeMC' : NeModuleConstruction .
    vars S S' S'' F F' FX' FY' NeF : Sort . vars SS SS' : SortSet . vars NeFS NeFS' : NeSortSet . vars OP Nil Q : Qid . var AS : AttrSet . var NES : Variable .
    vars NeMTS NeMTS' : NeModuleTemplateSet . var SPS : SortPoset . var SDS : SortDeclSet . var SSDS : SubsortDeclSet . vars X Y Z X' Y' TH TH' : Sort . vars T T' : Term .









    op        exists_ : ModuleTemplateSet                   -> NeModuleConstruction [     prec 75] .
    op forall_exists_ : ModuleTemplateSet ModuleTemplateSet -> NeModuleConstruction [ctor prec 75] .
    ------------------------------------------------------------------------------------------------
    eq exists MTS = forall none exists MTS .
    eq forall MTS exists NeMTS | NeMTS' = (forall MTS exists NeMTS) | (forall MTS exists NeMTS) .

    op .ModuleConstruction : -> ModuleConstruction [ctor] .
    -------------------------------------------------------
    eq forall MDS MDS' exists MDS = .ModuleConstruction .





    op _;_ : ModuleConstruction   ModuleConstruction ->   ModuleConstruction [ctor assoc      id: .ModuleConstruction prec 76 format(d n d d)] .
    op _;_ : ModuleConstruction NeModuleConstruction -> NeModuleConstruction [ctor assoc      id: .ModuleConstruction prec 76 format(d n d d)] .
    op _|_ : ModuleConstruction   ModuleConstruction ->   ModuleConstruction [ctor assoc comm id: .ModuleConstruction prec 77 format(d n d d)] .
    op _|_ : ModuleConstruction NeModuleConstruction -> NeModuleConstruction [ctor assoc comm id: .ModuleConstruction prec 77 format(d n d d)] .
    ----------------------------------------------------------------------------------------------------------------------------------------
    eq NeMC | NeMC = NeMC .





    op _deriving_ : ModuleDeclSet ModuleConstruction -> ModuleDeclSet [right id: .ModuleConstruction prec 76] .
    -----------------------------------------------------------------------------------------------------------
   ceq MDS deriving forall MTS exists MDS'           = ++(MDS | (MDS' << SUBSTS))                          if SUBSTS := match MTS with MDS .
   ceq MDS deriving forall MTS exists (MDS' \ NeMTS) = ++(MDS | not-instance-of?((MDS' << SUBSTS), NeMTS)) if SUBSTS := match MTS with MDS .
    eq MDS deriving (NeMC ; NeMC')                   = (MDS deriving NeMC) deriving NeMC' .
    eq MDS deriving (NeMC | NeMC')                   = (MDS deriving NeMC) (MDS deriving NeMC') .

    op _deriving_ : ModuleExpression ModuleConstruction -> ModuleExpression [right id: .ModuleConstruction prec 80] .
    -----------------------------------------------------------------------------------------------------------------
    eq #upModule(ME deriving NeMC) = #upModule(ME) deriving NeMC .

    op _deriving_ : Module ModuleConstruction -> [Module] [right id: .ModuleConstruction prec 80] .
    -----------------------------------------------------------------------------------------------
    eq MOD deriving NeMC = fromTemplate(getName(MOD), asTemplate(MOD) deriving NeMC) .







    op #upModule : ModuleExpression -> Module [memo] .
    --------------------------------------------------
    eq #upModule(ME) = upModule(ME, false) [owise] .










    op _<<_ : ModuleConstruction SubstitutionSet -> ModuleConstruction [right id: empty] .
    --------------------------------------------------------------------------------------
    eq (forall MTS exists MDS) << SU = (forall (MTS << SU) exists (MDS << SU)) | (forall MTS exists MDS) .

    eq NeMC << (SU | SU' | SUBSTS) = (NeMC << SU) | (NeMC << SU') | (NeMC << SUBSTS) .

    eq .ModuleConstruction << SU = .ModuleConstruction .
    eq (NeMC | NeMC')      << SU = (NeMC << SU) | (NeMC' << SU) .
    eq (NeMC ; NeMC')      << SU = (NeMC << SU) ; (NeMC' << SU) .





    op for_in__ : Sort SortDeclSet ModuleConstruction -> ModuleConstruction [prec 76] .
    -----------------------------------------------------------------------------------
   ceq for S in ( sorts S' . ) (forall MTS exists MDS) = forall (MTS << SU) exists (MDS << SU) if SU := upTerm(S) <- upTerm(S') .

    eq for S in SDS (NeMC ; NeMC') = (for S in SDS NeMC) ; (for S in SDS NeMC') .
    eq for S in SDS (NeMC | NeMC') = (for S in SDS NeMC) | (for S in SDS NeMC') .

    eq for S in none                      MC = .ModuleConstruction .
    eq for S in ( sorts S' ; S'' ; SS . ) MC = (for S in ( sorts S' . ) MC) | (for S in ( sorts S'' . ) MC) | (for S in ( sorts SS . ) MC) .







    op univ_ : ModuleDeclSet -> ModuleConstruction [prec 75] .
    ----------------------------------------------------------
    eq univ MDS = forall ( sorts fv<Sort>(MDS) . ) exists MDS .

























    op FUNCTOR : Sort SortPoset -> ModuleConstruction .
    ---------------------------------------------------
    eq FUNCTOR(X, none)                 = .ModuleConstruction .
    eq FUNCTOR(X, NeFS ; NeFS')         = FUNCTOR(X, NeFS) | FUNCTOR(X, NeFS') .
    eq FUNCTOR(X, (NeFS < NeFS' < SPS)) = ( FUNCTOR(X, NeFS) | FUNCTOR(X, (NeFS' < SPS)) )
                                        ; forall ( sorts NeFS ; NeFS' . )
                                          exists ( subsorts NeFS < NeFS' . ) .

   ceq FUNCTOR(X, F) = forall ( sorts X . )
                       exists ( sorts F . )
                     ; forall ( sorts X ; X' ; F ; F' . )
                              ( subsort X < X' . )
                       exists ( subsort F < F' . )
                    if X' := prime(X)
                    /\ F' := prime(X, F) .






    op COFUNCTOR : Sort SortPoset -> ModuleConstruction .
    -----------------------------------------------------
    eq COFUNCTOR(X, none)                 = .ModuleConstruction .
    eq COFUNCTOR(X, NeFS ; NeFS')         = COFUNCTOR(X, NeFS) | COFUNCTOR(X, NeFS') .
    eq COFUNCTOR(X, (NeFS < NeFS' < SPS)) = ( COFUNCTOR(X, NeFS) | COFUNCTOR(X, (NeFS' < SPS)) )
                                          ; forall ( sorts NeFS ; NeFS' . )
                                            exists ( subsorts NeFS < NeFS' . ) .

   ceq COFUNCTOR(X, F) = forall ( sorts X . )
                         exists ( sorts F . )
                       ; forall ( sorts X ; X' ; F ; F' . )
                                ( subsort X  < X' . )
                         exists ( subsort F' < F  . )
                      if X' := prime(X)
                      /\ F' := prime(X, F) .





    op PROFUNCTOR : Sort Sort SortPoset -> ModuleConstruction .
    -----------------------------------------------------------
    eq PROFUNCTOR(X, Y, none)                 = .ModuleConstruction .
    eq PROFUNCTOR(X, Y, NeFS ; NeFS')         = PROFUNCTOR(X, Y, NeFS) | PROFUNCTOR(X, Y, NeFS') .
    eq PROFUNCTOR(X, Y, (NeFS < NeFS' < SPS)) = ( PROFUNCTOR(X, Y, NeFS) | PROFUNCTOR(X, Y, (NeFS' < SPS)) )
                                              ; forall ( sorts NeFS ; NeFS' . )
                                                exists ( subsorts NeFS < NeFS' . ) .

   ceq PROFUNCTOR(X, Y, F) = forall ( sorts X ; Y . )
                             exists ( sorts F . )
                           ; ( forall ( sorts X ; X' ; F ; FX' . )
                                      ( subsort X <  X' . )
                               exists ( subsort F < FX' . )
                             | forall ( sorts Y ; Y' ; F ; FY' . )
                                      ( subsort  Y  < Y' . )
                               exists ( subsort FY' < F  . )
                             )
                          if X'  := prime(X)    /\ Y'  := prime(Y)
                          /\ FX' := prime(X, F) /\ FY' := prime(Y, F) .









    op BINARY-DATA : Sort Qid AttrSet -> ModuleConstruction .
    ---------------------------------------------------------
   ceq BINARY-DATA(F, OP, AS) = FUNCTOR(X, (X < NeF{X} < F{X}))
                              ; forall ( sorts    X ; NeF{X} ; F{X} . )
                                       ( subsorts X < NeF{X} < F{X} . )
                                exists ( op Nil : nil             ->   F{X} [ctor] .
                                         op OP  : (F{X})   (F{X}) ->   F{X} [ctor id(const(Nil, F{X})) AS] .
                                         op OP  : (F{X}) (NeF{X}) -> NeF{X} [ctor id(const(Nil, F{X})) AS] .
                                       )
                             if X   := var<Sort>('X)
                             /\ NeF := qid("Ne" + string(F))
                             /\ Nil := qid("."  + string(F)) .












   ops LIST MSET SET : -> ModuleConstruction .
   -------------------------------------------
    eq LIST = BINARY-DATA('List, '_`,_, assoc) .
    eq MSET = BINARY-DATA('MSet, '_;_, assoc comm) .
   ceq SET  = BINARY-DATA('Set, '_;_, assoc comm)
            ; forall ( sorts 'NeSet{var<Sort>('X)} . )
              exists ( eq '_;_[NES, NES] = NES [none] . )
           if NES := var('NeS, 'NeSet{var<Sort>('X)}) .








    op EXPONENTIAL : -> ModuleConstruction .
    ----------------------------------------
   ceq EXPONENTIAL = PROFUNCTOR(X, Y, X ==> Y) << (upTerm(X) <- upTerm(Y))
                   ; forall ( sorts X ==> Y . )
                     exists ( op '__ : (X ==> Y) X -> Y [none] . )
                   ; ( forall ( sorts X ==> Y ; Y ==> Z ; X ==> Z . )
                       exists ( op '_._ : (Y ==> Z) (X ==> Y) -> X ==> Z [none] .
                                op '_;_ : (X ==> Y) (Y ==> Z) -> X ==> Z [none] .
                              )
                     ) << ((upTerm(X) <- upTerm(Y)) | (upTerm(Y) <- upTerm(Z)) | (upTerm(X) <- upTerm(Z) ; upTerm(X) <- upTerm(Z)))
                   ; forall ( sorts X ==> X . )
                     exists ( op 'id < X > : nil -> X ==> X [ctor] . )
                            ( eq '__[const('id < X >, X ==> X), var('X, X)] = var('X, X) [none] . )
                  if X := var<Sort>('X)
                  /\ Y := var<Sort>('Y)
                  /\ Z := var<Sort>('Z) .












    sort ModModuleConstruction .
    ----------------------------
    var MMC : ModModuleConstruction .

    op _<_> : ModModuleConstruction Qid -> ModuleConstruction .
    -----------------------------------------------------------

    op _deriving_ : ModuleExpression ModModuleConstruction -> ModuleExpression [prec 80] .
    --------------------------------------------------------------------------------------
    eq ME deriving MMC = ME deriving (MMC < ME >) .

    op _deriving_ : Module ModModuleConstruction -> [Module] [prec 80] .
    --------------------------------------------------------------------
    eq MOD deriving MMC = MOD deriving (MMC < getName(MOD) >) .








    op cmb-pred : Sort Sort Qid -> MembAx .
    ---------------------------------------
    eq cmb-pred(S, S', Q) = ( cmb var('X, S) : S' if Q[var('X, S)] = 'true.Bool [none] . ) .

    op top-sorts : Sort -> ModuleTemplateSet .
    ------------------------------------------
    eq top-sorts(S) = (sorts S .) \ ((sorts S ; prime(S) .) subsort S < prime(S) .) .

    op sort-intersect : Sort -> ModuleConstruction .
    ------------------------------------------------
   ceq sort-intersect(S) = forall ( sorts S{X} ; S{Y} . )
                           exists ( sorts S{X Y} . )
                                  ( subsorts S{X Y} < S{X} ; S{Y} . )
                                  ( cmb var('T, S{X}) : S{X Y} if var('T, S{X}) : S{Y} [none] .
                                    cmb var('T, S{Y}) : S{X Y} if var('T, S{Y}) : S{X} [none] .
                                  )
                        if X := var<Sort>('X)
                        /\ Y := var<Sort>('Y) .

    op DOWN-TERM : -> ModModuleConstruction .
    -----------------------------------------
   ceq DOWN-TERM < Q > =   exists ( pr 'META-LEVEL .
                                    pr Q .
                                  )
                         ; FUNCTOR(X, (X < X ?))
                         ; forall ( sorts X ; X ? . )
                                  ( subsort X < X ? . )
                           exists ( op 'downTermError < X > : nil   -> X ?   [ctor] .
                                    op 'downTerm      < X > : 'Term -> X ?   [none] .
                                    op 'wellFormed    < X > : 'Term -> 'Bool [none] .
                                  )
                                  ( ceq 'downTerm   < X > [var('T, 'Term)] = var('X, X) if var('X, X) := 'downTerm[var('T, 'Term), const('downTermError < X >, X ?)] [none] .
                                    ceq 'wellFormed < X > [var('T, 'Term)] = 'true.Bool if var('X, X) := 'downTerm < X > [var('T, 'Term)] [none] .
                                  )
                      if X := var<Sort>('X) .

    op META-TERM : -> ModModuleConstruction .
    -----------------------------------------
   ceq META-TERM < Q > =   DOWN-TERM < Q >
                         ; exists tag-sorts(Q, (SDS SSDS))
                         ; for TH in SDS ( exists ( subsort TH{Q} < TH . )
                                         ; forall ( sorts X ; X ? . ) exists ( sorts TH{X @ Q} . )
                                         ; forall top-sorts(X ?)      exists ( subsort TH{X @ Q} < TH{Q} . )
                                         )
                         ; FUNCTOR(TH{Q}, TH{X @ Q})
                         ; FUNCTOR(X, TH{X @ Q})
                      if SDS SSDS := connected-component(asTemplate('META-TERM), ( sorts 'Term . ))
                      /\ X        := var<Sort>('X)
                      /\ Y        := var<Sort>('Y)
                      /\ TH       := var<Sort>('TH) .

    op tmp-mb : Sort Sort Qid -> ModuleConstruction .
    -------------------------------------------------
    eq tmp-mb(S, S', Q) = forall ( sorts S ; S ? ; S'{Q @ S} . )
                          exists ( cmb-pred( S' , S'{Q @ S} , 'wellFormed < S > ) ) .

    op META-THEORY : -> ModModuleConstruction .
    -------------------------------------------
   ceq META-THEORY < Q > =   ( DOWN-TERM < Q > | META-TERM < Q > )
                           ; tmp-mb(X, 'Constant,   Q)
                           ; tmp-mb(X, 'GroundTerm, Q)
                           ; tmp-mb(X, 'Variable,   Q)
                           ; tmp-mb(X, 'Term,       Q)
                        if X := var<Sort>('X) .
endfm


