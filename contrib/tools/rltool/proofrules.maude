fmod INTERSECT-REACHFORM is
  pr REACH-PROOF-GOAL-SIMPLIFICATION .
  pr TRANSITION-OPERATIONS .
  pr TRANSITIONSET-RENAME .
  pr TRANSITIONSET-SUBSTITUTION .
  var U : Module .
  var T : Term . var C C' : QFForm? . var D TST : QFCTermSet . var R : ReachForm .
  var FSS : FOFormSubstPairSet . var S : Substitution .

  op intersectReachform : Module QFCTermSet ReachForm -> ReachFormSet .
  eq intersectReachform(U,TST,(T | C) => D) = intersectReachform(U,#intersect(U,(T | C),TST),(T | C) => D) .

  op intersectReachform : Module FOFormSubstPair ReachForm -> ReachFormSet .
  eq intersectReachform(U,mtFSPS,R) = mt .
  eq intersectReachform(U,(C',S) | FSS,R) =
    renameTmpVar(U,notFound,conj-antc(R << S,C')) & intersectReachform(U,FSS,R) .

  op simplifyIntersectReachform : Module QFCTermSet ReachForm -> ReachFormSet .
  eq simplifyIntersectReachform(U,TST,R) = full-goal-simplify(U,intersectReachform(U,TST,R)) .
endfm

fmod REACH-PROOF-GOAL-SUBSUMPTION is
  pr REACH-PROOF-STATE-OPS                 . --- state getters
  pr RLTOOL-BACKEND-IMPL                   . --- checkVal/checkUnsat
  pr CONSTRAINED-TERMSET-MATCH             . --- subsumeByMatch
  pr INTERSECT-REACHFORM                   . --- intersectReachform

  var D : ProofMetadata . var MA : QFCTerm . var MF MF' TST : QFCTermSet .
  var B : Bool . var MB : MaybeBool .
  var F F' : QFForm? . var FSS : FOFormSubstPairSet . var S : Substitution .
  var U : Module . var R : ReachForm . var RS : ReachFormSet .

  --- OUT: True if the first set gets subsumed by the second
  op syn-subsume? : ProofMetadata QFCTermSet QFCTermSet -> MaybeBool .
  eq syn-subsume?(D,MF,MF') = subsumeByMatch(get-mod(D),MF,MF') .

  --- PRE: MatchAtom and MatchForm are well-defined with respect to ProofMetadata
  --- OUT: Bool is true means parameterized; otherwise unparameterized
  ----     True if formula generated by subsumeIfValid() is not satisfiable
  op sem-subsume? : ProofMetadata Bool QFCTermSet QFCTermSet -> MaybeBool .
  op sem-subsume? : ProofMetadata Bool QFCTerm    QFCTermSet -> MaybeBool .
  eq sem-subsume?(D,B,MA,MF)  = checkVal(D,subsumeIfValid(get-mod(D),B,MA,MF)) .
  eq sem-subsume?(D,B,MF,MF') =
    errb('Internal 'Error: 'Semantic 'subsumption 'only 'supports 'term 'sets 'on 'RHS) [owise] .

  op subsume? : ProofMetadata Bool ReachFormSet -> MaybeBool .
  eq subsume?(D,B,MA => MF) = sem-subsume?(D,B,MA,MF) .

  --- OUT: true iff the QFCTermSet is disjoint from the head of the reachform or
  ---      the intersected goal is provably subsumed
  op disjointOrSubsume : ProofMetadata QFCTermSet ReachForm -> MaybeBool .
  eq disjointOrSubsume(D,TST,MA => MF) =
    disjointOrSubsume(D,simplifyIntersectReachform(get-mod(D),TST,MA => MF)) .

  op disjointOrSubsume : ProofMetadata ReachFormSet -> MaybeBool .
  eq disjointOrSubsume(D,R & RS) = disjointOrSubsume(D,subsume?(D,true,R),RS) .
  eq disjointOrSubsume(D,mt) = true .

  op disjointOrSubsume : ProofMetadata MaybeBool ReachFormSet -> MaybeBool .
  eq disjointOrSubsume(D,MB,R & RS) = disjointOrSubsume(D,strict-and(MB,subsume?(D,true,R)),RS) .
  eq disjointOrSubsume(D,MB,mt) = strict-and(MB,true) .
endfm

--- This module defines a function to apply a list of axioms (labelled reach formulas)
--- to a reach formula that represent a goal that we wish to prove.
--- The result is a data structure that records the new goal that would be generated
--- after applying the axiom as well as any formula which we need to prove valid in
--- order to apply the axiom --- i.e. to prove that the axiom LHS constrained term
--- subsumes the LHS constrained term of the reach formula in an unparameterized way
--- N.B. we cannot reuse the subsumption code above we that code only generates the
---      formula we would need to prove validity, but it does not give us access to
---      the substitutions that axiom rule application generated which are needed in
---      order to compute axiom rule successors.
fmod TRANSITION-APPLICATION is
  pr TRANSITIONSET-SUBSTITUTION            .
  pr TRANSITION-CONVERSIONS                .
  pr FOFORMSUBSTITUTION-PAIRSET            .
  pr FOFORM-TRANSITIONSET-PAIR-LIST        .
  pr LABEL-TRANSITION-CONVERSIONS          .
  pr DEBUG-PRINT                           . --- debug-print()
  pr AXIOM-RESULT                          .
  pr CONSTRAINED-TERMSET-MATCH             .
  pr PATTERN-OPS                           .

  var U : Module . var QF QF' : QFForm? .
  var F F' : ReachForm . var AX : LabelReachForm . var AXL : LabelReachFormList .
  var S : Substitution . var FSPS : FOFormSubstPairSet .
  var FK : [FOFormSubstPairSet] . var AK : [LabelReachForm] .

  op apply-axioms : Module ReachForm LabelReachFormList -> [AxiomResultList] .
  eq apply-axioms(U,F,AX ; AXL) = if apply-syn-axiom(U,F,AX) =/= nilax
                                    then apply-syn-axiom(U,F,AX)
                                    else apply-sem-axiom(U,F,AX)
                                  fi apply-axioms(U,F,AXL) .
  eq apply-axioms(U,F,nil) = nilax .
  eq apply-axioms(U,F,AK) = errAxiomResult('Internal 'Error: 'apply-axioms 'ill-formed 'axiomlist '\n) .

  op apply-syn-axiom : Module ReachForm LabelReachForm -> AxiomResultList .
  eq apply-syn-axiom(U,F,AX) = apply-axiom(F,AX,matches(U,antc(trans(AX)),antc(F))) .

  op apply-sem-axiom : Module ReachForm LabelReachForm -> AxiomResultList .
  eq apply-sem-axiom(U,F,AX) = apply-axiom(F,AX,
    apply-sem-axiom(lhs-cond(F),applyMatchToCond(U,none,antc(F),antc(trans(AX))))) .

  op apply-sem-axiom : QFForm? FOFormSubstPairSet ~> FOFormSubstPairSet .
  eq apply-sem-axiom(QF,(QF',S) | FSPS) = (QF ==> QF',S) | apply-sem-axiom(QF,FSPS) .
  eq apply-sem-axiom(QF,mtFSPS)         = mtFSPS .

  --- NB:  This is a helper function that replaces the antecedent of the original ReachForm
  ---      by the succedent of the instantiated axiom ReachForm
  op apply-axiom : ReachForm LabelReachForm FOFormSubstPairSet -> AxiomResultList .
  eq apply-axiom(F,AX,(QF,S) | FSPS) = axrule(AX,S,QF,divide(conj(succ(trans(AX)) << S,lhs-cond(F)) => succ(F))) apply-axiom(F,AX,FSPS) .
  eq apply-axiom(F,AX,mtFSPS) = nilax .
  eq apply-axiom(F,AX,FK) = errAxiomResult(errFOFormSubstPairMsg(FK)) [owise] .
endfm

--- Implementation of reach proof rules follows a few important conventions:
--- [1] the ProofMetadata which contains all of the information needed to complete
---     any operation is passed along as needed
--- [2] each operation extracts out the values it needs from the ProofMetadata before
---     evaluating further --- this eases debugging since the ProofMetadata object can
---     be hidden, allowing only the "real" arguments to appear
--- [3] the result of a proof operation is a ProofUpdate object which, in fact, is
---     isomporphic to the NormalProof itself --- however, the meaning of a ProofUpdate
---     computed from a proof step is NOT to replace the NormalProof --- rather, a
---     merge rule will be called, merging the ProofUpdate into the NormalProof object
---     to produce a new NormalProof
---     NB: essentially, this is a generalization of MSOS write-only fields
--- In the end, we have a system that has:
--- [a] easy extensibility - if we need to pass more arguments along, we can
--- [b] easy debuggability - function returns only interesting data
fmod REACH-PROOF-RULES-AUX is
  pr REACH-PROOF-GOAL .
  pr LCCRULE-NARROWING .
  pr REACH-PROOF-GOAL-SUBSUMPTION .
  pr TRANSITION-APPLICATION .
  pr FOFORMSET-RENAME .
  pr TRANSITIONSET-RENAME .
  pr RLTOOL-SWITCHES .
  pr SUBSTITUTIONSET-AUX .

  var ID GN VC : Nat . var CNT : FindResult .
  var V : Variable . var TS : TermSet .
  var QF QF' : QFForm . var F F' : ReachForm . var FS : ReachFormSet .
  var G : ProofGoal . var GS : ProofGoalSet .
  var AR : AxiomResult . var ARL ARL' : AxiomResultList .

  var U : Module .
  var LRS : LabelLCCRuleSet .
  var TST : QFCTermSet .
  var S : Substitution .
  var CN CN' : ProofStrat .
  var D D' : ProofMetadata .
  var B : Bool .
  var BK : [Bool] .
  var MB : MaybeBool .
  var AXL : LabelReachFormList .
  var AX : LabelReachForm .

  var MG  : MaybeProofGoal .
  var MGK : [MaybeProofGoal] .
  var QL  : QidList .
  var FSK : [ReachFormSet] .
  var ARLK : [AxiomResultList] .

  op simp-action : ProofMetadata Module ProofGoal -> ProofUpdate .
  eq simp-action(D,U,G) = (none || newChildGoals(G,goal-simplify(U,getbody(G)))) .

  op termcheck-action : ProofMetadata Module QFCTermSet ProofGoal -> ProofUpdate .
  op termcheck-action : ProofMetadata Module Bool ProofGoal -> ProofUpdate .
  eq termcheck-action(D,U,TST,G) = termcheck-action(D,U,disjointOrSubsume(D,TST,getbody(G)),G) .
  eq termcheck-action(D,U,MB,G) =
    if MB == true
      then (none || copyGoalToChild(G))
      else (out('Warning: 'goal &sp printGoals(U,G) &sp 'may 'have 'terminated '\n) || copyGoalToChild(G))
    fi .
  eq [handle-error] :
     termcheck-action(D,U,BK,G) = (out('Warning: 'termination 'check 'on &sp printGoals(U,G) &sp 'encountered 'an 'error boolErrMsg(BK) '\n)) [owise] .

  --- NOTE: we filter successfully generated step successors through
  ---       renaming + normalization and since A/C/U matching often
  ---       leads to redundant goals being generated
  op step-action : ProofMetadata Module LabelLCCRuleSet ProofGoal -> ProofUpdate .
  op step-action : ProofMetadata Module [ReachFormSet] ProofGoal -> ProofUpdate .
  eq step-action(D,U,LRS,G) = step-action(D,U,top-narrow(U,LRS,getbody(G)),G) .
  eq step-action(D,U,FS,G) =
     if FS == mt or not wellFormed(U,FS) then
       (if FS == mt then out('Warning: 'narrowing 'on 'goal &sp printGoals(U,G) &sp 'generated 'zero 'successors '\n) else none fi ;
        if not wellFormed(U,FS) then out('Warning: 'narrowing 'on 'goal printGoalIds(G) 'generated 'ill-formed 'successors '\n) else none fi)
     else
       (none || deleteDuplGoals(renameNormalizeGoal(U,get-cnt(D),newChildGoals(G,FS))))
     fi .
  eq [handle-error] :
     step-action(D,U,FSK,G) =
     (if FSK :: ReachFormSet then none else out('Warning: 'narrowing 'on 'goal &sp printGoals(U,G) &sp 'encountered 'an 'error errReachFormMsg(FSK) '\n) fi) [owise] .

  op sub-action : ProofMetadata Module ProofGoal -> ProofUpdate .
  op sub-action : Module [Bool] ProofGoal -> ProofUpdate .
  eq sub-action(D,U,G) = sub-action(U,subsume?(D,true,full-goal-simplify(U,getbody(G))),G) .
  eq sub-action(U,MB,G) =
    if MB == true
      then (none || mt)
      else if MB == nobool
        then (out('Warning: 'goal &sp printGoals(U,G) &sp 'satisfaction 'unknown: 'conservatively 'retaining 'goal '\n) || copyGoalToChild(G))
        else (none || copyGoalToChild(G))
      fi
    fi .
  eq [handle-error] :
     sub-action(U,BK,G) = (out('Warning: 'checking 'goal &sp printGoals(U,G) &sp 'satisfaction 'encountered 'an 'error boolErrMsg(BK) '\n)) [owise] .

  op ax-action : ProofMetadata Module LabelReachForm ProofGoal -> ProofUpdate .
  op ax-action : ProofMetadata Module LabelReachForm [AxiomResultList] ProofGoal -> ProofUpdate .
  op ax-action : ProofMetadata Module ProofMetadata [MaybeBool] AxiomResultList AxiomResultList ProofGoal -> ProofUpdate .
  eq ax-action(D,U,AX,G) = ax-action(D,U,AX,apply-axioms(U,getbody(G),AX),G) .
  eq ax-action(D,U,AX,nilax,G) = (if printAxiomFailures then out('Notice: 'no 'syntactically 'usable 'instances 'of 'axiom print(U,AX) 'found 'for &sp printGoals(U,G) '\n) else none fi) .
  eq ax-action(D,U,AX,AR ARL,G) = ax-action(D,U,none,checkVal(D,arCond(AR)),ARL,AR,G) .
  eq [handle-error] :
     ax-action(D,U,AX,ARLK,G) = (out('Warning: 'generating 'axiom print(U,AX) 'successors 'for &sp printGoals(U,G) &sp 'encountered 'an 'error errAxiomResultMsg(ARLK) '\n)) [owise] .

  eq ax-action(D,U,D',BK,AR ARL,ARL',G) =
     if BK == true
       then (his(insert(getid(G),usedAxRec(ARL',AR ARL),empty)) || newChildGoals(G,arRes(ARL')))
       else ax-action(D,U,printAxFailure(D',U,BK,arAx(ARL'),G), checkVal(D,arCond(AR)), ARL,AR ARL', G)
     fi .
  eq ax-action(D,U,D',BK,nilax,ARL',G) =
     if BK == true
       then (his(insert(getid(G),usedAxRec(ARL',nilax),empty)) || newChildGoals(G,arRes(ARL')))
       else (printAxFailure(D',U,BK,arAx(ARL'),G) ; his(insert(getid(G),axrec(ARL'),empty)))
     fi .

  op printAxFailure : ProofMetadata Module [MaybeBool] LabelReachForm ProofGoal -> ProofMetadata .
  eq printAxFailure(D',U,MB,AX,G) = D' ; if printAxiomFailures and MB == nobool then out('Notice: 'axiom print(U,AX) 'validity 'for 'goal &sp printGoals(U,G) &sp 'unknown '\n) else none fi .
  eq printAxFailure(D',U,BK,AX,G) = D' ; out('Warning: 'axiom print(U,AX) 'validity 'check 'for 'goal &sp printGoals(U,G) &sp 'encountered 'an 'error boolErrMsg(BK) '\n) .

  op usedAxRec : AxiomResultList AxiomResultList -> AxiomRecord .
  eq usedAxRec(ARL,ARL') = axrec(head(ARL),delete(head(ARL),ARL')) .

  --- Derived Rules

  op case-action : ProofMetadata Module Variable TermSet ProofGoal -> ProofUpdate .
  eq case-action(D,U,V,TS,G) =
    if V in vars(antc(getbody(G))) == true
      then if intersection(vars(TS),vars(getbody(G))) == none
        then if wellFormedSet(U,assignments(V,TS)) == true
          then (none || newChildGoals(G,getbody(G) << assignments(V,TS)))
          else (out('Warning: 'case 'rule 'substitution 'is 'not 'well-formed '\n))
        fi else (out('Warning: 'case 'rule 'terms 'intersect 'unsafely 'with 'goal 'target '\n))
      fi else (out('Warning: 'case 'rule 'variable 'must 'be 'in 'goal 'head '\n))
    fi .

  op split-action : ProofMetadata Module Bool QFForm QFForm ProofGoal -> ProofUpdate .
  op split-action2 : ProofMetadata Module Bool QFForm QFForm ProofGoal -> ProofUpdate .

  eq split-action(D,U,true,QF,QF',G) = split-action2(D,U,true,QF /\ rhs-cond(getbody(G)),QF' /\ rhs-cond(getbody(G)),G) .
  eq split-action(D,U,false,QF,QF',G) = split-action2(D,U,true,QF,QF',G) .

  eq split-action2(D,U,B,QF,QF',G) =
    if QF == QF' then
      (out('Warning: 'prevented 'attempted 'split 'on 'identical 'formulas))
    else if QF == ff then
      (st(err) ; out('Error: 'invalid 'split 'value))
    else if safeVars(gather(getbody(G) & set-lhs-cond(getbody(G),QF) & if QF' =/= ff then set-lhs-cond(getbody(G),QF') else mt fi))
      then (out(if B or-else checkVal(D,rhs-cond(getbody(G)) <==> QF \/ QF') == true
                  then nil
                  else 'For 'full 'verification '`, &sp 'check 'formula 'equivalence 'manually '\n
                fi)
            || newChildGoals(G,set-lhs-cond(getbody(G),QF) & if QF' == ff then mt else set-lhs-cond(getbody(G),QF') fi))
      else (out('Warning: 'split 'rule 'formulas 'have 'unsafe 'variable 'sharing '\n))
    fi fi fi .

  var PA : ProofRuleAction .

  --- TODO: add flag (or separate function) for one-off runs, to support use-cases like the split rule
  ---       so that we do not invalidate a goal after failing to apply the rule
  op apply-proof-strat : ProofMetadata ProofGoal -> ProofMetadata? .
  eq apply-proof-strat(D,G) = lift-result(G,getstrat(G),D,apply-proof-action(D,nextaction(getstrat(G)),G)) .

  op apply-proof-action : ProofMetadata ProofStrat ProofGoal -> ProofUpdate .
  eq apply-proof-action(D,simplify,G)   = simp-action(D,get-mod(D),G) [print "simp-action"] .
  eq apply-proof-action(D,subsume,G)    = sub-action(D,get-mod(D),G) [print "sub-action"] .
  eq apply-proof-action(D,termcheck,G)  = termcheck-action(D,get-mod(D),get-tst(D),G) [print "termcheck-action"] .
  eq apply-proof-action(D,step,G)       = step-action(D,get-mod(D),get-rls(D),G) [print "step-action"] .
  eq apply-proof-action(D,axiom(AX),G)  = ax-action(D,get-mod(D),AX,G) [print "ax-action"] .
  eq apply-proof-action(D,case(V,TS),G) = case-action(D,get-mod(D),V,TS,G) [print "case-action"] .
  eq apply-proof-action(D,split(B,QF,QF'),G) = split-action(D,get-mod(D),B,QF,QF',G) [print "split-action"] .
  eq apply-proof-action(D,pause,G)      = (none || newChildGoals(G,getstrat(G),paused,getbody(G))) [print "pause-action"] .
  eq apply-proof-action(D,giveup,G)     = (none || newChildGoals(G,getstrat(G),inactive,getbody(G))) [print "giveup-action"] .

  op lift-result : ProofGoal ProofStrat ProofMetadata ProofUpdate -> ProofMetadata? .
  eq lift-result(G,CN,D,(D')) =
    if update(false,CN) == giveup
      then lift-result(G,D,raw-set(D',out('Notice: 'proof 'branch 'failed: &sp printGoals(get-mod(D),G) '\n)),mt)
      else lift-result(G,D,D',newChildGoals(G,update(false,CN),active,getbody(G)))
    fi .
  eq lift-result(G,CN,D,(D' || GS)) =
    if update(true,CN) == giveup
      then lift-result(G,D,raw-set(D',out('Notice: 'proof 'branch 'failed: &sp printGoals(get-mod(D),G) '\n)),mt)
      else lift-result(G,D,D',setstrat(GS,update(true,CN)))
    fi .
endfm

mod REACH-PROOF-RULES is
  pr REACH-PROOF-RULES-AUX .

  var D : ProofMetadata .
  var P P2 : Parent .
  var ID ID2 : Nat .
  var CN CN2 : ProofStrat .
  var PS PS2 : ProofGoalStatus .
  var PPS : ProofStatus .
  var F : ReachForm .
  var GS : ProofGoalSet .

  rl [select-goal] :
     {D ; st(PPS) ; prf(GS)}
  => if getActiveGoal(GS) :: ProofGoal
       then [merge(D ; prf(delgl(GS,getActiveGoal(GS))) ; st(PPS), apply-proof-strat(D,getActiveGoal(GS)))]
       else [D ; st(done) ; prf(GS)]
     fi .
endm
