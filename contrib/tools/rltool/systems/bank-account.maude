load ../theories/numbers.maude

mod BANK-ACCOUNT is
  protecting FVP-NAT-PRED .

  sorts Msg MsgConf .
  subsort Msg < MsgConf .

  op withdraw : Nat -> Msg [ctor] .
  op mt       : -> MsgConf [ctor] .
  op _,_ : MsgConf MsgConf -> MsgConf [ctor assoc comm id: mt] .
  --------------------------------------------------------------

  sort Account .

  op < bal:_pend:_overdraft:_> : Nat Nat Bool -> Account [ctor] .
  ----------------------------------------------------------------

  sorts State .

  op _#_ : Account MsgConf -> State [ctor] .
  ------------------------------------------

  vars n m x : Nat . var p : NzNat . var msgs : MsgConf .

  *** requesting to draw money having sufficient funds; the amount requested is
  *** added to the amount of pending withdraw requests
  rl [mark-withdrawal] :
     < bal: n + m + x pend: x     overdraft: false > #               msgs
  => < bal: n + m + x pend: x + m overdraft: false > # withdraw(m) , msgs .

  rl [overdraft] :
     < bal: n pend: x              overdraft: false > # withdraw(n + p) , msgs
  => < bal: 0 pend: x monus n + p  overdraft: true  > # msgs .

  rl [withdraw] :
     < bal: n + m pend: x          overdraft: false > # withdraw(m) , msgs
  => < bal: n     pend: x monus m  overdraft: false > # msgs .

  *** more money can at any time be deposited in the account if it is not in overdraft
  rl [deposit] :
     < bal: n     pend: x overdraft: false > # msgs
  => < bal: n + m pend: x overdraft: false > # msgs [nonexec] .
endm

mod BANK-ACCOUNT-DEFINEDOPS is
  protecting BANK-ACCOUNT .

  vars X Y : Bool . var K N M : Nat . var MSGS : MsgConf .

  --- idea that will work:
  --- split up MsgConf into two mutually exclusive sorts
  --- [1] the sort of confs that add up to zero
  --- [2] the sort of confs that add up to a nonzero num
  --- [3] subsort the debts function in each case
  --- [4] add an equation that makes the debts function
  ---     zero in the zero conf case
  --- [5] add the equations below but replacing the N
  ---     with a NzNat
  --- Finally, in the middle of the proof, do a case
  --- analysis on the MsgConf variable


  op debts : MsgConf -> Nat .
  ---------------------------
  eq debts(mt)                 = 0 .
  eq debts(withdraw(N) , MSGS) = N + debts(MSGS) .

  op nonzero? : Nat -> Bool .
  eq nonzero?(0) = false .
  eq nonzero?(K) = true [owise] .

 ceq K + N <= K + M = N <= M if nonzero?(K) .
 ceq K + N <= 0     = N <= 0 if nonzero?(K) .
endm

mod BANK-ACCOUNT-stop is
  pr BANK-ACCOUNT-DEFINEDOPS .
  op [_,_] : Account MsgConf -> State [ctor] .
  rl [stop] : A:Account # M:MsgConf => [A:Account,M:MsgConf] .
endm
