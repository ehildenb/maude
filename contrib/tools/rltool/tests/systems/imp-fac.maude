load ../../systems/imp.maude

fmod IMP-FAC is
  pr IMP-SYNTAX+MUL .

  var N M : Nat .
  var P : NzNat .

  op fac : Nat -> Nat .
  eq fac(N + 1) = (N + 1) * fac(N) .
  eq fac(0) = 1 .

  eq (N + 1) <= (N + P) = true .
endfm

mod IMP-SEMANTICS+FAC is
  pr IMP-SEMANTICS .
  pr IMP-FAC .
endm

load ../../rltool.maude

(select IMP-SEMANTICS+FAC .)
(use tool impsimp for validity on IMP-FAC with FOFORMSIMPLIFY-IMP-IMPL .)
(use tool varsat  for unsatisfiability on IMP-SYNTAX .)
(def-term-set (< done | E:Env >) | true .)
(declare-vars (CNT:Nat) U (TOT:Nat) U (CNT':Nat) U (TOT':Nat) U (MAX:Nat) .)

---
--- To obtain the true factorial program, just let TOT = 1 in the precondition
---
--- PROGRAM:
--- tot = fac(0)
--- while (count < max) {
---   count = count + 1
---   tot   = tot * count
---
--- INVARANT: 
--- CNT <= MAX
--- TOT = fac(CNT)
---
--- POSTCONDITION:
--- CNT = MAX
--- TOT = fac(MAX)
---
(add-goal fac : (< while (x <: x,,) {
		     x  = x  +: 1 ;
                     x, = x, *: x ;
		   } ~> done | x |-> CNT * x, |-> TOT * x,, |-> MAX >) | (CNT <= MAX) = (true) /\ (TOT) = (fac(CNT))
	      =>
                (< done | x |-> CNT' * x, |-> TOT' * x,, |-> MAX >) | (CNT') = (MAX) /\ (TOT') = (fac(MAX)) .)
(start-proof .)
(step .) (continue .)
(step .) (continue .)
(step .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .)
(step .)
(step .) (continue .) 
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .) (continue .)
(step .)
(list-goals .)
quit
