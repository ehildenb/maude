load ../../systems/reverse-bakery.maude
load ../../rltool.maude

(select REVERSE-BAKERY-stop .)
(use tool varsat for validity on BAKERY-STATE .)

(def-term-set ([C:Conf]) | true .)
(declare-vars (A:Nat ) U (B:Nat ) U (C:Nat ) U (D:Nat ) U (E:Nat ) U (F:Nat ) U (PS:ProcSet ) U
              (A':Nat) U (B':Nat) U (C':Nat) U (D':Nat) U (E':Nat) U (F':Nat) U (PS':ProcSet).)

(inv mutex to '`[_`] on
(< A ; B ; [C,crit(D)]             PS >) | (B)      =/= (D)    \/
(< A ; B ; [C,crit(E)] [D,crit(F)] PS >) | (E)       =  (F)    \/
(< A ; B ; [C,crit(E)] [D,wait(F)] PS >) | (F <= E)  =  (true) \/
(< A ; B ; [C,wait(E)] [D,wait(F)] PS >) | (E)       =  (F)    \/
(< A ; B ; [C,wait(B)] [D,wait(E)] PS >) | (E <= B)  =  (true) \/
(< A ; B ; [C,wait(D)]             PS >) | (A <= D)  =  (true) \/
(< A ; A ; [B,wait(C)]             PS >) | (C <  A)  =  (true) \/
(< A ; A ; [B,crit(C)]             PS >) | true                \/
(< A ; B ;                         PS >) | (A <  B)  =  (true) \/
(< A ; B ; [C,crit(D)]             PS >) | (A <= D)  =  (true)
.)
(start-proof .)
(on 1  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 2  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 3  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 4  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 4  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 5  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 6  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 7  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 8  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 9  use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(on 10 use strat mutex#1 mutex#2 mutex#3 mutex#4 mutex#5 mutex#6 mutex#7 mutex#8 mutex#9 mutex#10 .)
(step .)
--- TODO: add symbolic auto-split command that can be added to the default strategy
---       language so that these problems can be handled just by providing patterns
---       and so that the proof becomes totally agnostic towards the goal numbering
--- < A ; B ; [D,crit(E)] [F,wait(B)] > | B =/= E
--- split on B <= E
(subsume 396 by 400 .)
(split 400 by (&220:Nat <= &223:Nat) = (true) .)
--- < A ; B ; [D,crit(E)][F,crit(B)] > | E =/= 1 + B
--- split on E = B
(subsume 397 by 399 .)
(split 399 by (&220:Nat) = (&223:Nat) .)
--- <(1 + A) ; A ; [B,crit(C)][D,crit(A)]> | true
(subsume 407 by 408 .)
(split 408 by (&219:Nat) = (&222:Nat) .)
--- < A ; A ; [B,wait(C)] > | true = C <= A
--- split on A <= C
(subsume 432 by 433 .)
(split 433 by (&219:Nat <= &222:Nat) = (true) .)
--- < A ; B ; [C,wait(D)] [E,wait(1 + B)] [F,crit(B)] > | true = D <= 1 + B
--- split on D <= B
(subsume 435 by 440 .)
(split 440 by (&224:Nat <= &220:Nat) = (true) .)
(step .)
quit
