% !TEX root = main.tex

\section{Rewriting Logic and Rewriting Modulo SMT in a Nutshell}
\label{sec.rewsmt}

This section briefly explains  order-sorted rewriting logic and rewriting
modulo SMT, summarizing Sections 2--5
in~\cite{rocha-rewsmtjlamp-2017}.  Rewriting
logic~\cite{meseguer-rltcs-1992} is a semantic framework that unifies
a wide range of models of concurrency. 
%Specifications in rewriting
%logic are called rewrite theories and can be executed in the rewriting
%logic implementation Maude~\cite{clavel-maudebook-2007}.  By being
%executable, they benefit from a set of formal analysis tools available
%to Maude, such as state-space exploration and automata-based LTL model
%checking. 
Maude~\cite{clavel-maudebook-2007} is a language and tool to support 
the formal specification and analysis of concurrent systems in rewriting logic.
%
Rewriting modulo SMT~\cite{rocha-rewsmtjlamp-2017} is a
symbolic technique to model and analyze reachability properties of
infinite-state systems in rewriting logic, that can %also 
be executed
in Maude by querying decision procedures available from SMT
technology.

\subsection{Order-Sorted Rewrite Theories}

%First, some basic concepts of order-sorted equational theories and
%substitutions are needed.  
An \emph{order-sorted signature} $\Sigma$
is a tuple $\Sigma {=}(S,\leq,F)$ with a finite poset of sorts
$(S,\leq)$ and set of function symbols $F$ typed with sorts in $S$,
which can be subsort-overloaded. The \emph{set of function symbols of
  sort $w \in S^*$ in $\Sigma$} is denoted by $\Sigma_w$. 
%
The binary
relation $\equiv_\leq$ denotes the equivalence relation
$(\leq\cup\geq)^+$ generated by $\leq$ on $S$ and its point-wise
extension to strings in $S^*$. 
%For any sort $s\in S$, 
The expression
$\tops{s}$ denotes the connected component of $s$, that is, $\tops{s}
= \tops{s}_{\equiv_\leq}$.  
A {\em top sort} in $\Sigma$ is a sort $s
\in S$ such that for all $s' \in [s]$, $s' \leq s$.  

For $X =
\{X_s\}_{s\in S}$ an $S$-indexed family of disjoint variable sets with
each $X_s$ countably infinite, the {\em set of terms of sort $s$} and
the {\em set of ground terms of sort $s$} are denoted, respectively,
by $T_\Sigma(X)_s$ and $T_{\Sigma,s}$; similarly, $T_\Sigma(X)$ and
$T_\Sigma$ denote, respectively, the set of terms and the set of
ground terms. 

A {\em substitution} is an $S$-indexed mapping
$\func{\theta}{X}{T_\Sigma(X)}$ that is different from the identity
only for a finite subset of $X$, and such that $\theta(x) \in
T_\Sigma(X)_s$ if $x \in X_s$, for any $x \in X$ and $s\in S$. 
%
%A substitution $\theta$ is called {\em ground} if and only if $\ran{\theta} = \emptyset$.  
A substitution $\theta$ is called {\em ground} if and only if $\theta(x) \in T_\Sigma$ or $\theta(x) = x$ for any $x \in X$.
%
The application of a substitution
$\theta$ to a term $t$ is denoted by $\theta t$ and the composition
(in diagrammatic order) 
of two substitutions $\theta_1$ and $\theta_2$
is denoted by $\theta_1\theta_2$,
so that $ \theta_1\theta_2 t$
denotes $\theta_1(\theta_2 t)$.

A \emph{rewrite theory} is a tuple $\rcal = (\Sigma, E \uplus B, R)$
with: (i) $(\Sigma, E \uplus B)$ an order-sorted equational theory
with signature $\Sigma$, $E$ a set of equations over $T_\Sigma$, 
and
$B$ a set of structural axioms -- disjoint from the set of equations
$E$ -- over $T_\Sigma$ 
for which there is a finitary matching
algorithm (e.g., associativity, commutativity, and identity, or
combinations of them); and (ii) $R$ a finite set of rewrite rules over $T_\Sigma$.

 Intuitively, $\rcal$ specifies a concurrent system whose
states are elements of the set $T_{\Sigma/E\uplus B}$ of
$\Sigma$-terms modulo $E \uplus B$ and whose concurrent transitions
are axiomatized by the %rewrite 
rules $R$ according to the inference
rules of rewriting logic~\cite{bruni-semantics-2006}.  In particular,
for $t,u \in T_\Sigma$ representing states of the concurrent system
described by $\rcal$, a transition from $t$ to $u$ is captured by a
formula of the form $t \to_\rcal u$; the symbol $\to_\rcal$ denotes
the binary rewrite relation induced by $R$ over $T_{\Sigma/E\uplus B}$
and $\tcal_\rcal = (T_{\Sigma/E\uplus B},\rews_\rcal)$ denotes the
\emph{initial reachability model} of $\rcal$. %Moreover, 
The
expressions $\tcal_{\Sigma/E\uplus B}$ and $=_{E\uplus B}$ denote,
respectively, the \emph{initial algebra} of $(\Sigma,E\uplus B)$ and
the congruence induced by $(\Sigma,E\uplus B)$ on $\Sigma$-terms.

\begin{example}\label{ex:ch}
Consider a system with states in the top sort $\sort{Conf}$ of the
form $C_1 \parallel C_2$, with $C_1$ and $C_2$ multisets of integer
numbers.
Each state has sort $\sort{Conf}$,
an integer has sort $\sort{Int}$, and a multiset of integers has
sort $\sort{Channel}$.  Multiset union is denoted by juxtaposition,
and it is associative, commutative, and has identity $\textit{none}$
(which denotes the empty collection). Integer number addition and the
``less-than'' total order relation on integers are denoted with the
usual function symbols. 

The symbol $\stackrel{n}{=}$ represents the
``modulo $n$ congruence'' binary relation over integers (i.e., 
%given a natural number $n\geq 1$ and two integers $x,y$, the expression $x \stackrel{n}{=} y$ is 
a shorthand for $x \equiv y \mod n$).  The
system consists of the following three rewrite rules, where $I_1,I_2$
range over integers and $C_1,C_2$ over multisets of integers:
%
\begin{align*}
  I_1\;I_2\;C_1 \parallel C_2 \; \;\rews \;\;I_1 \; C_1 \parallel (I_1 + I_2 + 1)\;C_2 \quad & \textbf{if} \;\; 0 < I_1 \land 0< I_2 \land (I_1 + I_2 \stackrel{3}{=} 0) \\
  I_1\;I_2\;C_1 \parallel C_2 \;\;\rews\;\;I_1\;C_1 \parallel C_2 \quad & \textbf{if} \;\; 0 < I_1 \land 0< I_2 \land \neg(I_1 + I_2 \stackrel{3}{=} 0) \\
  I_1 \parallel I_2\;C_2 \;\;\rews\;\;\textit{none} \parallel I_2 \;C_2 \quad & \textbf{if}\;\; 0 < I_1 \land 0< I_2 \land (I_1 + I_2 \stackrel{17}{=} 0)
\end{align*}

\noindent In this system, integers move from the left channel to the
right channel.  By the first rule, an intenger $I_2$ is removed from
the left channel and the integer $I_1+I_2+1$ is added to the right
channel, for any $I_1$ and $I_2$ in the left channel, whenever $I_1$
and $I_2$ are at least 1, and $I_1+I_2$ is a multiple of 3. By the
second rule, an integer $I_2$ is removed from the left channel, for
any $I_1$ and $I_2$ in the left channel, whenever $I_1$ and $I_2$ are
at least 1, and $I_1+I_2$ is not a multiple of 3. By the third rule,
an integer $I_1$ is removed from the left channel, for any $I_1$ in
the left channel and $I_2$ in the right channel, whenever $I_1$ is the
only number in the left channel, $I_1$ and $I_2$ are at least 1, and
$I_1+I_2$ is a multiple of 17.
\end{example}

This system can be executed by rewriting in Maude as follows. Given a
rewrite rule $\crl{l}{r}{\textit{cond}}$, with $l,r \in
T_\Sigma(X)_\sort{Conf}$, %and \textit{cond} an equational condition, 
a
ground term $t \in T_{\Sigma,\sort{Conf}}$ rewrites to a ground term
$u \in T_{\Sigma,\sort{Conf}}$ (i.e., $t \rews_\rcal u$) 
%using such a rule 
if and only if there is a ground substitution $\sigma$ 
such that $t$ and $u$ are respectively substitution instances of $l$ and $r$
modulo $=_{E\uplus B}$ (i.e.,  $\sigma l =_{E \uplus B} t$ and $\sigma r =_{E \uplus B} u$), 
and the condition $\sigma \textit{cond}$ holds.
For example, 
by the first rule
and %the substitution 
$\sigma = \{I_1 \mapsto 1, I_2 \mapsto 2, C_1\mapsto 3\;4, C_2 \mapsto \textit{none}\}$,
follows $1\;2\;3\;4 \parallel \textit{none} \rews_\rcal 1\;3\;4 \parallel 4$.
% and 
%$1\;2\;3\;4 \parallel \textit{none} \rews_\rcal 2\;3\;4 \parallel 5$ 
%with the substitution $\sigma = \{I_1 \mapsto 2, I_2 \mapsto 1, C_1\mapsto 3\;4, C_2 \mapsto \textit{none}\}$. 
%There are also rewrites from $1\;2\;3\;4 \parallel \textit{none}$ with the second rule. 

By being executable in Maude, automatic state-space search
capabilities can be used, e.g., to identify potential deadlocks in
this system.  A Maude search command searches for states that are reachable
%detect \emph{any}
%$\rews_\rcal$-trace leading 
from a \emph{ground} initial state 
and match the search pattern and satisfy the search condition.
%to a state that can not be further rewritten and that is not an expected
%final state. In this example, only states with an empty left channel
%are expected final states. 
Starting from the initial state $1\;2\;3\;4
\parallel \textit{none}$, the following search command checks if there
is a deadlock state with a nonempty left channel that can not be further rewritten (and this command finds no solution):
%
\begin{maude}
search [1]   1 2 3 4 || none   =>!   C1 || C2   such that C1 =/= none .
\end{maude}
%
In this command, %label 
\verb|[1]| %is used to 
specifies the maximum
number (in this case, $1$) of solutions that the command should return,
and \verb|=>!| means 
that only non-reducible states with respect to $\rews_\rcal$ are to be considered as
solutions to the query. 
%This command finds no solution.
%meaning that all final states are as expected.



\subsection{Rewriting Modulo SMT}
\label{sec:rw-smt}

Rewriting modulo SMT is illustrated using 
%The next step is to consider 
a symbolic version of %the above system
Example~\ref{ex:ch}.
%based on rewriting modulo SMT. 
In this version, 
a symbolic state is given by a
\emph{constrained term} $\pair{t}{\phi}$, with $t \in
T_\Sigma(X_\lang)_\sort{Conf}$ and $\phi \in
\oqff{\Sigma_\lang}{X_\lang}$,
 where $X_\lang \subseteq X$ denotes the
set of variables ranging over the built-ins, 
$\Sigma_\lang \subseteq
\Sigma$ denotes the signature of the built-in sorts, 
and
$\oqff{\Sigma_\lang}{X_\lang}$ denotes the set of quantifier-free formulas
over $\Sigma_\lang$ with variables in $X_\lang$. 

\begin{example}
In the symbolic version of the system,
the built-in sorts are
$\sort{Bool}$ and $\sort{Int}$, and the non-built-in sorts are
$\sort{Channel}$ and $\sort{Conf}$. 
%
There are
% The symbolic version
%of the system consists of 
three %topmost 
rewrite rules
with  variables
$I_1,I_2$ of sort $\sort{Int}$, 
variables $C_1,C_2$ of sort $\sort{Channel}$, and
$\phi_1,\phi_2$ of sort $\sort{Bool}$:
%
\begin{align*}
  &\pair{I_1\;I_2\;C_1 \parallel C_2}{\phi_1} \;\rews\;\pair{I_1 \; C_1 \parallel (I_1 + I_2 + 1)\;C_2}{\phi_1 \land \phi_2} 
  \\[-0.2em]
  &\qquad\qquad\qquad\qquad \textbf{if} \quad \phi_2 := 0 < I_1 \;\land\; 0< I_2 \;\land\; (I_1 + I_2 \stackrel{3}{=} 0) \; \land \; \textit{sat}(\phi_1 \land \phi_2) 
\\[1ex]
  &\pair{I_1\;I_2\;C_1 \parallel C_2}{\phi_1}\;\rews \;\pair{I_1\;C_1 \parallel C_2}{\phi_1\land\phi_2} 
  \\[-0.2em]
  &\qquad\qquad\qquad\qquad\textbf{if} \quad \phi_2 := 0 < I_1 \;\land\; 0< I_2 \;\land\; \neg(I_1 + I_2 \stackrel{3}{=} 0) \; \land \; \textit{sat}(\phi_1 \land \phi_2) 
\\[1ex]
  &\pair{I_1 \parallel I_2\;C_2}{\phi_1}\;\rews\;\pair{\textit{none} \parallel I_2 \;C_2}{\phi_2} 
  \\[-0.2em]
  &\qquad\qquad\qquad\qquad \textbf{if} \quad  \phi_2 := 0 < I_1 \;\land\; 0< I_2 \;\land\; (I_1 + I_2 \stackrel{17}{=} 0) \; \land\; \textit{sat}(\phi_1 \land \phi_2)
\end{align*}
%
These %three 
rules are similar to the ones %presented before. 
in Example~\ref{ex:ch}.
The key observation in this version is that conditions are
treated as constraints, accumulated in the system state, and queried
for satisfiability with the help of the function $\textit{sat}$ (an
interface to the SMT-solver 
to check whether $\phi$ is satisfiable or not).
%that evaluates to $\true$ on a formula
%$\phi$ if it is satisfiable and evaluates to $\false$ otherwise).  
A
\textit{matching condition}~\cite{clavel-maudebook-2007} of the form
$t := u$ is a syntactic variant of the equational condition $t = u$
mathematically interpreted as an ordinary equation. Operationally, a
matching condition behaves like a `let' construct in functional
programming languages so that $t := u$ introduces $t$ in the rule as
the result of reducing $u$ to canonical form with the oriented
equations modulo the axioms.
\end{example}

%In general, 
\begin{definition}
Given a rewrite rule
$\crl{\pair{l}{\phi_l}}{\pair{r}{\phi_r}}{\phi}$, with $l,r \in
T_\Sigma(X)_\sort{Conf}$ and $\phi \in \oqff{\Sigma_\lang}{X_\lang}$,
a constrained term $\pair{t}{\phi_t} \in
T_\Sigma(X_\lang)_\sort{Conf}\times \oqff{\Sigma_\lang}{X_\lang}$
symbolically rewrites to a constrained term $\pair{u}{\phi_u}\in
T_\Sigma(X_\lang)_\sort{Conf}\times \oqff{\Sigma_\lang}{X_\lang}$
(denoted by $\pair{t}{\phi_t}\srews_\rcal \pair{u}{\phi_u}$) 
%using such a rule 
if and only if there is a substitution $\theta$  such that:
%
\begin{enumerate}[(a)]
	\item $\theta l =_{E \uplus B} t$ and $\theta r =_{E \uplus B} u$,
	\item $\tcal_{\Sigma/E \uplus B} \models (\phi_l \land \theta \phi) \Leftrightarrow \phi_u$,
	and
	\item  $\phi_u$ is $\tcal_{\Sigma/E \uplus  B}$-satisfiable.
\end{enumerate}
\end{definition}

\noindent
The symbolic relation $\srews_\rcal$ is defined as
a topmost rewrite relation,
where all rewrites take place at the top of the term,
 induced by $R$ modulo $E\uplus B$ on
$T_\Sigma(X_\lang)$ with extra bookkeeping of constraints.


Condition (a) can be solved by matching as in the definition of
$\rews_\rcal$ above. Condition (b) can be met by setting $\phi_u$ to
be $\phi_l \land \theta \phi$, as in the above matching
conditions. 
However, Condition (c) cannot --~in general~-- be dealt
with by rewriting. The reason is that such a condition can be an
inductive theorem of $\tcal_{\Sigma /E \uplus B}$. Instead, these
conditions are checked with the help of decision procedures available
from an SMT solver via the function $\textit{sat}$. Observe that, up
to the choice of the semantically equivalent $\varphi_u$ for which a
fixed strategy such as the one suggested above can be assumed, the
symbolic relation $\srews_\rcal$ is deterministic in the sense of
being determined by the rule and the substitution $\theta$ (here it is
assumed that variables in the rules are disjoint from the ones in the
target terms). The reader is referred to~\cite{rocha-rewsmtjlamp-2017}
for details about rewriting modulo SMT.

\begin{example}
%As an example, 
Consider the constrained term $\pair{A\;B\;C\;D \parallel \textit{none}}{\textit{true}}$,
with four variables $A,B,C,D \in X_{\sort{Int}}$. 
Notice that $\pair{A\;B\;C\;D \parallel
  \textit{none}}{\textit{true}}$ symbolically rewrites in one step to
$(A\;C\;D \parallel A + B + 1 ; 0 < A \land 0 < B \land (A + B
\stackrel{3}{=} 0))$.
\end{example}

Rewriting modulo SMT can be used %as a mechanism 
for solving {%\em
  existential} reachability goals in the initial model $\tcal_\rcal$
of a rewrite theory $\rcal$ modulo built-ins $\ecal_\lang$. In
general, for any constrained term $\pair{t}{\phi}$ where $t$ is a
state term with sort $\sort{Conf}$ and $\phi$ is a constraint,
$\den{t}{\phi}$ is the \emph{denotation} of $\pair{t}{\phi}$
consisting of all ground instances of $t$ that satisfy $\phi$;
formally $\den{t}{\phi} = \left\{t' \in T_{\Sigma,\sort{Conf}} \mid \;
(\exists \func{\sigma}{X}{T_\Sigma})\, t' = \sigma t \land
\tcal_{\Sigma/E\uplus B} \models \sigma\phi \right\}$.  The type of
\emph{existential reachability} question that rewriting modulo SMT can
solve can now be formulated: are there some states in $\den{t}{\phi}$
from which is possible to reach some state in $\den{u}{\psi}$?
Answering this question can be especially useful for symbolically
proving or disproving safety properties of $\rcal$, such as
%for instance
 inductive invariants or deadlock freedom of $\tcal_\rcal$:
when $\den{u}{\psi}$ is a set of \emph{bad} states, the idea is to
know whether reaching a state in $\den{u}{\psi}$ is possible.

Consider the following existential query,
where  $\rcal$ is the rewrite theory presented 
in Example~\ref{ex:ch} (i.e., the one without symbolic constraints):
%
\begin{align*}
  \tcal_\rcal \models \left(\exists \,I,C_1,C_2 \right) \; & \,I \, (I+1) \, (I+2) \, (I+3) \parallel \textit{none} \;\rews_\rcal^*\;C_1 \parallel C_2 \,\land\, I> 0 \\ & \land \, C_1 \neq \textit{none} \, \land \,  \textit{``$C_1 \parallel C_2$ is $\rews_\rcal$-irreducible''}.
\end{align*}
%
This query asks if it is possible to find an initial state consisting
of four consecutive positive integers in the left channel and no
number on the right channel that leads to an irreducible state where
there are still numbers in the left channel.
%
This is the same type of
deadlock freedom property discussed before, namely, the one in which
bad states are those irreducible ones in which the channel has at least one number. 

Answering this query in the negative proves that
$\rcal$ is deadlock free for any initial state satisfying the initial
pattern. Since $I$ ranges over an infinite domain, this question
cannot be solved directly via rewriting and would require, e.g.,
inductive reasoning over $\rews_\rcal$. 
However, the following Maude
\textit{search} command can be issued in Maude to find a proof (or a
counterexample) for the symbolic rewrite relation $\srews_\rcal$:
%
\begin{maude}
search [1] { I  I+1 I+2 I+3 || none , I > 0 }
       =>! { C1 || C2, Phi } such that C1 =/= none .
\end{maude}
%
Executed as it is, this command times out after 5 minutes.
%without finding a witness nor proving its nonexistence. 
As shown in
the next section, with the help of guarded terms, the exact same
search command terminates in less than 1 second without finding a
witness, therefore proving the deadlock freedom of $\tcal_\rcal$ from
states satisfying the pattern $I \; (I+1) \; (I+2) \; (I+3) \parallel
\textit{none}$.
