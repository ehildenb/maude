load ../../../contrib/tools/itp/itp-tool.maude
load ../../../contrib/systems/data-structures/list.maude

select ITP-TOOL .
loop init-itp .

--- English: 
--- Appending lists is associative

--- ITP:
(goal list-append-assoc : LIST-ITP
    |- A{L1:List? ; L2:List? ; L3:List?}
((((L1:List?): List) & ((L2:List?): List) & ((L3:List?): List))
 => ((append(L1:List?, append(L2:List?, L3:List?)))
      = (append(append(L1:List?, L2:List?), L3:List?)))) .)

---------
--- goal: list-append-assoc
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

select ITP-TOOL .
loop init-itp .

---ooo English:
--- If we append to a list L the empty list, we always obtain the same list L.

--- ITP:
(goal append-nil : LIST-ITP
    |- A{L:List?}(((L:List?): List) => (append(L:List?, nil)) = (L:List?)) .)

---------
--- goal: list-append-nil
---------
(ind on L:List? .)
--- base case
(auto .)
--- inductive case
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: 
--- If we append two lists, we always obtain a list
--- ITP
(goal list-append : LIST-ITP
   |- A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
       => ((append(L1:List?, L2:List?)): List)) .)
(ind* on L1:List? .)

select ITP-TOOL .
loop init-itp .

--- English:
--- If an element is a member of a list L1, 
--- then it is also a member of the list that results of appending a list L2 to the list L1.

--- ITP: 
(goal list-member-append-left : 
      LIST-ITP |- A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L1:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

---------
--- goal: list-member-append-left
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- English:
--- If an element is a member of a list L2, 
--- then it is also a member of the list that results of appending the list L2 to a list L1.

--- ITP:
(goal list-member-append-right : 
      LIST-ITP |- A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L2:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

---------
--- goal: list-member-append-right 
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: if an integer is a member of a list L, then it is also
--- a member of the reverse of L.

(goal list-member-reverse : 
      LIST-ITP |- A{N:Int? ; L:List?}
      ((((N:Int?): Int) & ((L:List?): List) & ((isMember(N:Int?, L:List?)) = (true)))
                => ((isMember(N:Int?, reverse(L:List?))) = (true))) .)

-----------
---- lemma: append
-----------
(lem append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: list-member-append-left 
----------
(lem list-member-append-left : 
     A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L1:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

----------
--- lemma: list-member-append-right  
----------
(lem list-member-append-right : 
     A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L2:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)


----------
--- lemma: reverse 
----------
(lem reverse : 
   A{L1:List?}(((L1:List?): List) => ((reverse(L1:List?)): List)) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)


---------
--- goal: list-member-reverse
---------
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: 
--- If we reverse the list that results from appending a list L2 to a list L1, 
--- we obtain the same list that the list that results after appending the reverse 
--- of L1 to the reverse of L2.

--- ITP :
(goal reverse-append : 
   LIST-ITP |- A{L1:List? ; L2:List?}
((((L1:List?): List) & ((L2:List?): List))
=>           
((reverse(append(L1:List?, L2:List?))) 
             = (append(reverse(L2:List?), reverse(L1:List?))))) .)

----------
--- lemma: append
----------
(lem append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: append-nil
----------
(lem append-nil :
   A{L:List?}(((L:List?): List) => (append(L:List?, nil)) = (L:List?)) .)
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: append-assoc
----------
(lem append-assoc : 
 A{L1:List? ; L2:List? ; L3:List?}
((((L1:List?): List) & ((L2:List?): List) & ((L3:List?): List))
 => ((append(L1:List?, append(L2:List?, L3:List?)))
      = (append(append(L1:List?, L2:List?), L3:List?)))) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: reverse
----------
(lem reverse :
A{L1:List?}
  (((L1:List?): List) => ((reverse(L1:List?)): List)) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

---------
--- goal: reverse-append
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: If we reverse the reverse of a list L, we obtain the same list L.

--- Goal:
(goal rev :
    LIST-ITP |- A{L:List?}(((L:List?): List) => ((reverse(reverse(L:List?))) = (L:List?))) .)

----------
--- lemma: list-append-nil
----------
(lem list-append-nil : 
   A{L:List?}(((L:List?): List) => (append(L:List?, nil)) = (L:List?)) .)
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: list-append-assoc
----------
(lem list-append-assoc : 
   A{L1:List? ; L2:List? ; L3:List?}
((((L1:List?): List) & ((L2:List?): List) & ((L3:List?): List))
 => ((append(L1:List?, append(L2:List?, L3:List?)))
      = (append(append(L1:List?, L2:List?), L3:List?)))) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: list-append
----------
(lem list-append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: list-reverse
----------
(lem reverse :
A{L1:List?}
  (((L1:List?): List) => ((reverse(L1:List?)): List)) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: reverse-append
----------
(lem list-reverse-append : 
     A{L1:List? ; L2:List?}
      ((((L1:List?): List) & ((L2:List?): List)) 
           => ((reverse(append(L1:List?, L2:List?))) 
             = (append(reverse(L2:List?), reverse(L1:List?))))) .)
(ind on  L1:List? .) 
--- base case:
(auto .)
--- inductive case:
(auto .)

---------
--- goal: list-reverse-reverse
---------
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: 
--- If we reverse a lists, we always obtain a list.

--- ITP: 
(goal list-reverse :
    LIST-ITP |- A{L1:List?}
  (((L1:List?): List) => ((reverse(L1:List?)): List)) .)

----------
--- lemma: list-append:
----------
(lem list-append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

---------
--- goal: list-reverse
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
