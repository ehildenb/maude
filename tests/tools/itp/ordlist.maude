load ../../../contrib/tools/itp/itp-tool.maude
load ../../../contrib/systems/data-structures/ordlist.maude

select ITP-TOOL .
loop init-itp .

--- English: 
--- Appending lists is associative

--- ITP:
(goal ordlist-append-assoc : 
   ORDLIST |- A{L1:List? ; L2:List? ; L3:List?}
((((L1:List?): List) & ((L2:List?): List) & ((L3:List?): List))
 => ((append(L1:List?, append(L2:List?, L3:List?)))
      = (append(append(L1:List?, L2:List?), L3:List?)))) .)

---------
--- goal: list-append-assoc
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

select ITP-TOOL .
loop init-itp .

---ooo English:
--- If we append to a list L the empty list, we always obtain the same list L.

--- ITP:
(goal append-nil : 
   ORDLIST |- A{L:List?}(((L:List?): List) => (append(L:List?, nil)) = (L:List?)) .)

---------
--- goal: list-append-nil
---------
(ind on L:List? .)
--- base case
(auto .)
--- inductive case
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: 
--- If we append two lists, we always obtain a list

--- ITP
(goal list-append : ORDLIST
   |- A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
       => ((append(L1:List?, L2:List?)): List)) .)

---------
--- goal: list-append
---------
(ind on L1:List? .)
(auto .)
(auto .)

select ITP-TOOL .
loop init-itp .

--- English:
--- deleting an element in a ordered lists with
--- returns always an ordered lists.

--- ITP:
(goal ordlist-delete : 
    ORDLIST |- 
      A{E:Int? ; L:List?}
        ((((E:Int?): Int) & ((L:List?): OrdList))
       => ((delete(E:Int?, L:List?)): OrdList)) .)

----------
--- lemma: ordlist-list-delete: 
----------
(lem ordlist-list-delete : A{E:Int? ; L:List?}
     ((((E:Int?): Int) &  ((L:List?): List))
   => ((delete(E:Int?, L:List?)): List)) .)

(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (E*Int? > V0#0*Int?) .)
--- --- case true 
(auto .)
--- --- case false
(auto .)
(split on (E*Int? < V0#0*Int?) .)
--- --- --- case true 
(auto .)
--- --- --- case false
(auto .)

----------
--- lemma: ordlist-delete-aux
----------
(lem ordlist-delete-aux : A{E1:Int? ; E2:Int? ; L:List?}
     ((((E1:Int?): Int) & ((E2:Int?): Int) &  ((L:List?): List) &
       ((E1:Int? : L:List?): OrdList))
   => ((E1:Int? : delete(E2:Int?, L:List?)): OrdList)) .)

---(

(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (E2*Int? < V0#0*Int?) .)
--- --- case (E2*Int? < V0#0*Int?) = true
(auto .)
(ctor-term-split on (E1*Int? : V0#0*Int? : V0#1*List?) OrdList .)
(auto .)
--- --- case (E2*Int? < V0#0*Int?) = false 
(auto .)
(split on (E2*Int? > V0#0*Int?) .)
--- --- --- case (E2*Int? > V0#0*Int?) = true
(auto .)
(ctor-term-split on (E1*Int? : V0#0*Int? : V0#1*List?) OrdList .)
(auto .)
--- --- --- case (E2*Int? > V0#0*Int?) = false 
(auto .)
(ctor-split on V0#1*List? List .)
--- --- --- --- case V0#1*List? = nil 
(auto .)
--- --- --- --- case V0#1*List? = V1#0:Int? : V1#1:List?
(auto .)
(ctor-term-split on (E1*Int? : V0#0*Int? : V1#0*Int? : V1#1*List?) OrdList .)
(auto .)
(ctor-term-split on (V0#0*Int? : V1#0*Int? : V1#1*List?) OrdList .)
(auto .)

---------
--- goal: ordlist-delete
---------
(ind on L:List? .)
--- --- base cases:
--- --- 1. empty list
(auto .)
--- --- 2. unary list
(auto .)
(split on (E*Int? > V0#0*Int?) .)
--- --- ---  E*Int? > V0#0*Int? = true 
(auto .)
--- --- ---  E*Int? > V0#0*Int? = false 
(split on (E*Int? < V0#0*Int?) .)
--- --- ---  --- E*Int? < V0#0*Int? = true 
(auto .)
--- --- ---  --- E*Int? < V0#0*Int? = false 
(auto .)
--- ---  inductive case:
(auto .)
(split on (E*Int? > V0#0*Int?) .)
--- ---  --- case E*Int? > V0#0*Int? = true
(auto .) 
--- ---  --- case E*Int? > V0#0*Int? = false
(auto .)
(split on (E*Int? < V0#0*Int?) .)
--- --- ---  --- E*Int? < V0#0*Int? = true 
(auto .)
--- --- ---  --- E*Int? < V0#0*Int? = false
(auto .)
)

select ITP-TOOL .
loop init-itp .

--- English:
--- An ordered lists is a list.

--- ITP:
(goal ordlist-insert : ORDLIST |-
      A{L:List?}(((L:List?): OrdList)
         => ((L:List?): List)) .)

(auto .)
(ctor-split on (L*List?) OrdList .)
--- case L*List? = nil
(auto .)
--- case L*List? = V0#0:Int? : nil
(auto .)
--- case L*List? = V0#0:Int? : V0#1:Int? : V0#2:List?
(auto .)

select ITP-TOOL .
loop init-itp .

--- English:
--- If an element is a member of a list L1, 
--- then it is also a member of the list that results of appending a list L2 to the list L1.

--- ITP: 
(goal ordlist-member-append-left : 
      ORDLIST |- A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L1:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

---------
--- goal: list-member-append-left
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- English:
--- If an element is a member of a list L2, 
--- then it is also a member of the list that results of appending the list L2 to a list L1.

--- ITP:
(goal ordlist-member-append-right : 
      ORDLIST |- A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L2:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

---------
--- goal: list-member-append-right 
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: if an integer is a member of a list L, then it is also
--- a member of the reverse of L.

(goal ordlist-member-reverse : 
      ORDLIST |- A{N:Int? ; L:List?}
      ((((N:Int?): Int) & ((L:List?): List) & ((isMember(N:Int?, L:List?)) = (true)))
                => ((isMember(N:Int?, reverse(L:List?))) = (true))) .)

-----------
---- lemma: append
-----------
(lem ordlist-append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-member-append-left 
----------
(lem ordlist-member-append-left : 
     A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L1:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

----------
--- lemma: ordlist-member-append-right  
----------
(lem list-member-append-right : 
     A{N:Int? ; L1:List? ; L2:List?}
((((N:Int?): Int) & ((L1:List?): List) & ((isMember(N:Int?, L2:List?)) = (true)))
                => ((isMember(N:Int?, append(L1:List?, L2:List?))) = (true))) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)


----------
--- lemma: ordlist-reverse 
----------
(lem ordlist-reverse : 
   A{L1:List?}(((L1:List?): List) => ((reverse(L1:List?)): List)) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

---------
--- goal: list-member-reverse
---------
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (N*Int? < V0#0*Int?) .)
--- case N*Int? < V0#0*Int? = true
(auto .)
--- case N*Int? < V0#0*Int? = false
(auto .)
(split on (N*Int? > V0#0*Int?) .)
--- --- case N*Int? > V0#0*Int? = true
(auto .)
--- --- case N*Int? > V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- select WEBITP-TOOL .
--- loop init-webitp .

--- English:
--- insert'ing an element in a ordered lists with
--- returns always an ordered lists.

--- ITP:
(goal ordlist-ord-insert : ORDLIST |-
      A{L:List? ; I:Int?}((((L:List?): OrdList) & ((I:Int?): Int))
         => ((ord-insert(I:Int?, L:List?)): OrdList)) .)

----------
--- lemma: ordlist-list-ord-insert:
----------
(lem ordlist-list-ord-insert : A{E:Int? ; L:List?}
     ((((E:Int?): Int) &  ((L:List?): List))
   => ((ord-insert(E:Int?, L:List?)): List)) .)

(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
(split on (E*Int? > V0#0*Int?) .)
--- --- case true
(auto .)
--- --- case false
(auto .)

----------
--- lemma: ordlist-ord-insert-aux
----------
(lem ordlist-ord-insert-aux : A{E1:Int? ; E2:Int? ; L:List?}
     ((((E1:Int?): Int) & ((E2:Int?): Int) & ((L:List?): List) &
       ((E1:Int? <= E2:Int?) = (true))
        & ((E1:Int? : L:List?): OrdList))
   => ((E1:Int? : ord-insert(E2:Int?, L:List?)): OrdList)) .)

(ind on L:List? .)
--- base cases:
---
(auto .)
--- inductive case:
(auto .)
(split on (E2*Int? <= V0#0*Int?) .)
--- case true
(auto .)
(ctor-term-split on (E1*Int? : V0#0*Int? : V0#1*List?) OrdList .)
(auto .)
--- case false
(auto .)
(ctor-term-split on (E1*Int? : V0#0*Int? : V0#1*List?) OrdList .)
(auto .)

---------
--- goal: ordlist-ord-insert
---------
(ind on L:List? .)
--- base cases:
--- 1. empty lists
(auto .)
--- 2. unary lists
(auto .)
(split on (I*Int? <= V0#0*Int?) .)
--- case I* Int? <= V0#0*Int? = true
(auto .)
--- case I* Int? <= V0#0*Int? = false
(auto .)
--- inductive case:
(auto .)
(split on (I*Int? <= V0#0*Int?) .)
--- case I*Int? <= V0#0*Int? = true
(auto .)
--- case I*Int? <= V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- English:
--- if L is an ordered lists, then
--- checking with ord-isMember
--- whether an element is in L gives
--- the same result than checking it 
--- with isMember.

--- ITP:
(goal ordlist-ord-isMember : ORDLIST |-
      A{L:List? ; I:Int?}((((L:List?): OrdList) & ((I:Int?): Int)) 
         => ((ord-isMember(I:Int?, L:List?)) = (isMember(I:Int?, L:List?)))) .)

----------
--- lemma:
----------
(lem ordlist-isMember :
   A{L:List? ; I1:Int? ; I2:Int?}((((L:List?): List) & ((I1:Int?): Int) & ((I2:Int?): Int)
            & ((I1:Int? < I2:Int?) = (true)) & ((I2:Int? :  L:List?): OrdList))
         => ((isMember(I1:Int?, (I2:Int? : L:List?))) = (false))) .)

(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
---
(ctor-term-split on (I2*Int? : V0#0*Int? : V0#1*List?) OrdList .)
(auto .)

---------
--- goal: ordlist-ord-isMember
---------

(ind on L:List? .)
--- base cases:
--- --- 1. empty lists
(auto .)
--- --- 2. unary lists
(auto .)
(split on (I*Int? < V0#0*Int?) .)
--- --- --- case I*Int? < V0#0*Int? = true
(auto .)
--- --- --- case I*Int? < V0#0*Int? = false
(auto .)
(split on (I*Int? > V0#0*Int?) .)
--- --- --- case I*Int? > V0#0*Int? = true
(auto .)
--- --- --- case I*Int? > V0#0*Int? = false
(auto .)
--- inductive case:
(auto .)
(split on (I*Int? < V0#0*Int?) .)
--- --- case I*Int? < V0#0*Int? = true
(auto .)
--- --- case I*Int? < V0#0*Int? = false
(auto .)
(split on (I*Int? > V0#0*Int?) .)
--- --- --- case I*Int? > V0#0*Int? = true
(auto .)
--- --- --- case I*Int? > V0#0*Int? = false
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: 
--- If we reverse the list that results from appending a list L2 to a list L1, 
--- we obtain the same list that the list that results after appending the reverse 
--- of L1 to the reverse of L2.

--- ITP :
(goal ordlist-reverse-append : 
   ORDLIST |- A{L1:List? ; L2:List?}
((((L1:List?): List) & ((L2:List?): List))
=>           
((reverse(append(L1:List?, L2:List?))) 
             = (append(reverse(L2:List?), reverse(L1:List?))))) .)

----------
--- lemma: ordlist-append
----------
(lem ordlist-append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-append-nil
----------
(lem ordlist-append-nil :
   A{L:List?}(((L:List?): List) => (append(L:List?, nil)) = (L:List?)) .)
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-append-assoc
----------
(lem ordlist-append-assoc : 
 A{L1:List? ; L2:List? ; L3:List?}
((((L1:List?): List) & ((L2:List?): List) & ((L3:List?): List))
 => ((append(L1:List?, append(L2:List?, L3:List?)))
      = (append(append(L1:List?, L2:List?), L3:List?)))) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-reverse
----------
(lem ordlist-reverse :
A{L1:List?}
  (((L1:List?): List) => ((reverse(L1:List?)): List)) .)

(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

---------
--- goal: ordlist-reverse-append
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: If we reverse the reverse of a list L, we obtain the same list L.

--- Goal:
(goal ordlist-reverse :
    ORDLIST |- A{L:List?}(((L:List?): List) => ((reverse(reverse(L:List?))) = (L:List?))) .)

----------
--- lemma: ordlist-append-nil
----------
(lem ordlist-append-nil : 
   A{L:List?}(((L:List?): List) => (append(L:List?, nil)) = (L:List?)) .)
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-append-assoc
----------
(lem ordlist-append-assoc : 
   A{L1:List? ; L2:List? ; L3:List?}
((((L1:List?): List) & ((L2:List?): List) & ((L3:List?): List))
 => ((append(L1:List?, append(L2:List?, L3:List?)))
      = (append(append(L1:List?, L2:List?), L3:List?)))) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-append
----------
(lem ordlist-append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-reverse
----------
(lem ordlist-reverse-is-list :
  A{L1:List?} (((L1:List?): List) => ((reverse(L1:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

----------
--- lemma: ordlist-reverse-append
----------
(lem ordlist-reverse-append : 
     A{L1:List? ; L2:List?}
      ((((L1:List?): List) & ((L2:List?): List)) 
           => ((reverse(append(L1:List?, L2:List?))) 
             = (append(reverse(L2:List?), reverse(L1:List?))))) .)
(ind on  L1:List? .) 
--- base case:
(auto .)
--- inductive case:
(auto .)

---------
--- goal: ordlist-reverse-reverse
---------
(ind on L:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

select ITP-TOOL .
loop init-itp .

--- English: 
--- If we reverse a lists, we always obtain a list.

--- ITP: 
(goal ordlist-reverse :
    ORDLIST |- A{L1:List?}
  (((L1:List?): List) => ((reverse(L1:List?)): List)) .)

----------
--- lemma: ordlist-append:
----------
(lem ordlist-append : 
   A{L1:List? ; L2:List?}((((L1:List?): List) & ((L2:List?): List))
      => ((append(L1:List?, L2:List?)): List)) .)
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)

---------
--- goal: ordlist-reverse
---------
(ind on L1:List? .)
--- base case:
(auto .)
--- inductive case:
(auto .)
