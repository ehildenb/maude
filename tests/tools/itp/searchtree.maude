load ../../../contrib/tools/itp/itp-tool.maude
load ../../../contrib/systems/data-structures/searchtree.maude

select ITP-TOOL .
loop init-itp .

(goal insert-searchtree : SEARCHTREE |- A{I:Int? ; ST:STree?}
      ((((I:Int?): Int) & ((ST:STree?): STree))
            => ((insert(ST:STree?, I:Int?)): NeSTree)) .)

-------------------------------------
--- lemma nonempty-insert
-------------------------------------
(lem nonempty-insert : A{I:Int? ; L:STree?}
     ((((I:Int?) : Int) & ((L:STree?) : Tree))
     =>
      ((insert(L:STree?, I:Int?)) : NeTree)) .)

(ind on L:STree? .)
----------
--- case 1
----------
(auto .)
----------
--- case 2
----------
(auto .)
(split on (V0#2*Int? < I*Int?) .)
(auto .)
(auto .)
(split on (V0#2*Int? > I*Int?) .)
(auto .)
(auto .)

-------------------------------------
--- lemma stree-is-tree
-------------------------------------
(lem stree-is-tree : A{L:STree?}
     (((L:STree?) : STree)
      =>
      ((L:STree?) : Tree)) .)

(ind on L:STree? .)
(auto .)
(auto .)
(auto .)
(auto .)
(auto .)

-------------------------------------
--- lemma nestree-is-netree
-------------------------------------
(lem stree-is-tree : A{L:STree?}
     (((L:STree?) : NeSTree)
      =>
      ((L:STree?) : NeTree)) .)

(ind on L:STree? .)
(auto .)
(auto .)
(auto .)
(auto .)

-------------------------------------
--- lemma max-insert
-------------------------------------
(lem max-insert : A{I:Int? ; I':Int? ; L:STree?}
     ((((I:Int?): Int) & ((I':Int?): Int) & ((L:STree?): NeSTree) & 
      ((max(L:STree?) < I:Int?)= (true)) & ((I:Int? > I':Int?)= (true)))
      => 
      ((max(insert(L:STree?, I':Int?)) < I:Int?) = (true))) .)

(ind on L:STree? .)
----------
--- case 1
----------
(auto .)
(split on (V0#0*Int? < I'*Int?) .)
--- case V0#0*Int? < I'*Int? = true 
(auto .)
--- case V0#0*Int? < I'*Int? = false 
(auto .)
(split on (V0#0*Int? > I'*Int?) .)
--- case V0#0*Int? > I'*Int? = true 
(auto .)
--- case V0#0*Int? > I'*Int? = false [=>  V0#0*Int? = I'*Int?] 
(auto .)
----------
--- case 2
----------
(auto .)
(split on (V0#0*Int? < I'*Int?) .)
--- case V0#0*Int? < I'*Int? = true 
(auto .)
--- case V0#0*Int? < I'*Int? = false 
(auto .)
(split on (V0#0*Int? > I'*Int?) .)
--- ---  case V0#0*Int? > I'*Int? = true 
(auto .)
--- ---  case V0#0*Int? > I'*Int? = false [=>  V0#0*Int? = I'*Int?]
(auto .)

----------
--- case 3
----------
(auto .)
(split on (V0#1*Int? < I'*Int?) .)
--- case V0#1*Int? < I'*Int? = true 
(auto .)
--- case V0#1*Int? < I'*Int? = false 
(auto .)
(split on (V0#1*Int? > I'*Int?) .)
--- ---  case V0#1*Int? > I'*Int? = true 
(auto .)
--- ---  case V0#1*Int? > I'*Int? = false [=>  V0#1*Int? = I'*Int?]
(auto .)

----------
--- case 4
---------- 
(auto .)
(split on (V0#1*Int? < I'*Int?) .)
--- case V0#1*Int? < I'*Int? = true 
(auto .)
--- case V0#1*Int? < I'*Int? = false 
(auto .)
(split on (V0#1*Int? > I'*Int?) .)
--- ---  case V0#1*Int? > I'*Int? = true 
(auto .)
--- ---  case V0#1*Int? > I'*Int? = false [=>  V0#1*Int? = I'*Int?]
(auto .)

-------------------------------------
--- lemma min-insert
-------------------------------------
(lem min-insert : A{I:Int? ; I':Int? ; L:STree?}
     ((((I:Int?): Int) & ((I':Int?): Int) & ((L:STree?): NeSTree) & 
      ((I:Int? < min(L:STree?))= (true)) & ((I:Int? < I':Int?)= (true)))
      => 
      ((I:Int? < min(insert(L:STree?, I':Int?))) = (true))) .)


(ind on L:STree? .)
----------
--- case 1
----------
(auto .)
(split on (V0#0*Int? < I'*Int?) .)
--- case V0#0*Int? < I'*Int? = true 
(auto .)
--- case V0#0*Int? < I'*Int? = false 
(auto .)
(split on (V0#0*Int? > I'*Int?) .)
--- case V0#0*Int? > I'*Int? = true 
(auto .)
--- case V0#0*Int? > I'*Int? = false [=>  V0#0*Int? = I'*Int?] 
(auto .)
----------
--- case 2
----------
(auto .)
(split on (V0#0*Int? < I'*Int?) .)
--- case V0#0*Int? < I'*Int? = true 
(auto .)
--- case V0#0*Int? < I'*Int? = false 
(auto .)
(split on (V0#0*Int? > I'*Int?) .)
--- ---  case V0#0*Int? > I'*Int? = true 
(auto .)
--- ---  case V0#0*Int? > I'*Int? = false [=>  V0#0*Int? = I'*Int?]
(auto .)

----------
--- case 3
----------
(auto .)
(split on (V0#1*Int? < I'*Int?) .)
--- case V0#1*Int? < I'*Int? = true 
(auto .)
--- case V0#1*Int? < I'*Int? = false 
(auto .)
(split on (V0#1*Int? > I'*Int?) .)
--- ---  case V0#1*Int? > I'*Int? = true 
(auto .)
--- ---  case V0#1*Int? > I'*Int? = false [=>  V0#1*Int? = I'*Int?]
(auto .)

----------
--- case 4
---------- 
(auto .)
(split on (V0#1*Int? < I'*Int?) .)
--- case V0#1*Int? < I'*Int? = true 
(auto .)
--- case V0#1*Int? < I'*Int? = false 
(auto .)
(split on (V0#1*Int? > I'*Int?) .)
--- ---  case V0#1*Int? > I'*Int? = true 
(auto .)
--- ---  case V0#1*Int? > I'*Int? = false [=>  V0#1*Int? = I'*Int?]
(auto .)

-------------------------------------
--- main goal
-------------------------------------
(ind on ST:STree? .)
----------
--- case 1
----------
(auto .)
----------
--- case 2
---------- 
(auto .)
(split on (V0#0*Int? > I*Int?) .)
--- --- case V0#0*Int? > I*Int? = true
(auto .)
--- --- case V0#0*Int? > I*Int? = false
(auto .)
(split on (V0#0*Int? < I*Int?) .)
--- --- case V0#0*Int? < I*Int? = true
(auto .)
--- --- case V0#0*Int? < I*Int? = false [==> V0#0*Int? = I*Int?]
(auto .)
----------
--- case 3
----------
(auto .)
(split on (V0#0*Int? > I*Int?) .)
--- --- case V0#0*Int? > I*Int? = true
(auto .)
--- --- case V0#0*Int? > I*Int? = false
(auto .)
(split on (V0#0*Int? < I*Int?) .)
--- --- --- case V0#0*Int? < I*Int? = true
(auto .)
--- --- --- case V0#0*Int? < I*Int? = false [==> V0#0*Int? = I*Int?]
(auto .)
----------
--- case 4
----------
(auto .)
(split on (V0#1*Int? < I*Int?) .)
--- --- case V0#1*Int? < I*Int? = true
(auto .)
--- --- case V0#0*Int? > I*Int? = false
(auto .)
(split on (V0#1*Int? > I*Int?) .)
--- --- --- case V0#0*Int? < I*Int? = true
(auto .)
--- --- --- case V0#0*Int? < I*Int? = false [==> V0#0*Int? = I*Int?]
(auto .)
----------
--- case 5
----------
(auto .)
(split on (V0#1*Int? < I*Int?) .)
--- --- case V0#1*Int? < I*Int? = true
(auto .)
--- --- case V0#1*Int? < I*Int? = false
(auto .)
(split on (V0#1*Int? > I*Int?) .)
--- --- --- case V0#1*Int? > I*Int = true 
(auto .)
--- --- --- case V0#1*Int? > I*Int = false [==> V0#1*Int? = I*Int?]
(auto .)

select ITP-TOOL .
loop init-itp .

(goal reverse-reverse-searchtree : SEARCHTREE |- A{T:STree?}
      ((((T:STree?): Tree)) => ((reverse(reverse(T:STree?))) = (T:STree?))) .)

-------------------------------------
--- main goal
-------------------------------------

(ind on T:STree? .)
(auto .)
(auto .)

select ITP-TOOL .
loop init-itp .

(goal searchmember-reverse : SEARCHTREE |- A{I:Int? ; T:STree?}
      ((((I:Int?) : Int) & ((T:STree?) : Tree)) 
       =>
       ((isMember(I:Int?, reverse(T:STree?))) = 
        (isMember(I:Int?, T:STree?)))) .)

-------------------------------------
--- lemma ismember-bool
-------------------------------------
(lem ismember-bool : A{I:Int? ; T:STree?}
     ((((I:Int?) : Int) & ((T:STree?) : Tree))
      =>
      ((isMember(I:Int?, T:STree?)): Bool)) .)

(ind on T:STree? .)
(auto .)
(auto .)
(split on (I*Int? < V0#2*Int?) .)
(split on (isMember(I*Int?, V0#0*STree?)) .)
(auto .)
(auto .)
--- Necessary to distinguish the case I*Int? = V0#2*Int?
(split on (I*Int? > V0#2*Int?) .)
(split on (isMember(I*Int?, V0#0*STree?)) .)  --- I*Int? > V0#2*Int?
(auto .)
(auto .)
(auto .)  --- I*Int? = V0#2*Int?

-------------------------------------
--- lemma ismember-bool
-------------------------------------
(lem reverse-tree : A{T:STree?}
     ((((T:STree?) : Tree))
      =>
      ((reverse(T:STree?)): Tree)) .)

(ind on T:STree? .)
(auto .)
(auto .)

-------------------------------------
--- main goal
-------------------------------------

(ind on T:STree? .)
----------
--- case 1
---------- 
(auto .)

----------
--- case 2
----------
(auto .)
(split on (I*Int? < V0#2*Int?) .) 
(split on (isMember(I*Int?, V0#1*STree?)) .)
--- split on isMember
  (auto .)
  (split on (isMember(I*Int?, V0#0*STree?)) .)
  (auto .)
  (auto .)
--- split on isMember
  (auto .)
  (split on (isMember(I*Int?, V0#0*STree?)) .)
  (auto .)
  (auto .)
--- --- second part of the splitting of I*Int < V0#2*Int?
--- Necessary to distinguish the case I*Int? = V0#2*Int?
(split on (I*Int? > V0#2*Int?) .)
(split on (isMember(I*Int?, V0#1*STree?)) .)  --- I*Int? > V0#2*Int?
--- split on isMember
  (auto .)
  (split on (isMember(I*Int?, V0#0*STree?)) .)
  (auto .)
  (auto .)
--- split on isMember
  (auto .)
  (split on (isMember(I*Int?, V0#0*STree?)) .)
  (auto .)
  (auto .)
(auto .)  --- I*Int? = V0#2*Int?

