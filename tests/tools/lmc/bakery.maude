set show timing off .

load ../../../contrib/systems/bakery.maude
load ../../../contrib/tools/lmc/lgraph-search.maude
load ../../../contrib/tools/meta/narrowing.maude

--- Module BAKERY-NARROWING-GRAPH
--- =============================

mod BAKERY-NARROWING-GRAPH is
   protecting BAKERY .
    extending FVP-NARROWING-GRAPH + GRAPH-ANALYSIS .

    eq ##m## = upModule('BAKERY, true) .

    op upIdle : -> [Term] .
    -----------------------
    eq upIdle = upTerm([idle]) .

    op init : Nat -> [Term] .
    -------------------------
    eq init(0) = upTerm(0 ; 0 ; [idle] [idle]) .
    eq init(1) = '_;_;_['X:Name,'X:Name,'__[upIdle,upIdle]] .
    eq init(2) = '_;_;_['X:Name,'Y:Name,'__[upIdle,'PWS:ProcWaitSet]] .
    eq init(3) = '_;_;_['__['s.Name,'X:Name],'Y:Name,'__['`[_`]['crit['__['s.Name,'X:Name]]], upIdle, upIdle, 'PWS:ProcWaitSet]] .
    eq init(4) = '_;_;_['X:Name,'Y:Name,'__[upIdle,upIdle]] .
endm

--- Low-level functions
--- -------------------

--- ### ensure that init(0..4) are well formed

reduce wellFormed(##m##, init(0)) .
reduce wellFormed(##m##, init(1)) .
reduce wellFormed(##m##, init(2)) .
reduce wellFormed(##m##, init(3)) .
reduce wellFormed(##m##, init(4)) .

--- ### Function `step`

reduce step(state(init(0))) .
reduce step(state(init(1))) .
reduce step(state(init(2))) .
reduce step(state(init(3))) .

--- ### Function `fold`

reduce fold ( state('_;_;_['__['s.Name,'@1:Name],'__['s.Name,'@1:Name],'__['`[_`]['idle.ModeIdle],'`[_`]['idle.ModeIdle]]])
            , state('_;_;_['X:Name,              'Y:Name,              '__['`[_`]['idle.ModeIdle],'`[_`]['idle.ModeIdle]]])
            ) .
reduce fold(state(init(1)), state(init(2))) .
reduce fold(state(init(1)), state(init(4))) .

reduce not (fold(state(init(4)), state(init(3))) :: Fold) .

--- ### Function `bfs`

reduce bfs(state(init(0)), 0) .
reduce bfs(state(init(1)), 0) .
reduce bfs(state(init(2)), 0) .
reduce bfs(state(init(3)), 0) .

reduce bfs(state(init(0)), 2) .
reduce bfs(state(init(1)), 2) .
reduce bfs(state(init(2)), 2) .
reduce bfs(state(init(3)), 2) .

--- achieves finite state graph
reduce bfs(state(init(1))) .

reduce bfs(state(init(4)), 10) .

--- Module BAKERY-FVP-CTOR-NARROWING-GRAPH
--- ======================================

mod BAKERY-FVP-CTOR-NARROWING-GRAPH is
   protecting BAKERY-FVP-CTOR .
    extending FVP-NARROWING-GRAPH .
    extending GRAPH-ANALYSIS .

    eq ##m## = upModule('BAKERY-FVP-CTOR, true) .

    op init : Nat -> [Term] .
    -------------------------
    eq init(0) = '<_`,_`,_`,_>['sleep.NcMode ,'_+_['1.NzNat>,'1.NzNat>,'1.NzNat>],'wait.NcMode,'_+_['1.NzNat>,'1.NzNat>]] .
    eq init(1) = '<_`,_`,_`,_>['PNC:NcMode   , 'X1:Nat> , 'QC:Mode      , 'X2:Nat>] .
    eq init(2) = '<_`,_`,_`,_>['PC:Mode      , 'Y1:Nat> , 'QNC:NcMode   , 'Y2:Nat>] .
    eq init(3) = '<_`,_`,_`,_>['sleep.NcMode , 'X0:Nat> , 'sleep.NcMode , 'X0:Nat>] .
endm

***(Desired initial states and invariant:
   vars X0 X Y X' Y' : Nat .

Set of initial states:  < sleep, X0, sleep, X0 > .

  vars P Q : Mode .    vars P' Q' : NcMode .  vars

Mutex Invariant:  < P', X, Q, Y > \/ < P, X', Q', Y' > .
             or: state(init(1)) \/ state(init(2)) .
)

reduce wellFormed(##m##, init(0)) .
reduce wellFormed(##m##, init(1)) .
reduce wellFormed(##m##, init(2)) .
reduce wellFormed(##m##, init(3)) .

reduce step(state(init(0))) .
reduce step(state(init(1))) .
reduce step(state(init(2))) .
reduce step(state(init(3))) .

reduce state(init(3)) <= (state(init(1)) ; state(init(2))) .
reduce state(init(1)) <= (state(init(1)) ; state(init(2))) .
reduce state(init(2)) <= state(init(1)) .

--- both initial states yield finite state-graphs
reduce bfs(state(init(1))) .
reduce bfs(state(init(2))) .
reduce bfs(state(init(3))) .
reduce bfs(state(init(1)) ; state(init(2))) .

reduce nodes(bfs(state(init(1)))) .
reduce nodes(bfs(state(init(2)))) .
reduce nodes(bfs(state(init(3)))) .
reduce nodes(bfs(state(init(1)) ; state(init(2)))) .

reduce nodes(bfs(state(init(1)) ; state(init(2)))) <= (nodes(bfs(state(init(1)))) ; nodes(bfs(state(init(2))))) .
reduce (nodes(bfs(state(init(1)))) ; nodes(bfs(state(init(2))))) <= nodes(bfs(state(init(1)) ; state(init(2)))) .

reduce state(init(3))                                 <= (state(init(1)) ; state(init(2))) .
reduce state(init(3))                                 <= nodes(bfs(state(init(1)) ; state(init(2)))) .
reduce (state(init(1)) ; state(init(2)))              <= nodes(extend(state(init(1)) ; state(init(2)))) .
reduce (state(init(1)) ; state(init(2)))              <= nodes(bfs(state(init(1)) ; state(init(2)))) .
reduce nodes(extend(state(init(1)) ; state(init(2)))) <= nodes(bfs(state(init(1)) ; state(init(2)))) .

--- state init(3) stays within init(1) ; init(2)
reduce nodes(bfs(state(init(3)))) <= (state(init(1)) ; state(init(2))) .

--- even though in general init(1) ; init(2) is *not* an invariant
--- this is because both the counters could be zero to start, which means both `sleep => wait` rules can fire
reduce invariant(state(init(1)) ; state(init(2))) .
reduce nodes(bfs(state(init(1)) ; state(init(2)))) <= (state(init(1)) ; state(init(2))) .
reduce check state(init(3)) stable in state(init(1)) ; state(init(2)) .
