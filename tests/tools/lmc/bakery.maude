set show timing off .

load ../../../contrib/systems/bakery.maude
load ../../../contrib/tools/lmc/lgraph-search.maude

--- ### Bakery System Instatiation

fmod BAKERY-NARROWING-GRAPH-COMMON is
    including UNCONDITIONALIZE-FVP-BOOL .
    including ( CONDITIONAL-NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH ) .
    including FOLDING-LABELED-GRAPH-RENDER-TIKZ + LEXICAL .

    eq #tSort = 'Conf .
    -------------------

    vars T T' T'' : Term . var TL : TermList . var Q : Qid . var QL : QidList .
    var SUB : Substitution . vars STR STR' : String .

    op upIdle : -> [Term] .
    -----------------------
    eq upIdle = '`[_`]['idle.ModeIdle] .

    op upCrit : Term -> [Term] .
    ----------------------------
    eq upCrit(T) = '`[_`]['crit[T]] .

   ops lt le : Term Term -> [Term] .
   ---------------------------------
    eq lt(T, T') = '_?=_[ '_<_[T, T'], 'true.Bool] .
    eq le(T, T') = '_?=_['_<=_[T, T'], 'true.Bool] .

    op conf : Term Term Term -> [Term] .
    ------------------------------------
    eq conf(T, T', T'') = '_;_;_[T, T', T''] .

--- The following initial terms characterize our initialization and bad states.
---
--- -   `conf2Idle` has two idle processes.
--- -   `confManyIdle` has an arbitrary set of `idle` processes.
--- -   `confManyWait` has an arbitrary set of `wait` processes.
--- -   `confManyProc` has an arbitrary set of any processes.

    op conf2Idle    : Term Term -> [Term] .
    op confManyIdle : Term Term -> [Term] .
    op confManyWait : Term Term -> [Term] .
    op confManyProc : Term Term -> [Term] .
    ---------------------------------------
    eq conf2Idle   (T, T') = conf(T, T', '__[upIdle, upIdle]) .
    eq confManyIdle(T, T') = conf(T, T', 'PIS:ProcIdleSet)    .
    eq confManyWait(T, T') = conf(T, T', 'PWS:ProcWaitSet)    .
    eq confManyProc(T, T') = conf(T, T', 'PS:ProcSet)         .

--- -   `conf2Crit` is any constrained configuration which contains two `crit` processes.

    op conf2Crit : -> [Term] .
    --------------------------
    eq conf2Crit = #cTerm['_;_;_['N:Name, 'M:Name, '__['`[_`]['MC1:ModeCrit], '`[_`]['MC2:ModeCrit], 'PS:ProcSet]], #cTrue] .

    op stripVarTypes : QidList -> [QidList] .
    -----------------------------------------
    eq stripVarTypes(nil)  = nil .
    eq stripVarTypes(Q QL) = if (Q :: Variable) or (Q :: Constant) then getName(Q) else Q fi stripVarTypes(QL) .

    op renamingSubst : -> Substitution .
    ------------------------------------
    eq renamingSubst = '@1:Name <- 'X:Name ; '%1:Name <- 'N:Name
                     ; '@2:Name <- 'Y:Name ; '%2:Name <- 'M:Name
                     ; '@3:Name <- 'Z:Name
                     ; '@2:NzNat <- 'NzN:NzNat
                     ; '@2:ProcIdleSet <- 'PIS:ProcIdleSet
                     ; '@2:ProcWaitSet <- 'PWS2:ProcWaitSet
                     ; '@3:ProcWaitSet <- 'PWS3:ProcWaitSet .

    op renderDirect : Term -> String .
    ------------------------------------
    eq renderDirect(T) = printTokens(stripVarTypes(metaPrettyPrint(#M, T << renamingSubst))) .

    eq renderTikZLabel(label(Q , SUB)) = string(Q) .

    op renderTikZState : Term -> String .
    -------------------------------------
    eq renderTikZState(T) = "\texttt{" + renderDirect(T) + "}" .

    op renderTikZConstraint : Term -> String .
    ------------------------------------------
    eq renderTikZConstraint('_<=_[T, T']) = "\texttt{" + renderDirect(T) + "} \\le \texttt{" + renderDirect(T') + "}" .
    eq renderTikZConstraint('_<_ [T, T']) = "\texttt{" + renderDirect(T) + "} \\lt \texttt{" + renderDirect(T') + "}" .

    eq renderTikZConstraint('_?=_['true.Bool, T]) = renderTikZConstraint(T) .
    eq renderTikZConstraint('_?=_[T, 'true.Bool]) = renderTikZConstraint(T) .

   ceq renderTikZConstraint(T) = "" if T  := #cTrue .
    eq renderTikZConstraint(T) = "\texttt{" + renderDirect(T) + "}" [owise] .

   ceq renderTikZNode(state(Q[T,T'])) = "$" + renderTikZState(T) + STR' + "$"
                                     if Q := #cTerm
                                     /\ STR  := renderTikZConstraint(T')
                                     /\ STR' := if STR == "" then "" else "\\ st \\ " + STR fi .
endfm

reduce wellFormed(upModule('BAKERY, false), conf2Idle   ('X:Name, 'Y:Name)) .
reduce wellFormed(upModule('BAKERY, false), confManyIdle('X:Name, 'Y:Name)) .
reduce wellFormed(upModule('BAKERY, false), confManyWait('X:Name, 'Y:Name)) .
reduce wellFormed(upModule('BAKERY, false), confManyProc('X:Name, 'Y:Name)) .

--- ### Two Process Bakery

--- #### With Equational Abstraction

--- As a sanity check, results of section 3.1 of [@bae-escobar-meseguer-abstract-model-checking] are replicated.
--- This required an equational abstraction which reduced all the names in the configuration uniformly when they are all non-`0`.

mod BAKERY-2PROC-EQUATIONAL-ABSTRACTION is
    including BAKERY .

    vars N M K L : Name . var PIS : ProcIdleSet .

    eq s N ; s M ; [idle]      [idle]      = N ; M ; [idle]    [idle] .
    eq s N ; s M ; [wait(s K)] [idle]      = N ; M ; [wait(K)] [idle] .
    eq s N ; s M ; [crit(s K)] [idle]      = N ; M ; [crit(K)] [idle] .
    eq s N ; s M ; [wait(s K)] [wait(s L)] = N ; M ; [wait(K)] [wait(L)] .
    eq s N ; s M ; [wait(s K)] [crit(s L)] = N ; M ; [wait(K)] [crit(L)] .
    eq s N ; s M ; [crit(s K)] [crit(s L)] = N ; M ; [crit(K)] [crit(L)] .
endm

--- Here we instantiate to the abstracted theory:

mod BAKERY-2PROC-EQUATIONAL-ABSTRACTION-NARROWING-GRAPH is
    extending BAKERY-NARROWING-GRAPH-COMMON .

    eq #MO = upModule('BAKERY-2PROC-EQUATIONAL-ABSTRACTION, true) .

--- The initial state has two `idle` processes and both counters `N`:

    op conf2IdleEq : -> [Term] .
    ----------------------------
    eq conf2IdleEq = #cTerm[conf2Idle('X:Name, 'X:Name), #cTrue] .
endm

reduce wellFormed(#M) .

reduce wellFormed(#M, conf2Crit) .
reduce wellFormed(#M, conf2IdleEq) .

--- Under this assumption, a finite state graph is achieved.
--- The resulting graph differs from [@bae-escobar-meseguer-abstract-model-checking] because here states which are $=_{B}$ are identified (with $B = AC$ for the process set).
--- In addition, edges which take advantage of the equational abstraction to fold into a prior state are not identified.

reduce renderTikZGraph(0, bfs(state(conf2IdleEq)))
    == "\tikzset{elliptic state/.style={draw,ellipse}}"
       "\begin{tikzpicture}[shorten >=1pt,on grid,transform shape]"
       "\footnotesize"
       "    \node[elliptic state] (s_0) at (0,-10) {$\texttt{X ; X ; [idle] [idle]}$};"
       "    \node[elliptic state] (s_2) at (0,-14) {$\texttt{s X ; X ; [idle] [wait(X)]}$};"
       "    \node[elliptic state] (s_4) at (0,-18) {$\texttt{s X ; X ; [idle] [crit(X)]}$};"
       "    \node[elliptic state] (s_6) at (2,-17) {$\texttt{s s X ; X ; [wait(X)] [wait(s X)]}$};"
       "    \node[elliptic state] (s_10) at (0,-22) {$\texttt{s s X ; X ; [crit(X)] [wait(s X)]}$};"
       "    \\path[->] (s_10) edge [bend left=10] node [pos=0.3,right] {exit} (s_2);"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {crit} (s_10);"
       "    \\path[->] (s_4) edge [bend left=10] node [pos=0.3,right] {wake} (s_10);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {exit} (s_0);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {wake} (s_6);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {crit} (s_4);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {wake} (s_2);"
       "\\end{tikzpicture}" .

--- We can also search for a reach-path to a "bad" state in `conf2Crit`, and see that there is none:

--- **TODO**: Fix bug in this query.

reduce state(conf2IdleEq) =>* state(conf2Crit) .

--- #### With Constrained Bakery

--- Here the equational abstraction is avoided by taking advantage of constrained states.

mod BAKERY-2PROC-NARROWING-GRAPH is
    extending BAKERY-NARROWING-GRAPH-COMMON .

--- Instead we instantiate to the original theory:

    eq #MO = upModule('BAKERY, true) .
endm

reduce wellFormed(#M) .
reduce wellFormed(#M, conf2Crit) .

--- From an initial state with arbitrary counters, we are on course to have an infinite representation of the state space.

reduce renderTikZGraph(0, bfs(state(#cTerm[conf2Idle('X:Name, 'Y:Name), #cTrue]), 4))
    == "\tikzset{elliptic state/.style={draw,ellipse}}"
       "\begin{tikzpicture}[shorten >=1pt,on grid,transform shape]"
       "\footnotesize"
       "    \node[elliptic state] (s_0) at (0,-10) {$\texttt{X ; Y ; [idle] [idle]}$};"
       "    \node[elliptic state] (s_2) at (0,-14) {$\texttt{s X ; Y ; [idle] [wait(X)]}$};"
       "    \node[elliptic state] (s_4) at (0,-18) {$\texttt{s X ; X ; [idle] [crit(X)]}$};"
       "    \node[elliptic state] (s_6) at (2,-17) {$\texttt{s s Y ; X ; [wait(Y)] [wait(s Y)]}$};"
       "    \node[elliptic state] (s_10) at (0,-22) {$\texttt{s s X ; X ; [crit(X)] [wait(s X)]}$};"
       "    \node[elliptic state] (s_14) at (2,-21) {$\texttt{s s X ; s X ; [crit(s X)] [wait(X)]}$};"
       "    \node[elliptic state] (s_18) at (0,-26) {$\texttt{s s X ; s s X ; [idle] [wait(X)]}$};"
       "    \\path[->] (s_14) edge [bend left=10] node [pos=0.3,right] {exit} (s_18);"
       "    \\path[->>] (s_10) edge [bend left=10] node [pos=0.3,left] {exit} (s_2);"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {crit} (s_14);"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {crit} (s_10);"
       "    \\path[->] (s_4) edge [bend left=10] node [pos=0.3,right] {wake} (s_10);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {exit} (s_0);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {wake} (s_6);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {crit} (s_4);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {wake} (s_2);"
       "\\end{tikzpicture}" .

--- Instead, we can refine the state-description by starting in states such that `Y <= X`, where `Y` is the critical counter and `X` is the next available number.
--- Here we see that a finite state graph is achieved, where some of the states have additional constraints:

reduce renderTikZGraph(0, bfs(state(#cTerm[conf2Idle('X:Name, 'Y:Name), le('Y:Name, 'X:Name)])))
    == "\tikzset{elliptic state/.style={draw,ellipse}}"
       "\begin{tikzpicture}[shorten >=1pt,on grid,transform shape]"
       "\footnotesize"
       "    \node[elliptic state] (s_0) at (0,-10) {$\texttt{X ; Y ; [idle] [idle]}\\ st \\ \texttt{Y} \\le \texttt{X}$};"
       "    \node[elliptic state] (s_2) at (0,-14) {$\texttt{s X ; Y ; [idle] [wait(X)]}\\ st \\ \texttt{Y} \\le \texttt{X}$};"
       "    \node[elliptic state] (s_4) at (2,-13) {$\texttt{s N M ; N ; [idle] [wait(N M)]}$};"
       "    \node[elliptic state] (s_6) at (0,-18) {$\texttt{s N ; N ; [idle] [crit(N)]}$};"
       "    \node[elliptic state] (s_8) at (2,-17) {$\texttt{s s Y ; X ; [wait(Y)] [wait(s Y)]}\\ st \\ \texttt{X} \\le \texttt{Y}$};"
       "    \node[elliptic state] (s_10) at (4,-16) {$\texttt{s s N M ; N ; [wait(N M)] [wait(s N M)]}$};"
       "    \node[elliptic state] (s_16) at (0,-22) {$\texttt{s X ; s X ; [idle] [idle]}$};"
       "    \node[elliptic state] (s_18) at (2,-21) {$\texttt{s s X ; X ; [crit(X)] [wait(s X)]}$};"
       "    \\path[->>] (s_18) edge [bend left=10] node [pos=0.3,left] {exit} (s_4);"
       "    \\path[->>] (s_16) edge [bend left=10] node [pos=0.3,left] {wake} (s_4);"
       "    \\path[->] (s_10) edge [bend left=10] node [pos=0.3,right] {crit} (s_18);"
       "    \\path[->>] (s_8) edge [bend left=10] node [pos=0.3,left] {crit} (s_18);"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {wake} (s_18);"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {exit} (s_16);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {wake} (s_10);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {crit} (s_6);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {wake} (s_10);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {wake} (s_8);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {crit} (s_6);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {wake} (s_4);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {wake} (s_2);"
       "\\end{tikzpicture}" .

--- ### Arbitrary Process Bakery

--- #### With Equational Abstraction

--- As a sanity check, results of section 3.3 of [@bae-escobar-meseguer-abstract-model-checking] are replicated.
--- This required an equational abstraction which removed "extra" waiting processes, which was shown to be sound.

mod BAKERY-NPROC-EQUATIONAL-ABSTRACTION is
    including BAKERY .

    vars M L : Name . var PS : ProcSet .

    eq s s s L M ; M ; PS [wait(s L M)] [wait(s s L M)]
     =   s s L M ; M ; PS [wait(s L M)] .
endm

--- Here we instantiate to the abstracted theory:

mod BAKERY-NPROC-EQUATIONAL-ABSTRACTION-NARROWING-GRAPH is
    extending BAKERY-NARROWING-GRAPH-COMMON .

    eq #MO = upModule('BAKERY-NPROC-EQUATIONAL-ABSTRACTION, true) .

--- The initial state has all `idle` processes and equal counters.

    op confManyIdleEq : -> [Term] .
    -------------------------------
    eq confManyIdleEq = #cTerm[confManyIdle('X:Name, 'X:Name), #cTrue] .
endm

reduce wellFormed(#M) .
reduce wellFormed(#M, conf2Crit) .
reduce wellFormed(#M, confManyIdleEq) .

--- Under this assumption, a finite state graph is achieved.
--- The resulting graph differs from [@bae-escobar-meseguer-abstract-model-checking] because here states which are $=_{B}$ are identified (with $B = AC$ for the process set).
--- In addition, edges which take advantage of the equational abstraction to fold into a prior state are not identified.

reduce renderTikZGraph(0, bfs(state(confManyIdleEq)))
    == "\tikzset{elliptic state/.style={draw,ellipse}}"
       "\begin{tikzpicture}[shorten >=1pt,on grid,transform shape]"
       "\footnotesize"
       "    \node[elliptic state] (s_0) at (0,-10) {$\texttt{X ; X ; PIS}$};"
       "    \node[elliptic state] (s_2) at (0,-14) {$\texttt{s X ; X ; PIS [wait(X)]}$};"
       "    \node[elliptic state] (s_4) at (0,-18) {$\texttt{s X ; X ; PIS [crit(X)]}$};"
       "    \node[elliptic state] (s_6) at (2,-17) {$\texttt{s s X ; X ; PIS [wait(X)] [wait(s X)]}$};"
       "    \node[elliptic state] (s_10) at (0,-22) {$\texttt{s s X ; X ; PIS [crit(X)] [wait(s X)]}$};"
       "    \\path[->>] (s_10) edge [loop below,min distance=25] node [pos=0.3,left] {wake} (s_10);"
       "    \\path[->>] (s_10) edge [bend left=10] node [pos=0.3,left] {exit} (s_2);"
       "    \\path[->>] (s_6) edge [loop below,min distance=25] node [pos=0.3,left] {wake} (s_6);"
       "    \\path[->>] (s_6) edge [bend left=10] node [pos=0.3,left] {crit} (s_10);"
       "    \\path[->] (s_4) edge [bend left=10] node [pos=0.3,right] {wake} (s_10);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {exit} (s_0);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {wake} (s_6);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {crit} (s_4);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {wake} (s_2);"
       "\\end{tikzpicture}" .

--- #### With Constrained States and Lemmas

--- Similar to the two process case, an equational abstraction of the system can be avoided searching in a constraint system.

mod BAKERY-NPROC-RECFUNC is
   protecting BAKERY .
   protecting FVP-BOOL-EQFORM * ( sort Nat to Name
                                , op 1 to s
                                , op _+_ to __
                                ) .

    vars N N' M : Name . vars NzN NzN' : NzNat . vars EqF EqF' : EqForm{Bool} .
    var P : Proc . var PWS : ProcWaitSet . vars PS : ProcSet .

--- The predicate `ill-formed` encodes the cases when a queue at the bakery is not well formed.
--- The first name corresponds to the current customer being served, and the second to the next number someone will pull if they walk in.

    op ill-formed : Name ProcSet Name -> Bool .
    -------------------------------------------

--- Bakerys can be ill-formed because the pool of waiting processes has numbers which
---
--- -   should have already been called, or
--- -   remain to be called.

    eq ill-formed(N NzN, PS, N) = true .

    eq ill-formed(N NzN, [wait(N)] PS, M) = true .
    eq ill-formed(N NzN, [crit(N)] PS, M) = true .

    eq ill-formed(N, [wait(M N')] PS, M) = true .
    eq ill-formed(N, [crit(M N')] PS, M) = true .

--- Stating some recursive properties of ill-formed states assists when proving the implication in $T$ for state subsumption in $\R$.
--- Read right-to-left as implications, these are inductive properties about `ill-formed` states, that is:
---
--- -   adding `[idle]` processes does not change whether a state is `ill-formed`,
--- -   if a pool of processes `PS` has numbers amongst them down to `s N`, then adding a process with number `N` does not affect `ill-formed`, and
--- -   if a pool of processes `PS` has numbers amongst them less than `M`, adding a process wth number `s M` does not affect `ill-formed`.

    eq ill-formed(N, [idle] PS, M) = ill-formed(N, PS, M) .

    eq ill-formed(N, [crit(N)] PS, M) = ill-formed(s N, PS, M) .
    eq ill-formed(N, [wait(N)] PS, M) = ill-formed(s N, PS, M) .

    eq ill-formed(N, [wait(M)] PS, s M) = ill-formed(N, PS, M) .
    eq ill-formed(N, [crit(M)] PS, s M) = ill-formed(N, PS, M) .
endm

--- Note that `ill-formed` does not imply our overall property we wish to show for the system, as it does not bar states with two critical processes.
--- For instance, the following does not simplify to `true`:

reduce ill-formed(N, [crit(N)] [crit(s N)], s s N) .

--- but this does:

reduce ill-formed(N, [wait(N)] [wait(N)], s N) .

reduce (true ?= ill-formed(s N, PWS       , M))
    => (true ?= ill-formed(s N, PWS [idle], M)) .

reduce (true ?= ill-formed(s N, PWS, N'))
    => (true ?= ill-formed(s N, PWS [wait(N')] [wait(s N')], s s N')) .

reduce (true ?= ill-formed(s N, PWS, N'))
    => (true ?= ill-formed(s N, PWS [wait(N')], s N')) .

reduce (true ?= ill-formed(s N, PWS           , s M))
    => (true ?= ill-formed(s N, PWS [wait(M)] , s M)) .

reduce (true ?= ill-formed(s N, PWS,              M))
    => (true ?= ill-formed(s N, PWS [wait(M)] , s M)) .

reduce (true ?= ill-formed(s s N , PWS           , N))
    => (true ?= ill-formed(s M   , PWS [wait(N)] , s N)) .

fmod BAKERY-NPROC-RECFUNC-NARROWING-GRAPH is
    extending BAKERY-NARROWING-GRAPH-COMMON .

    vars C C' T T' T'' : Term . var TYPE : Type .

    eq #MO = upModule('BAKERY-NPROC-RECFUNC, true) .

    op ep : Term Term Term -> [Term] .
    ----------------------------------
    eq ep(T, T', T'') = '_!=_['true.Bool, 'ill-formed[T, T', T'']] .

   ceq implies?(C, C') = true if { T , TYPE } := metaReduce(#M, '_=>_[C, C'])
                              /\ T = #cTrue .

    op wellFormedManyWait : -> Term .
    ---------------------------------
    eq wellFormedManyWait = #cTerm['_;_;_['X:Name, 'Y:Name, 'PWS:ProcWaitSet], ep('Y:Name, 'PWS:ProcWaitSet, 'X:Name)] .
endfm

reduce wellFormed(#M) .
reduce wellFormed(#M, wellFormedManyWait) .

--- reduce bfs(state(wellFormedManyWait)) .

--- From an arbitrary state with idle processes, we get an ever-increasing state-graph.

reduce renderTikZGraph(0, bfs(states(#cTerm[conf('X:Name, 'Y:Name, 'PIS:ProcIdleSet), #cTrue]), 3))
    == "\tikzset{elliptic state/.style={draw,ellipse}}"
       "\begin{tikzpicture}[shorten >=1pt,on grid,transform shape]"
       "\footnotesize"
       "    \node[elliptic state] (s_0) at (0,-10) {$\texttt{X ; Y ; PIS}$};"
       "    \node[elliptic state] (s_2) at (0,-14) {$\texttt{s X ; Y ; @3 [wait(X)]}$};"
       "    \node[elliptic state] (s_4) at (0,-18) {$\texttt{s X ; X ; PIS [crit(X)]}$};"
       "    \node[elliptic state] (s_6) at (2,-17) {$\texttt{s s Y ; X ; @3 [wait(Y)] [wait(s Y)]}$};"
       "    \node[elliptic state] (s_10) at (0,-22) {$\texttt{s s X ; X ; PIS [crit(X)] [wait(s X)]}$};"
       "    \node[elliptic state] (s_14) at (2,-21) {$\texttt{s s Y ; s Y ; @1 [crit(s Y)] [wait(Y)]}$};"
       "    \node[elliptic state] (s_16) at (4,-20) {$\texttt{s s s Z ; X ; PIS [wait(Z)] [wait(s Z)] [wait(s s Z)]}$};"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {wake} (s_16);"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {crit} (s_14);"
       "    \\path[->>] (s_6) edge [bend left=10] node [pos=0.3,left] {crit} (s_10);"
       "    \\path[->] (s_4) edge [bend left=10] node [pos=0.3,right] {wake} (s_10);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {exit} (s_0);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {wake} (s_6);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {crit} (s_4);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {wake} (s_2);"
       "\\end{tikzpicture}" .

--- From a state which is restricted to have the `every-position` property, we almost achieve a folded graph in 1 step.

reduce renderTikZGraph(0, bfs(states(#cTerm[conf('X:Name, 'Y:Name, 'PWS:ProcWaitSet), ep('Y:Name, 'PWS:ProcWaitSet, 'X:Name)]), 3))
    == "\tikzset{elliptic state/.style={draw,ellipse}}"
       "\begin{tikzpicture}[shorten >=1pt,on grid,transform shape]"
       "\footnotesize"
       "    \node[elliptic state] (s_0) at (0,-10) {$\texttt{X ; Y ; PWS}\\ st \\ \texttt{true != ill-formed(Y, PWS, X)}$};"
       "    \node[elliptic state] (s_2) at (0,-14) {$\texttt{X ; Y ; PWS3 [crit(Y)]}\\ st \\ \texttt{true != ill-formed(s Y, PWS3, X)}$};"
       "    \node[elliptic state] (s_4) at (2,-13) {$\texttt{s X ; Y ; PWS3 [wait(X)]}\\ st \\ \texttt{true != ill-formed(Y, PWS3, X)}$};"
       "    \node[elliptic state] (s_6) at (0,-18) {$\texttt{X ; s Z ; PWS2 [idle]}\\ st \\ \texttt{true != ill-formed(s Z, PWS2, X)}$};"
       "    \node[elliptic state] (s_8) at (2,-17) {$\texttt{s X ; Z ; PWS2 [crit(Z)] [wait(X)]}\\ st \\ \texttt{true != ill-formed(s Z, PWS2, X)}$};"
       "    \node[elliptic state] (s_16) at (0,-22) {$\texttt{X ; s Y ; PWS3 [idle] [crit(s Y)]}\\ st \\ \texttt{true != ill-formed(s s Y, PWS3, X)}$};"
       "    \\path[->>] (s_8) edge [bend left=10] node [pos=0.3,left] {wake} (s_2);"
       "    \\path[->>] (s_8) edge [bend left=10] node [pos=0.3,left] {exit} (s_6);"
       "    \\path[->>] (s_6) edge [bend left=10] node [pos=0.3,left] {wake} (s_4);"
       "    \\path[->] (s_6) edge [bend left=10] node [pos=0.3,right] {crit} (s_16);"
       "    \\path[->>] (s_4) edge [loop below,min distance=25] node [pos=0.3,left] {wake} (s_4);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {crit} (s_2);"
       "    \\path[->>] (s_4) edge [bend left=10] node [pos=0.3,left] {crit} (s_2);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {wake} (s_8);"
       "    \\path[->] (s_2) edge [bend left=10] node [pos=0.3,right] {exit} (s_6);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {wake} (s_4);"
       "    \\path[->] (s_0) edge [bend left=10] node [pos=0.3,right] {crit} (s_2);"
       "\\end{tikzpicture}" .

--- Module FVP-BAKERY
--- =================

fmod FVP-BAKERY-INIT is
   protecting META-TERM .
   protecting UNCONDITIONALIZE-FVP-BOOL .
    including CONDITIONAL-NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH .

    op init : Nat -> [Term] .
    -------------------------
    eq init(0) = '<_`,_`,_`,_>['sleep.NcMode ,'_+_['1.NzNat,'1.NzNat,'1.NzNat],'wait.NcMode,'_+_['1.NzNat,'1.NzNat]] .
    eq init(1) = '<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat   , 'QC:Mode      , 'X2:Nat   ] .
    eq init(2) = '<_`,_`,_`,_>[ 'PC:Mode      , 'Y1:Nat   , 'QNC:NcMode   , 'Y2:Nat   ] .
    eq init(3) = '<_`,_`,_`,_>[ 'sleep.NcMode , 'X0:Nat   , 'sleep.NcMode , 'X0:Nat   ] .
    eq init(4) = '<_`,_`,_`,_>[ 'sleep.NcMode , 'X0:Nat   , 'sleep.NcMode , 'X1:Nat   ] .
    eq init(5) = '<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat   , 'QC:Mode      , 'X2:NzNat ] .
    eq init(6) = '<_`,_`,_`,_>[ 'PC:Mode      , 'Y1:NzNat , 'QNC:NcMode   , 'Y2:Nat   ] .
    eq init(7) = '<_`,_`,_`,_>[ 'wait.NcMode  , 'Y1:Nat   , 'QC:Mode      , 'Y2:NzNat ] .
    eq init(8) = '<_`,_`,_`,_>[ 'QC:Mode      , 'Y1:NzNat , 'wait.NcMode  , 'Y2:Nat   ] .
    eq init(9) = '<_`,_`,_`,_>[ 'crit.Mode    , 'X2:Nat   , 'crit.Mode    , 'X3:Nat   ] .
endfm

--- FVP-CONDITIONAL-NARROWING-GRAPH

mod BAKERY-FVP-CONDITIONAL-NARROWING-GRAPH is
    including FVP-BAKERY-INIT .

    var N : Nat . vars T T' : Term .

    eq #tSort = 'BState .
    eq #MO    = upModule('BAKERY-FVP, true) .

    op fvpTT : -> Term .
    --------------------
    eq fvpTT = 'tt.TrueLit`{Bool`} .

    op inj : Nat -> Term .
    ----------------------
    eq inj(N) = '_st_[init(N), fvpTT] .

    op neq : Term Term -> Term .
    ----------------------------
endm

reduce wellFormed(#M) .
reduce wellFormed(#M, inj(1)) .
reduce wellFormed(#M, inj(2)) .

--- proposed invariant:
reduce state(inj(1)) ; state(inj(2)) .

--- actually can produce a double-crit mode in 2 steps:
reduce (state(inj(1)) ; state(inj(2))) =>* state(inj(9)) .
reduce bfs((state(inj(1)) ; state(inj(2))), 2) .

--- perhaps we can start from a smaller initial state:
reduce state(inj(4)) =>* state(inj(9)) .

--- Is this execution in our proposed invariant?
reduce nodes(bfs(state(inj(4)))) <= (state(inj(1)) ; state(inj(2))) .
reduce bfs(state(inj(4))) .

reduce (state(inj(5)) ; state(inj(6))) =>* state(inj(9)) .

mod BAKERY-FVP-CTOR-NARROWING-GRAPH is
   protecting FVP-BAKERY-INIT .
    extending NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH .

    eq #M = upModule('BAKERY-FVP-CTOR, true) .
endm

***(Desired initial states and invariant:
   vars X0 X Y X' Y' : Nat .

Set of initial states:  < sleep, X0, sleep, X0 > .

  vars P Q : Mode .    vars P' Q' : NcMode .  vars

Mutex Invariant:  < P', X, Q, Y > \/ < P, X', Q', Y' > .
             or: state(init(1)) \/ state(init(2)) .
)


reduce wellFormed(#M, init(0)) .
reduce wellFormed(#M, init(1)) .
reduce wellFormed(#M, init(2)) .
reduce wellFormed(#M, init(3)) .
reduce wellFormed(#M, init(4)) .
reduce wellFormed(#M, init(5)) .
reduce wellFormed(#M, init(6)) .
reduce wellFormed(#M, init(7)) .
reduce wellFormed(#M, init(8)) .
reduce wellFormed(#M, init(9)) .

reduce step(state(init(0))) .
reduce step(state(init(1))) .
reduce step(state(init(2))) .
reduce step(state(init(3))) .

reduce state(init(3)) <= states(init(1) | init(2)) .
reduce state(init(1)) <= states(init(1) | init(2)) .
reduce state(init(2)) <= state(init(1)) .

reduce state('wait.NcMode)           <= state('PC:Mode) .
reduce state('_+_['1.NzNat,'V3:Nat]) <= state('Y1:NzNat) .
reduce state('V2:NcMode)             <= state('QNC:NcMode) .
reduce state('V3:Nat)                <= state('Y2:Nat) .

--- TODO: It would be nice to be able to prove the following
reduce state('Y1:NzNat) <= state('_+_['1.NzNat,'V3:Nat]) .

reduce state('<_`,_`,_`,_>[ 'wait.NcMode , '_+_['1.NzNat,'V3:Nat] ,  'V2:NcMode , 'V3:Nat ])
    <= state('<_`,_`,_`,_>[ 'PC:Mode     , 'Y1:NzNat              , 'QNC:NcMode , 'Y2:Nat ]) .


reduce state('sleep.NcMode) <= state('PNC:NcMode) .
reduce state('0.Nat)        <= state('X1:Nat) .
reduce state('V2:NcMode)    <= state('QC:Mode) .
reduce state('V3:Nat)       <= state('X2:NzNat) .

reduce state('<_`,_`,_`,_>[ 'sleep.NcMode , '0.Nat  , 'V2:NcMode , 'V3:Nat   ])
    <= state('<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat , 'QC:Mode   , 'X2:NzNat ]) .

reduce   state('<_`,_`,_`,_>[ 'sleep.NcMode , '0.Nat    , 'V2:NcMode    , 'V3:Nat   ])
    <= ( state('<_`,_`,_`,_>[ 'PC:Mode      , 'Y1:NzNat , 'QNC:NcMode   , 'Y2:Nat   ])
       ; state('<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat   , 'QC:Mode      , 'X2:NzNat ])
       ; state('<_`,_`,_`,_>[ 'sleep.NcMode , '0.Nat    , 'sleep.NcMode , '0.Nat    ])
       ) .

reduce intersect(state('V2:NzNat), state('V3:Nat)) .
reduce intersect(state('V2:Nat), state('V3:Nat)) .
reduce intersect( state('<_`,_`,_`,_>['V1:Mode,'0.Nat,'crit.Mode,'V2:Nat])
                , state('<_`,_`,_`,_>['V1:Mode,'_+_['V2:Nat,'V3:NzNat],'crit.Mode,'V2:Nat])
                ) .

--- both initial states yield finite state-graphs
reduce bfs(state(init(1))) .
reduce bfs(state(init(2))) .
reduce bfs(state(init(3))) .
reduce bfs(states(init(1) | init(2))) .

reduce nodes(bfs(state(init(1)))) .
reduce nodes(bfs(state(init(2)))) .
reduce nodes(bfs(state(init(3)))) .
reduce nodes(bfs(states(init(1) | init(2)))) .

reduce nodes(bfs(states(init(1) | init(2)))) <= (nodes(bfs(state(init(1)))) ; nodes(bfs(state(init(2))))) .
reduce (nodes(bfs(state(init(1)))) ; nodes(bfs(state(init(2))))) <= nodes(bfs(states(init(1) | init(2)))) .

reduce state(init(3))                                               <= states(init(1) | init(2)) .
reduce state(init(3))                                               <= nodes(bfs(states(init(1) | init(2)))) .
reduce states(init(1) | init(2))                                    <= nodes(extend(states(init(1) | init(2)))) .
reduce states(init(1) | init(2))                                    <= nodes(bfs(states(init(1) | init(2)))) .
reduce nodes(extend(states(init(1) | init(2))))                     <= states(init(1) | init(2)) .
reduce nodes(extend(states(init(1) | init(2))))                     <= nodes(bfs(states(init(1) | init(2)))) .
reduce nodes(extend(states(init(5) | init(6) | init(7) | init(8)))) <= states(init(5) | init(6) | init(7) | init(8)) .

--- state init(3) stays within init(1) ; init(2)
reduce nodes(bfs(state(init(3)))) <= states(init(1) | init(2)) .

--- even though in general init(1) ; init(2) is *not* an invariant
reduce invariant(states(init(1) | init(2))) .
reduce invariant(states(init(4) | init(5) | init(6))) .
reduce invariant(states(init(5) | init(6) | init(7) | init(8))) .
reduce nodes(bfs(states(init(1) | init(2)))) <= states(init(1) | init(2)) .
reduce check state(init(3)) stable in states(init(1) | init(2)) .

--- state 3 never reaches the bad state 9, but states 1 ; 2 can
reduce state(init(3))            =>* state(init(9)) .
reduce states(init(1) | init(2)) =>* state(init(9)) .
