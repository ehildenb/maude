set show timing off .

load ../../../contrib/systems/bakery.maude
load ../../../contrib/tools/lmc/lgraph-search.maude

--- ### Bakery System Instatiation

fmod BAKERY-NARROWING-GRAPH-COMMON is
    including UNCONDITIONALIZE-FVP-BOOL .
    including ( CONDITIONAL-NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH ) .

    eq #tSort = 'Conf .
    -------------------

    vars T T' T'' : Term .

    op upIdle : -> [Term] .
    -----------------------
    eq upIdle = '`[_`]['idle.ModeIdle] .

    op upCrit : Term -> [Term] .
    ----------------------------
    eq upCrit(T) = '`[_`]['crit[T]] .

   ops lt le : Term Term -> [Term] .
   ---------------------------------
    eq lt(T, T') = '_?=_[ '_<_[T, T'], 'true.Bool] .
    eq le(T, T') = '_?=_['_<=_[T, T'], 'true.Bool] .

    op conf : Term Term Term -> [Term] .
    ------------------------------------
    eq conf(T, T', T'') = '_;_;_[T, T', T''] .

--- The following initial terms characterize our initialization and bad states.
---
--- -   `conf2Idle` has two idle processes.
--- -   `confManyIdle` has an arbitrary set of `idle` processes.
--- -   `confManyWait` has an arbitrary set of `wait` processes.
--- -   `confManyProc` has an arbitrary set of any processes.

    op conf2Idle    : Term Term -> [Term] .
    op confManyIdle : Term Term -> [Term] .
    op confManyWait : Term Term -> [Term] .
    op confManyProc : Term Term -> [Term] .
    ---------------------------------------
    eq conf2Idle   (T, T') = conf(T, T', '__[upIdle, upIdle]) .
    eq confManyIdle(T, T') = conf(T, T', 'PIS:ProcIdleSet)    .
    eq confManyWait(T, T') = conf(T, T', 'PWS:ProcWaitSet)    .
    eq confManyProc(T, T') = conf(T, T', 'PS:ProcSet)         .

--- -   `conf2Crit` is any constrained configuration which contains two `crit` processes.

    op conf2Crit : -> [Term] .
    --------------------------
    eq conf2Crit = #cTerm['_;_;_['N:Name, 'M:Name, '__['`[_`]['MC1:ModeCrit], '`[_`]['MC2:ModeCrit], 'PS:ProcSet]], #cTrue] .
endfm

reduce wellFormed(upModule('BAKERY, false), conf2Idle   ('X:Name, 'Y:Name)) .
reduce wellFormed(upModule('BAKERY, false), confManyIdle('X:Name, 'Y:Name)) .
reduce wellFormed(upModule('BAKERY, false), confManyWait('X:Name, 'Y:Name)) .
reduce wellFormed(upModule('BAKERY, false), confManyProc('X:Name, 'Y:Name)) .

--- ### Two Process Bakery

--- #### With Equational Abstraction

--- As a sanity check, results of section 3.1 of [@bae-escobar-meseguer-abstract-model-checking] are replicated.
--- This required an equational abstraction which reduced all the names in the configuration uniformly when they are all non-`0`.

mod BAKERY-2PROC-EQUATIONAL-ABSTRACTION is
    including BAKERY .

    vars N M K L : Name . var PIS : ProcIdleSet .

    eq s N ; s M ; [idle]      [idle]      = N ; M ; [idle]    [idle] .
    eq s N ; s M ; [wait(s K)] [idle]      = N ; M ; [wait(K)] [idle] .
    eq s N ; s M ; [crit(s K)] [idle]      = N ; M ; [crit(K)] [idle] .
    eq s N ; s M ; [wait(s K)] [wait(s L)] = N ; M ; [wait(K)] [wait(L)] .
    eq s N ; s M ; [wait(s K)] [crit(s L)] = N ; M ; [wait(K)] [crit(L)] .
    eq s N ; s M ; [crit(s K)] [crit(s L)] = N ; M ; [crit(K)] [crit(L)] .
endm

--- Here we instantiate to the abstracted theory:

mod BAKERY-2PROC-EQUATIONAL-ABSTRACTION-NARROWING-GRAPH is
    extending BAKERY-NARROWING-GRAPH-COMMON .

    eq #MO = upModule('BAKERY-2PROC-EQUATIONAL-ABSTRACTION, true) .

--- The initial state has two `idle` processes and both counters `N`:

    op conf2IdleEq : -> [Term] .
    ----------------------------
    eq conf2IdleEq = #cTerm[conf2Idle('X:Name, 'X:Name), #cTrue] .
endm

reduce wellFormed(#M) .

reduce wellFormed(#M, conf2Crit) .
reduce wellFormed(#M, conf2IdleEq) .

--- Under this assumption, a finite state graph is achieved.
--- The resulting graph differs from [@bae-escobar-meseguer-abstract-model-checking] because here states which are $=_{B}$ are identified (with $B = AC$ for the process set).
--- In addition, edges which take advantage of the equational abstraction to fold into a prior state are not identified.

reduce bfs(state(conf2IdleEq)) .

--- We can also search for a reach-path to a "bad" state in `conf2Crit`, and see that there is none:

--- **TODO**: Fix bug in this query.

reduce state(conf2IdleEq) =>* state(conf2Crit) .

--- #### With Constrained Bakery

--- Here the equational abstraction is avoided by taking advantage of constrained states.

mod BAKERY-2PROC-NARROWING-GRAPH is
    extending BAKERY-NARROWING-GRAPH-COMMON .

--- Instead we instantiate to the original theory:

    eq #MO = upModule('BAKERY, true) .

--- The initial state `cConf2Idle` contains two idle states, but the counters are not made to be the same as in [@bae-escobar-meseguer-abstract-model-checking].
--- Instead, the `crit` counter is constrained to be lower than the `wait` counter using side-conditions in the theory `FVP-INT-PRED`.

    op cConf2Idle : -> [Term] .
    ---------------------------
    eq cConf2Idle = #cTerm[conf2Idle('X:Name, 'Y:Name), le('Y:Name, 'X:Name)] .
endm

reduce wellFormed(#M) .

reduce wellFormed(#M, conf2Crit) .
reduce wellFormed(#M, cConf2Idle) .

--- Here we see that a finite state graph is achieved, where some of the states have additional constraints:

reduce bfs(state(cConf2Idle)) .

--- Indeed, the initial constrained state cannot reach an instance of our `bad` states:

--- **TODO**: Fix bug in this query.

reduce state(cConf2Idle) =>* state(conf2Crit) .

--- ### Arbitrary Process Bakery

--- #### With Equational Abstraction

--- As a sanity check, results of section 3.3 of [@bae-escobar-meseguer-abstract-model-checking] are replicated.
--- This required an equational abstraction which removed "extra" waiting processes, which was shown to be sound.

mod BAKERY-NPROC-EQUATIONAL-ABSTRACTION is
    including BAKERY .

    vars M L : Name . var PS : ProcSet .

    eq s s s L M ; M ; PS [wait(s L M)] [wait(s s L M)]
     =   s s L M ; M ; PS [wait(s L M)] .
endm

--- Here we instantiate to the abstracted theory:

mod BAKERY-NPROC-EQUATIONAL-ABSTRACTION-NARROWING-GRAPH is
    extending BAKERY-NARROWING-GRAPH-COMMON .

    eq #MO = upModule('BAKERY-NPROC-EQUATIONAL-ABSTRACTION, true) .

--- The initial state has all `idle` processes and equal counters.

    op confManyIdleEq : -> [Term] .
    -------------------------------
    eq confManyIdleEq = #cTerm[confManyIdle('X:Name, 'X:Name), #cTrue] .
endm

reduce wellFormed(#M) .

reduce wellFormed(#M, conf2Crit) .
reduce wellFormed(#M, confManyIdleEq) .

--- Under this assumption, a finite state graph is achieved.
--- The resulting graph differs from [@bae-escobar-meseguer-abstract-model-checking] because here states which are $=_{B}$ are identified (with $B = AC$ for the process set).
--- In addition, edges which take advantage of the equational abstraction to fold into a prior state are not identified.

reduce bfs(state(confManyIdleEq)) .

--- Module FVP-BAKERY
--- =================

fmod FVP-BAKERY-INIT is
   protecting META-TERM .
   protecting UNCONDITIONALIZE-FVP-BOOL .
    including CONDITIONAL-NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH .

    op init : Nat -> [Term] .
    -------------------------
    eq init(0) = '<_`,_`,_`,_>['sleep.NcMode ,'_+_['1.NzNat,'1.NzNat,'1.NzNat],'wait.NcMode,'_+_['1.NzNat,'1.NzNat]] .
    eq init(1) = '<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat   , 'QC:Mode      , 'X2:Nat   ] .
    eq init(2) = '<_`,_`,_`,_>[ 'PC:Mode      , 'Y1:Nat   , 'QNC:NcMode   , 'Y2:Nat   ] .
    eq init(3) = '<_`,_`,_`,_>[ 'sleep.NcMode , 'X0:Nat   , 'sleep.NcMode , 'X0:Nat   ] .
    eq init(4) = '<_`,_`,_`,_>[ 'sleep.NcMode , 'X0:Nat   , 'sleep.NcMode , 'X1:Nat   ] .
    eq init(5) = '<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat   , 'QC:Mode      , 'X2:NzNat ] .
    eq init(6) = '<_`,_`,_`,_>[ 'PC:Mode      , 'Y1:NzNat , 'QNC:NcMode   , 'Y2:Nat   ] .
    eq init(7) = '<_`,_`,_`,_>[ 'wait.NcMode  , 'Y1:Nat   , 'QC:Mode      , 'Y2:NzNat ] .
    eq init(8) = '<_`,_`,_`,_>[ 'QC:Mode      , 'Y1:NzNat , 'wait.NcMode  , 'Y2:Nat   ] .
    eq init(9) = '<_`,_`,_`,_>[ 'crit.Mode    , 'X2:Nat   , 'crit.Mode    , 'X3:Nat   ] .
endfm

--- FVP-CONDITIONAL-NARROWING-GRAPH

mod BAKERY-FVP-CONDITIONAL-NARROWING-GRAPH is
    including FVP-BAKERY-INIT .

    var N : Nat . vars T T' : Term .

    eq #tSort = 'BState .
    eq #MO    = upModule('BAKERY-FVP, true) .

    op fvpTT : -> Term .
    --------------------
    eq fvpTT = 'tt.TrueLit`{Bool`} .

    op inj : Nat -> Term .
    ----------------------
    eq inj(N) = '_st_[init(N), fvpTT] .

    op neq : Term Term -> Term .
    ----------------------------
endm

reduce wellFormed(#M) .
reduce wellFormed(#M, inj(1)) .
reduce wellFormed(#M, inj(2)) .

--- proposed invariant:
reduce state(inj(1)) ; state(inj(2)) .

--- actually can produce a double-crit mode in 2 steps:
reduce (state(inj(1)) ; state(inj(2))) =>* state(inj(9)) .
reduce bfs((state(inj(1)) ; state(inj(2))), 2) .

--- perhaps we can start from a smaller initial state:
reduce state(inj(4)) =>* state(inj(9)) .

--- Is this execution in our proposed invariant?
reduce nodes(bfs(state(inj(4)))) <= (state(inj(1)) ; state(inj(2))) .
reduce bfs(state(inj(4))) .

reduce (state(inj(5)) ; state(inj(6))) =>* state(inj(9)) .

mod BAKERY-FVP-CTOR-NARROWING-GRAPH is
   protecting FVP-BAKERY-INIT .
    extending NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH .

    eq #M = upModule('BAKERY-FVP-CTOR, true) .
endm

***(Desired initial states and invariant:
   vars X0 X Y X' Y' : Nat .

Set of initial states:  < sleep, X0, sleep, X0 > .

  vars P Q : Mode .    vars P' Q' : NcMode .  vars

Mutex Invariant:  < P', X, Q, Y > \/ < P, X', Q', Y' > .
             or: state(init(1)) \/ state(init(2)) .
)


reduce wellFormed(#M, init(0)) .
reduce wellFormed(#M, init(1)) .
reduce wellFormed(#M, init(2)) .
reduce wellFormed(#M, init(3)) .
reduce wellFormed(#M, init(4)) .
reduce wellFormed(#M, init(5)) .
reduce wellFormed(#M, init(6)) .
reduce wellFormed(#M, init(7)) .
reduce wellFormed(#M, init(8)) .
reduce wellFormed(#M, init(9)) .

reduce step(state(init(0))) .
reduce step(state(init(1))) .
reduce step(state(init(2))) .
reduce step(state(init(3))) .

reduce state(init(3)) <= states(init(1) | init(2)) .
reduce state(init(1)) <= states(init(1) | init(2)) .
reduce state(init(2)) <= state(init(1)) .

reduce state('wait.NcMode)           <= state('PC:Mode) .
reduce state('_+_['1.NzNat,'V3:Nat]) <= state('Y1:NzNat) .
reduce state('V2:NcMode)             <= state('QNC:NcMode) .
reduce state('V3:Nat)                <= state('Y2:Nat) .

--- TODO: It would be nice to be able to prove the following
reduce state('Y1:NzNat) <= state('_+_['1.NzNat,'V3:Nat]) .

reduce state('<_`,_`,_`,_>[ 'wait.NcMode , '_+_['1.NzNat,'V3:Nat] ,  'V2:NcMode , 'V3:Nat ])
    <= state('<_`,_`,_`,_>[ 'PC:Mode     , 'Y1:NzNat              , 'QNC:NcMode , 'Y2:Nat ]) .


reduce state('sleep.NcMode) <= state('PNC:NcMode) .
reduce state('0.Nat)        <= state('X1:Nat) .
reduce state('V2:NcMode)    <= state('QC:Mode) .
reduce state('V3:Nat)       <= state('X2:NzNat) .

reduce state('<_`,_`,_`,_>[ 'sleep.NcMode , '0.Nat  , 'V2:NcMode , 'V3:Nat   ])
    <= state('<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat , 'QC:Mode   , 'X2:NzNat ]) .

reduce   state('<_`,_`,_`,_>[ 'sleep.NcMode , '0.Nat    , 'V2:NcMode    , 'V3:Nat   ])
    <= ( state('<_`,_`,_`,_>[ 'PC:Mode      , 'Y1:NzNat , 'QNC:NcMode   , 'Y2:Nat   ])
       ; state('<_`,_`,_`,_>[ 'PNC:NcMode   , 'X1:Nat   , 'QC:Mode      , 'X2:NzNat ])
       ; state('<_`,_`,_`,_>[ 'sleep.NcMode , '0.Nat    , 'sleep.NcMode , '0.Nat    ])
       ) .

reduce intersect(state('V2:NzNat), state('V3:Nat)) .
reduce intersect(state('V2:Nat), state('V3:Nat)) .
reduce intersect( state('<_`,_`,_`,_>['V1:Mode,'0.Nat,'crit.Mode,'V2:Nat])
                , state('<_`,_`,_`,_>['V1:Mode,'_+_['V2:Nat,'V3:NzNat],'crit.Mode,'V2:Nat])
                ) .

--- both initial states yield finite state-graphs
reduce bfs(state(init(1))) .
reduce bfs(state(init(2))) .
reduce bfs(state(init(3))) .
reduce bfs(states(init(1) | init(2))) .

reduce nodes(bfs(state(init(1)))) .
reduce nodes(bfs(state(init(2)))) .
reduce nodes(bfs(state(init(3)))) .
reduce nodes(bfs(states(init(1) | init(2)))) .

reduce nodes(bfs(states(init(1) | init(2)))) <= (nodes(bfs(state(init(1)))) ; nodes(bfs(state(init(2))))) .
reduce (nodes(bfs(state(init(1)))) ; nodes(bfs(state(init(2))))) <= nodes(bfs(states(init(1) | init(2)))) .

reduce state(init(3))                                               <= states(init(1) | init(2)) .
reduce state(init(3))                                               <= nodes(bfs(states(init(1) | init(2)))) .
reduce states(init(1) | init(2))                                    <= nodes(extend(states(init(1) | init(2)))) .
reduce states(init(1) | init(2))                                    <= nodes(bfs(states(init(1) | init(2)))) .
reduce nodes(extend(states(init(1) | init(2))))                     <= states(init(1) | init(2)) .
reduce nodes(extend(states(init(1) | init(2))))                     <= nodes(bfs(states(init(1) | init(2)))) .
reduce nodes(extend(states(init(5) | init(6) | init(7) | init(8)))) <= states(init(5) | init(6) | init(7) | init(8)) .

--- state init(3) stays within init(1) ; init(2)
reduce nodes(bfs(state(init(3)))) <= states(init(1) | init(2)) .

--- even though in general init(1) ; init(2) is *not* an invariant
reduce invariant(states(init(1) | init(2))) .
reduce invariant(states(init(4) | init(5) | init(6))) .
reduce invariant(states(init(5) | init(6) | init(7) | init(8))) .
reduce nodes(bfs(states(init(1) | init(2)))) <= states(init(1) | init(2)) .
reduce check state(init(3)) stable in states(init(1) | init(2)) .

--- state 3 never reaches the bad state 9, but states 1 ; 2 can
reduce state(init(3))            =>* state(init(9)) .
reduce states(init(1) | init(2)) =>* state(init(9)) .
