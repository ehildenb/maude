set show timing off .

load ../../../contrib/systems/bank-account.maude
load ../../../contrib/tools/lmc/lgraph-search.maude
load ../../../contrib/tools/meta/narrowing.maude

--- Initial states and Conditions
--- =============================

mod BANK-ACCOUNT-CONDITIONS is
   protecting BANK-ACCOUNT-CTOR .

    var N : Nat . vars X Y : Truth . var MSGS : MsgConf .

    op _->_ : Truth Truth -> Truth .
    --------------------------------
--- TODO: check if these improve performance at all
---    eq X  -> X  = tt        [variant] .
---    eq ff -> X  = tt        [variant] .
---    eq X  -> tt = tt        [variant] .
    eq X  -> Y  = ~(X) \/ Y [variant] .

    op debts : MsgConf -> Nat .
    ---------------------------
    eq debts(mt)                 = 0 .
    eq debts(withdraw(N) , MSGS) = N + debts(MSGS) .
endm

mod BANK-ACCOUNT-INIT-STATES is
    extending FVP-NARROWING-GRAPH .

    var N : Nat . vars NeNS NeNS' : NeNodeSet .

    op init : Nat -> [Term] .
    -------------------------
    eq init(0) = '_#_['<`bal:_pend:_overdraft:_>['N:Nat,'X:Nat,'ff.Truth],'MSGS:MsgConf] .
    eq init(1) = '_#_['<`bal:_pend:_overdraft:_>['N:Nat,'X:Nat,'tt.Truth],'MSGS:MsgConf] .
    eq init(2) = '_#_['<`bal:_pend:_overdraft:_>['_+_['@2:Nat,'@3:Nat,'debts['@1:MsgConf]],'debts['@1:MsgConf],'ff.Truth],'@1:MsgConf] .
    eq init(3) = '_#_['<`bal:_pend:_overdraft:_>['N:Nat,'X:Nat,'ff.Truth],'MSGS:MsgConf] .

    op pred : Nat -> [Term] .
    -------------------------
    eq pred(0) = 'C:Truth .
    eq pred(1) = '_>=_['N:Nat, 'X:Nat] .
    eq pred(2) = 'tt.Truth .
    eq pred(3) = '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]] .
    eq pred(4) = '_->_[pred(3), pred(2)] << sub(0) .

    op cinit : Nat -> [Term] .
    --------------------------
    eq cinit(0) = '_|_[init(0), pred(0)] .
    eq cinit(1) = '_|_[init(0), pred(1)] .
    eq cinit(2) = '_|_[init(1), pred(0)] .
    eq cinit(3) = '_|_[init(1), pred(1)] .
    eq cinit(4) = '_|_[init(2), pred(2)] .
    eq cinit(5) = '_|_[init(3), pred(3)] .

    op sub : Nat -> [Substitution] .
    --------------------------------
    eq sub(0) = ('MSGS:MsgConf <- '@1:MsgConf ; 'N:Nat <- '_+_['@2:Nat,'@3:Nat,'debts['@1:MsgConf]] ; 'X:Nat <- 'debts['@1:MsgConf]) .

    op states : NodeSet -> [NodeSet] .
    ----------------------------------
    eq states(.NodeSet)     = .NodeSet .
    eq states(NeNS ; NeNS') = states(NeNS) ; states(NeNS') .

    eq states(N) = state(cinit(N)) .
endm

--- Module BANK-ACCOUNT-CTOR
--- ------------------------

mod BANK-ACCOUNT-CTOR-NARROWING-GRAPH is
    extending BANK-ACCOUNT-INIT-STATES .
    extending GRAPH-ANALYSIS .

    eq ##m## = upModule('BANK-ACCOUNT-CTOR, true) .
endm

reduce wellFormed(##m##, init(0)) .
reduce bfs(state(init(0))) .

--- Module BANK-ACCOUNT-DEFINEDOPS
--- ------------------------------

mod BANK-ACCOUNT-CTOR-NARROWING-MODULO-T-GRAPH is
    extending FVP-NARROWING-MODULO-T-GRAPH .
    extending GRAPH-ANALYSIS .

    eq ##m## = upModule('BANK-ACCOUNT-DEFINEDOPS, true) .

    op init : Nat -> [Term] .
    -------------------------
    eq init(0) = '_#_['<`bal:_pend:_overdraft:_>['N:Nat,'X:Nat,'ff.Truth],'MSGS:MsgConf] .
endm

reduce wellFormed(##m##, init(0)) .
reduce bfs(state(init(0))) .

--- Module BANK-ACCOUNT-UNCONDITIONALIZED
--- -------------------------------------

mod BANK-ACCOUNT-CTOR-UNCONDITIONALIZED is
   protecting UNCONDITIONALIZE .
    extending BANK-ACCOUNT-INIT-STATES .
    extending GRAPH-ANALYSIS .

    eq ##m## = unconditionalize(##s##, ##c##, ##o##, ##m-condition##, ##m-orig##) .

    op ##s## : ~> Sort [memo] .
    op ##c## : ~> Sort [memo] .
    op ##o## : ~> Qid  [memo] .
    op ##m-condition## : ~> Qid     [memo] .
    op ##m-orig##      : ~> SModule [memo] .
    ----------------------------------------
    eq ##s## = 'State .
    eq ##c## = 'Truth .
    eq ##o## = '_|_   .
    eq ##m-condition## = 'BANK-ACCOUNT-CONDITIONS .
    eq ##m-orig##      = upModule('BANK-ACCOUNT-CTOR, true) .
endm

reduce ##m## .
reduce wellFormed(##m##) .

reduce leastSort (##m##, init(0)) .
reduce wellFormed(##m##, init(0)) .
reduce wellFormed(##m##, init(1)) .
reduce wellFormed(##m##, init(2)) .
reduce wellFormed(##m##, init(3)) .

reduce leastSort (##m##, pred(0)) .
reduce wellFormed(##m##, pred(0)) .
reduce wellFormed(##m##, pred(1)) .
reduce wellFormed(##m##, pred(2)) .
reduce wellFormed(##m##, pred(3)) .
reduce wellFormed(##m##, pred(4)) .

reduce leastSort (##m##, cinit(0)) .
reduce wellFormed(##m##, cinit(0)) .
reduce wellFormed(##m##, cinit(1)) .
reduce wellFormed(##m##, cinit(2)) .
reduce wellFormed(##m##, cinit(3)) .
reduce wellFormed(##m##, cinit(4)) .
reduce wellFormed(##m##, cinit(5)) .

eof

reduce bfs(state(cinit(0))) .
reduce bfs(state(cinit(1)), 1) .

reduce state(pred(1)) <= state(pred(0)) .
reduce states(1)      <= states(0) .
reduce states(1)      <= states(2) .

reduce intersect(states(0), states(2)) .

reduce states(0) .
reduce invariant(states(0)) .
reduce invariant(states(2)) .
reduce invariant(states(0 ; 2)) .

reduce states(1) .
reduce nodes(extend(states(1))) .
reduce invariant(states(1)) .

--- Without condition subsumption works, condition is always true given subsuming substitution.
reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['@2:Nat,'@3:Nat,'debts['@1:MsgConf]] , 'debts['@1:MsgConf]               , 'ff.Truth ] , '@1:MsgConf                              ] , 'tt.Truth])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf                            ] , '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .

reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['@2:Nat,'@3:Nat,'debts['@1:MsgConf]] , '_+_['@3:Nat,'debts['@1:MsgConf]] , 'ff.Truth ] , '_`,_['@1:MsgConf,'withdraw['@3:Nat]]    ] , 'tt.Truth])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf                            ] , '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .
  
reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['%2:Nat,'%3:Nat,'%4:Nat]             , '%2:Nat                           , 'ff.Truth ] , '%1:MsgConf                              ] , '_==_['%2:Nat,'debts['%1:MsgConf]]])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf                            ] , '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .

reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['%1:Nat,'%3:Nat,'%4:Nat]             , '_+_['%1:Nat,'%4:Nat]             , 'ff.Truth ] , '_`,_['%2:MsgConf,'withdraw['%4:Nat]]    ] , '_==_['%1:Nat,'debts['%2:MsgConf]]])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf],'_/\_['_>=_['N:Nat,'X:Nat ] , '_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .
  
reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['@1:Nat,'@4:Nat]                     , '@2:Nat                           , 'ff.Truth ] , '@3:MsgConf                              ] , '_/\_['_>=_['@1:Nat,'@2:Nat],'_==_['@2:Nat,'debts['@3:MsgConf]]]])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf                            ] , '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .

reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['%2:Nat,'%4:Nat]                     , '_+_['1.Nat,'%2:Nat,'%3:Nat]      , 'ff.Truth ] , '%1:MsgConf                              ] , 'ff.Truth])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf                            ] , '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .

reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['%2:Nat,'%3:Nat]                     , '%2:Nat                           , 'tt.Truth ] , '%1:MsgConf                              ] , 'ff.Truth])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf                            ] , '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .

reduce state('_|_['_#_['<`bal:_pend:_overdraft:_>['_+_['%2:Nat,'%3:Nat]                     , '%2:Nat                           , 'ff.Truth ] , '%4:MsgConf                              ] , '_==_['_+_['%1:Nat,'%2:Nat],'_+_['%1:Nat,'debts['%4:MsgConf]]]])
    <= state('_|_['_#_['<`bal:_pend:_overdraft:_>['N:Nat                                    , 'X:Nat                            , 'ff.Truth ] , 'MSGS:MsgConf                            ] , '_/\_['_>=_['N:Nat,'X:Nat],'_==_['X:Nat,'debts['MSGS:MsgConf]]]]) .
--- And more

--- set trace on .
--- reduce bfs(state(init(0) | '_>=_['N:Nat, 'X:Nat] ?= 'tt.Truth /\ 'X:Nat ?= 'debts['MSGS:MsgConf]), 3) .

--- ; The invariant satisfied by this protocol can be expressed as the constrained term:
--- ;
--- ;     < bal: n pend: x overdraft: ff > # msgs | n >= x = tt /\ x = debts(msgs)
--- ;
--- ; where debts is the recursive function:
--- ;
--- ;  op debts : MsgConf -> Nat .
--- ;
--- ;  eq debts(mt) = 0 .
--- ;  eq debts(withdraw(m),msgs) = m + debts(msgs) .
--- ;
--- ; Note that this predicate should have an easy proof by contextual rewriting in reachability logic.
