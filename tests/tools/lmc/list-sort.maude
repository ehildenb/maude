load ../../../contrib/tools/fvp/numbers.maude
load ../../../contrib/tools/lmc/lgraph-search.maude

set include BOOL off .
set include NAT  off .

fmod RENAMED-FVP-NARROWING-GRAPH is
   protecting ( FVP-NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH )
            * ( sort   Nat to   NatP
              , sort NzNat to NzNatP
              , op downTerm to downTermP
              , op   upTerm to   upTermP
              ) .
endfm

fmod FVP-NAT-LIST is
   protecting FVP-NAT-PRED .

    sorts NeListNat ListNat .
    -------------------------
    subsort Nat < NeListNat < ListNat .

    var L : ListNat .

    op .ListNat :                     ->   ListNat [ctor] .
    op _;_      : NeListNat NeListNat -> NeListNat [ctor assoc prec 60] .
    ---------------------------------------------------------------------

    op _;_ : ListNat ListNat -> ListNat [assoc prec 60] .
    -----------------------------------------------------
    eq L ; .ListNat = L [variant] .
    eq .ListNat ; L = L [variant] .
endfm

reduce .ListNat ; 1 + 1 + 1 ; .ListNat .
reduce 1 + 1 + 1 ; 1 + 1 ; 1 + 1 + 1 + 1 ; 1 .

mod FVP-NAT-LIST-SORTING is
   protecting FVP-NAT-LIST .

    sort System .
    -------------

    vars N M : Nat . vars NeL NeL' : NeListNat .

    op [_] : ListNat -> System [ctor] .
    -----------------------------------
    rl [       N + M + 1 ; N        ] => [       N ; N + M + 1        ] [narrowing] .
    rl [ NeL ; N + M + 1 ; N        ] => [ NeL ; N ; N + M + 1        ] [narrowing] .
    rl [       N + M + 1 ; N ; NeL' ] => [       N ; N + M + 1 ; NeL' ] [narrowing] .
    rl [ NeL ; N + M + 1 ; N ; NeL' ] => [ NeL ; N ; N + M + 1 ; NeL' ] [narrowing] .
endm

rewrite [ 1 + 1 + 1  ;  1 + 1 ] .
rewrite [ 1 + 1 + 1  ;  1 + 1  ;  1 + 1 + 1 + 1 ; 1 ] .
rewrite [ 1 + 1 + 1 + 1  ;  1 + 1 + 1  ;  1 + 1 + 1 + 1 + 1 ] .

fmod FVP-NAT-LIST-SORTED-PRED is
   protecting FVP-NAT-LIST .
   protecting FVP-BOOL-EQFORM .

    sorts MSetNat .
    ---------------
    subsort Nat < MSetNat .

    vars N M : Nat . vars NeL NeL' : NeListNat . var L : ListNat .

    op .MSetNat :                 -> MSetNat [ctor] .
    op _,_      : MSetNat MSetNat -> MSetNat [assoc comm id: .MSetNat] .   ---- TODO: `ctor`?
    --------------------------------------------------------------------

    op list2mset : ListNat -> MSetNat .
    -----------------------------------
    eq list2mset(.ListNat)   = .MSetNat .
    eq list2mset(N)          = N .
    eq list2mset(NeL ; NeL') = list2mset(NeL) , list2mset(NeL') .

    op unsorted : ListNat -> Form{Bool} [ctor] .
    --------------------------------------------
    eq unsorted(N)         = ff                                 [variant] .
    eq unsorted(.ListNat)  = ff                                 [variant] .
    eq unsorted(N ; M ; L) = (M < N ?= true) /\ unsorted(M ; L) [variant] .

    --- eq unsorted(     n + m + 1 ; n     ) = tt [variant] .
    --- eq unsorted(l1 ; n + m + 1 ; n     ) = tt [variant] .
    --- eq unsorted(     n + m + 1 ; n ; l2) = tt [variant] .
    --- eq unsorted(l1 ; n + m + 1 ; n ; l2) = tt [variant] .
endfm

fmod FVP-NAT-LIST-SORT-PERMUTATION is
    including UNCONDITIONALIZE-FVP-BOOL
            + RENAMED-FVP-NARROWING-GRAPH .

    var N : NatP . var TL : TermList . var Q : Qid .

    eq #M = upModule('FVP-NAT-LIST-SORTING, true) .
    -----------------------------------------------

    op nat : NatP -> Term .
    -----------------------
    eq nat(0) = '0.Nat .
    eq nat(1) = '1.NzNat .
    eq nat(2) = '_+_['1.NzNat, '1.NzNat] .
    eq nat(3) = '_+_['1.NzNat, '1.NzNat, '1.NzNat] .
    eq nat(4) = '_+_['1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat] .
    eq nat(5) = '_+_['1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat] .
    eq nat(6) = '_+_['1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat] .
    eq nat(7) = '_+_['1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat] .
    eq nat(8) = '_+_['1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat] .
    eq nat(9) = '_+_['1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat, '1.NzNat] .

    op init : NatP -> Term .
    ------------------------
    eq init(0) = '`[_`]['_;_[nat(3), nat(4), nat(5)]] .
    eq init(1) = '`[_`]['_;_[nat(4), nat(3), nat(5)]] .
    eq init(2) = '`[_`]['_;_[nat(3), nat(4)]] .
    eq init(3) = '`[_`]['_;_[nat(4), nat(3)]] .
    eq init(4) = '`[_`]['_;_[nat(3), nat(6), nat(4), nat(5)]] .
    eq init(5) = '`[_`]['_;_[nat(3), nat(6), nat(9), nat(5)]] .
endfm

reduce nat(0) .
reduce nat(1) .
reduce nat(2) .
reduce nat(3) .
reduce nat(4) .

reduce wellFormed(#M, nat(0)) .
reduce wellFormed(#M, nat(1)) .
reduce wellFormed(#M, nat(2)) .
reduce wellFormed(#M, nat(3)) .
reduce wellFormed(#M, nat(4)) .

reduce wellFormed(#M, init(0)) .
reduce wellFormed(#M, init(1)) .
reduce wellFormed(#M, init(2)) .
reduce wellFormed(#M, init(3)) .
reduce wellFormed(#M, init(4)) .
reduce wellFormed(#M, init(5)) .

reduce step(state(init(0))) .
reduce step(state(init(1))) .
reduce step(state(init(2))) .
reduce step(state(init(3))) .
reduce step(state(init(4))) .
reduce step(state(init(5))) .

---(The properties we want to prove are:
 var S : MSet .

1. the invariant:

  l | list2mset(l) = S

which is parametric on S,

with itself as the set of initial states:

    [l ] | list2mset(l) = S

This shows that the multiset of elements in the list is always the same.

We would need to prove:
(i) subsumption, which is trivial, since it is the same set; and

(ii) the formula:

[l ] | list2mset(l) = S =>* < [l'] | list2mset(l') = S >

where <_> is the "stopwatch" operator with rule

 [l] => < [l] > .

2. There is no need to use the "stopwatch" operator for
the other property we want to prove, which is a
weak termination condition.

The set T of terminating states is:

[l] | unsorted(l) =/= tt

and the weak termination condition, saying that at the end the list
is sorted is:

[l] | \top =>* [l'] | unsorted(l') =/= tt

Note that to prove this formula it will be quite useful to:

a. use case analysis with the generating set for the sort List:

{nil,n,m ; l1}

b.  Note that  in the first two cases it will be quite easy to
     prove that subsumption works, because:

    b.1 the unsorted predicate is FVP
    b.2. unsorted(nil) = true has no unifiers
    b3. unsorted(n) = true has no unifiers.
)---
