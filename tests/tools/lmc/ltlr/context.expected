Warning: "full-maude27.maude", line 2715 (fmod VARIANT): didn't expect token }:
eq getTerms ( { T:Term , S:Substitution , NextVar:Nat } <---*HERE*
Warning: "full-maude27.maude", line 2715 (fmod VARIANT): no parse for statement
eq getTerms ({T:Term, S:Substitution, NextVar:Nat} | R:VariantTripleSet) =
    T:Term | getTerms (R:VariantTripleSet) .
Warning: "full-maude27.maude", line 2722 (fmod VARIANT): didn't expect token }:
eq getSubstitutions ( { T:Term , S:Substitution , NextVar:Nat } <---*HERE*
Warning: "full-maude27.maude", line 2722 (fmod VARIANT): no parse for statement
eq getSubstitutions ({T:Term, S:Substitution, NextVar:Nat} |
    R:VariantTripleSet) = S:Substitution | getSubstitutions (
    R:VariantTripleSet) .
Warning: "full-maude27.maude", line 3312 (fmod VARIANT-HANDLING): didn't expect
    token }:
eq toVariantTripleSet ( { T , S , S' , NextVar } | VTS ) = { T , S , NextVar }
    <---*HERE*
Warning: "full-maude27.maude", line 3310 (fmod VARIANT-HANDLING): no parse for
    statement
eq toVariantTripleSet ({T, S, S', NextVar} | VTS) = {T, S, NextVar} |
    toVariantTripleSet (VTS) .
Warning: "full-maude27.maude", line 3864 (fmod META-E-UNIFICATION): didn't
    expect token }:
eq getVariants***$ ( M , T , NextVar , VTS , N , { T2:Term , S:Substitution ,
    NV2:Nat } <---*HERE*
Warning: "full-maude27.maude", line 3864 (fmod META-E-UNIFICATION): no parse
    for statement
eq getVariants***$ (M, T, NextVar, VTS, N, {T2:Term, S:Substitution, NV2:Nat})
    = getVariants***$$ (M, T, NextVar, VTS, N, {T2:Term, S:Substitution,
    NV2:Nat}, split ({S:Substitution, NV2:Nat}, NextVar)) .
Warning: "full-maude27.maude", line 3870 (fmod META-E-UNIFICATION): didn't
    expect token }:
eq getVariants***$$ ( M , T , NextVar , VTS , N , { T2:Term , S:Substitution ,
    NV2:Nat } <---*HERE*
Warning: "full-maude27.maude", line 3869 (fmod META-E-UNIFICATION): no parse
    for statement
eq getVariants***$$ (M, T, NextVar, VTS, N, {T2:Term, S:Substitution, NV2:Nat},
    {S1:Substitution, S2:Substitution, NV2:Nat}) = getVariants*** (M, T,
    NextVar, VTS | {T2:Term, S1:Substitution, S2:Substitution, NV2:Nat}, N + 1)
    .
Warning: "full-maude27.maude", line 19462 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq makeVariantSet ( { T , Subst , Subst' , N } | VFS ) = { T , Subst , N }
    <---*HERE*
Warning: "full-maude27.maude", line 19462 (fmod MODULE-VARIANTS): no parse for
    statement
eq makeVariantSet ({T, Subst, Subst', N} | VFS) = {T, Subst, N} |
    makeVariantSet (VFS) .
Warning: "full-maude27.maude", line 19475 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getRlVariants ( M , ( { '<_> [ T ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19475 (fmod MODULE-VARIANTS): no parse for
    statement
eq getRlVariants (M, ({'<_> [T], Subst, N} | VtS), T', nil, AtS) = (rl getTerm
    (metaNormalize (M, T)) => getTerm (metaNormalize (M, _<<_ (T', Subst))) [
    AtS] .) getRlVariants (M, VtS, T', nil, AtS) .
Warning: "full-maude27.maude", line 19478 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getRlVariants ( M , ( { F [ T , TL ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19478 (fmod MODULE-VARIANTS): no parse for
    statement
eq getRlVariants (M, ({F [T, TL], Subst, N} | VtS), T', Cond, AtS) = (crl
    getTerm (metaNormalize (M, T)) => getTerm (metaNormalize (M, _<<_ (T',
    Subst))) if makeCond (TL, Cond, Subst) [AtS] .) getRlVariants (M, VtS, T',
    Cond, AtS) .
Warning: "full-maude27.maude", line 19483 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getEqVariants ( M , ( { '<_> [ T ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19483 (fmod MODULE-VARIANTS): no parse for
    statement
eq getEqVariants (M, ({'<_> [T], Subst, N} | VtS), T', nil, AtS) = (eq getTerm
    (metaNormalize (M, T)) = getTerm (metaNormalize (M, _<<_ (T', Subst))) [
    AtS] .) getEqVariants (M, VtS, T', nil, AtS) .
Warning: "full-maude27.maude", line 19486 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getEqVariants ( M , ( { F [ T , TL ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19486 (fmod MODULE-VARIANTS): no parse for
    statement
eq getEqVariants (M, ({F [T, TL], Subst, N} | VtS), T', Cond, AtS) = (ceq
    getTerm (metaNormalize (M, T)) = getTerm (metaNormalize (M, _<<_ (T',
    Subst))) if makeCond (TL, Cond, Subst) [AtS] .) getEqVariants (M, VtS, T',
    Cond, AtS) .
Warning: "full-maude27.maude", line 19657 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getVariants ( M , T , Subst | SubstS ) = { getTerm ( metaNormalize ( M , T
    << Subst ) ) , Subst , 0 } <---*HERE*
Warning: "full-maude27.maude", line 19656 (fmod MODULE-VARIANTS): no parse for
    statement
eq getVariants (M, T, Subst | SubstS) = {getTerm (metaNormalize (M, T <<
    Subst)), Subst, 0} | getVariants (M, T, SubstS) .
Warning: "full-maude27.maude", line 19658 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getVariants ( M , T , empty ) = { T , none , 0 } <---*HERE*
Warning: "full-maude27.maude", line 19658 (fmod MODULE-VARIANTS): no parse for
    statement
eq getVariants (M, T, empty) = {T, none, 0} .

	    Full Maude 2.7 June 18th 2014


	    LTLR Fairness Model Checker December 10th 2011

Introduced module POSITION-MODEL-PRED

ModelChecker: a system graph may compute only state propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the NDFS algorithm with a Buchi automaton (1 states).
ModelChecker: Examined 14 system states and 19 transitions.
ltlr model check in POSITION-MODEL-PRED :
  [2] |= <> reach(b)
result ModelCheckResult :
  counterexample(
{ f(f(a,a),f(a,a)),{'tob} }
{ f(f(b,a),f(a,a)),{'tob} }
{ f(b,f(a,a)),{'toa} }
{ f(a,f(a,a)),{'tob} },
{ f(a,f(b,a)),{'tob} }
{ f(b,f(b,a)),{'toa} })

ModelChecker: a system graph may compute state, event, and enabled
    propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the Streett algorithm with a gen-Buchi automaton (1 states).
ModelChecker: Examined 4 system states and 4 transitions.
ltlr model check in POSITION-MODEL-PRED :
  [2] |= <> reach(b)
under fairness :
  fair({'tob})
result ModelCheckResult :
  counterexample(nil,
{ f(f(a,a),f(a,a)),{f(f([],a),f(a,a))| 'tob} }
{ f(f(b,a),f(a,a)),{f(f([],a),f(a,a))| 'toa} })

ModelChecker: a system graph may compute state, event, and enabled
    propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the Streett algorithm with a gen-Buchi automaton (1 states).
ModelChecker: Examined 17 system states and 26 transitions.
ltlr model check in POSITION-MODEL-PRED :
  [2] |= <> reach(b)
under fairness :
  fair(pos('tob,P:Pos))
result ModelCheckResult :
  counterexample(
{ f(f(a,a),f(a,a)),{f(f([],a),f(a,a))| 'tob} }
{ f(f(b,a),f(a,a)),{f(f(b,[]),f(a,a))| 'tob} }
{ f(b,f(a,a)),{f([],f(a,a))| 'toa} }
{ f(a,f(a,a)),{f(a,f([],a))| 'tob} }
{ f(a,f(b,a)),{f(a,f(b,[]))| 'tob} },
{ f(a,b),{f(a,[])| 'toa} }
{ f(a,a),{f([],a)| 'tob} }
{ f(b,a),{f([],a)| 'toa} }
{ f(a,a),{f(a,[])| 'tob} })

ModelChecker: a system graph may compute state, event, and enabled
    propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the Streett algorithm with a gen-Buchi automaton (1 states).
ModelChecker: Examined 25 system states and 78 transitions.
ltlr model check in POSITION-MODEL-PRED :
  [2] |= <> reach(b)
under fairness :
  fair({CXT:StateContext | 'tob})
result Bool :
  true

Bye.
