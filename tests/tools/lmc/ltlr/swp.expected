Warning: "full-maude27.maude", line 2715 (fmod VARIANT): didn't expect token }:
eq getTerms ( { T:Term , S:Substitution , NextVar:Nat } <---*HERE*
Warning: "full-maude27.maude", line 2715 (fmod VARIANT): no parse for statement
eq getTerms ({T:Term, S:Substitution, NextVar:Nat} | R:VariantTripleSet) =
    T:Term | getTerms (R:VariantTripleSet) .
Warning: "full-maude27.maude", line 2722 (fmod VARIANT): didn't expect token }:
eq getSubstitutions ( { T:Term , S:Substitution , NextVar:Nat } <---*HERE*
Warning: "full-maude27.maude", line 2722 (fmod VARIANT): no parse for statement
eq getSubstitutions ({T:Term, S:Substitution, NextVar:Nat} |
    R:VariantTripleSet) = S:Substitution | getSubstitutions (
    R:VariantTripleSet) .
Warning: "full-maude27.maude", line 3312 (fmod VARIANT-HANDLING): didn't expect
    token }:
eq toVariantTripleSet ( { T , S , S' , NextVar } | VTS ) = { T , S , NextVar }
    <---*HERE*
Warning: "full-maude27.maude", line 3310 (fmod VARIANT-HANDLING): no parse for
    statement
eq toVariantTripleSet ({T, S, S', NextVar} | VTS) = {T, S, NextVar} |
    toVariantTripleSet (VTS) .
Warning: "full-maude27.maude", line 3864 (fmod META-E-UNIFICATION): didn't
    expect token }:
eq getVariants***$ ( M , T , NextVar , VTS , N , { T2:Term , S:Substitution ,
    NV2:Nat } <---*HERE*
Warning: "full-maude27.maude", line 3864 (fmod META-E-UNIFICATION): no parse
    for statement
eq getVariants***$ (M, T, NextVar, VTS, N, {T2:Term, S:Substitution, NV2:Nat})
    = getVariants***$$ (M, T, NextVar, VTS, N, {T2:Term, S:Substitution,
    NV2:Nat}, split ({S:Substitution, NV2:Nat}, NextVar)) .
Warning: "full-maude27.maude", line 3870 (fmod META-E-UNIFICATION): didn't
    expect token }:
eq getVariants***$$ ( M , T , NextVar , VTS , N , { T2:Term , S:Substitution ,
    NV2:Nat } <---*HERE*
Warning: "full-maude27.maude", line 3869 (fmod META-E-UNIFICATION): no parse
    for statement
eq getVariants***$$ (M, T, NextVar, VTS, N, {T2:Term, S:Substitution, NV2:Nat},
    {S1:Substitution, S2:Substitution, NV2:Nat}) = getVariants*** (M, T,
    NextVar, VTS | {T2:Term, S1:Substitution, S2:Substitution, NV2:Nat}, N + 1)
    .
Warning: "full-maude27.maude", line 19462 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq makeVariantSet ( { T , Subst , Subst' , N } | VFS ) = { T , Subst , N }
    <---*HERE*
Warning: "full-maude27.maude", line 19462 (fmod MODULE-VARIANTS): no parse for
    statement
eq makeVariantSet ({T, Subst, Subst', N} | VFS) = {T, Subst, N} |
    makeVariantSet (VFS) .
Warning: "full-maude27.maude", line 19475 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getRlVariants ( M , ( { '<_> [ T ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19475 (fmod MODULE-VARIANTS): no parse for
    statement
eq getRlVariants (M, ({'<_> [T], Subst, N} | VtS), T', nil, AtS) = (rl getTerm
    (metaNormalize (M, T)) => getTerm (metaNormalize (M, _<<_ (T', Subst))) [
    AtS] .) getRlVariants (M, VtS, T', nil, AtS) .
Warning: "full-maude27.maude", line 19478 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getRlVariants ( M , ( { F [ T , TL ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19478 (fmod MODULE-VARIANTS): no parse for
    statement
eq getRlVariants (M, ({F [T, TL], Subst, N} | VtS), T', Cond, AtS) = (crl
    getTerm (metaNormalize (M, T)) => getTerm (metaNormalize (M, _<<_ (T',
    Subst))) if makeCond (TL, Cond, Subst) [AtS] .) getRlVariants (M, VtS, T',
    Cond, AtS) .
Warning: "full-maude27.maude", line 19483 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getEqVariants ( M , ( { '<_> [ T ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19483 (fmod MODULE-VARIANTS): no parse for
    statement
eq getEqVariants (M, ({'<_> [T], Subst, N} | VtS), T', nil, AtS) = (eq getTerm
    (metaNormalize (M, T)) = getTerm (metaNormalize (M, _<<_ (T', Subst))) [
    AtS] .) getEqVariants (M, VtS, T', nil, AtS) .
Warning: "full-maude27.maude", line 19486 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getEqVariants ( M , ( { F [ T , TL ] , Subst , N } <---*HERE*
Warning: "full-maude27.maude", line 19486 (fmod MODULE-VARIANTS): no parse for
    statement
eq getEqVariants (M, ({F [T, TL], Subst, N} | VtS), T', Cond, AtS) = (ceq
    getTerm (metaNormalize (M, T)) = getTerm (metaNormalize (M, _<<_ (T',
    Subst))) if makeCond (TL, Cond, Subst) [AtS] .) getEqVariants (M, VtS, T',
    Cond, AtS) .
Warning: "full-maude27.maude", line 19657 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getVariants ( M , T , Subst | SubstS ) = { getTerm ( metaNormalize ( M , T
    << Subst ) ) , Subst , 0 } <---*HERE*
Warning: "full-maude27.maude", line 19656 (fmod MODULE-VARIANTS): no parse for
    statement
eq getVariants (M, T, Subst | SubstS) = {getTerm (metaNormalize (M, T <<
    Subst)), Subst, 0} | getVariants (M, T, SubstS) .
Warning: "full-maude27.maude", line 19658 (fmod MODULE-VARIANTS): didn't expect
    token }:
eq getVariants ( M , T , empty ) = { T , none , 0 } <---*HERE*
Warning: "full-maude27.maude", line 19658 (fmod MODULE-VARIANTS): no parse for
    statement
eq getVariants (M, T, empty) = {T, none, 0} .

	    Full Maude 2.7 June 18th 2014


	    LTLR Fairness Model Checker December 10th 2011

Introduced module SLIDING-WINDOW-ABSTRACTION-CHECK

ModelChecker: a system graph may compute only state propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the NDFS algorithm with a Buchi automaton (2 states).
ModelChecker: Examined 1780 system states and 12045 transitions.
ltlr model check in SLIDING-WINDOW-ABSTRACTION-CHECK :
  initial(1,4) |= [](S-correct(p)/\ S-correct(q)/\ S>=A'(p)/\ S>=A'(q)/\
    recv-correct(p)/\ recv-correct(q)/\ ~ wrong-data-in-fifo(p)/\ ~
    wrong-data-in-fifo(q))
result Bool :
  true

ModelChecker: a system graph may compute only state propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the NDFS algorithm with a Buchi automaton (1 states).
ModelChecker: Examined 113 system states and 226 transitions.
ltlr model check in SLIDING-WINDOW-ABSTRACTION-CHECK :
  initial(1,3) |= <> success
result ModelCheckResult :
  counterexample(
{ [p : 0,0,1,1,[0,'C];[1,'B];[2,'A],empty,empty]&[q : 0,0,1,1,[0,'X];[1,'Y];[2,
    'Z],empty,empty],{'send} }
{ [p : 0,0,1,1,[0,'C];[1,'B];[2,'A],empty,[0,'X]]&[q : 0,0,1,1,[0,'X];[1,'Y];[
    2,'Z],empty,empty],{'send} }
{ [p : 0,0,1,1,[0,'C];[1,'B];[2,'A],empty,[0,'X]]&[q : 0,0,1,1,[0,'X];[1,'Y];[
    2,'Z],empty,[0,'C]],{'recv} }
{ [p : 1,0,1,1,[0,'C];[1,'B];[2,'A],[0,'X],empty]&[q : 0,0,1,1,[0,'X];[1,'Y];[
    2,'Z],empty,[0,'C]],{'send} }
{ [p : 1,0,1,1,[0,'C];[1,'B];[2,'A],[0,'X],[0,'X]]&[q : 0,0,1,1,[0,'X];[1,'Y];[
    2,'Z],empty,[0,'C]],{'send} }
{ [p : 1,0,1,1,[0,'C];[1,'B];[2,'A],[0,'X],[0,'X]]&[q : 0,0,1,1,[0,'X];[1,'Y];[
    2,'Z],empty,[0,'C];[1,'B]],{'recv} }
{ [p : 1,0,1,1,[0,'C];[1,'B];[2,'A],[0,'X],[0,'X]]&[q : 1,0,1,1,[0,'X];[1,'Y];[
    2,'Z],[0,'C],[1,'B]],{'send} }
{ [p : 1,0,1,1,[0,'C];[1,'B];[2,'A],[0,'X],[0,'X];[1,'Y]]&[q : 1,0,1,1,[0,'X];[
    1,'Y];[2,'Z],[0,'C],[1,'B]],{'send} }
{ [p : 1,0,1,1,[0,'C];[1,'B];[2,'A],[0,'X],[0,'X];[1,'Y]]&[q : 1,0,1,1,[0,'X];[
    1,'Y];[2,'Z],[0,'C],[0,'C];[1,'B]],{'recv} }
{ [p : 1,0,1,1,[0,'C];[1,'B];[2,'A],[0,'X],[1,'Y]]&[q : 1,0,1,1,[0,'X];[1,'Y];[
    2,'Z],[0,'C],[0,'C];[1,'B]],{'recv} }
{ [p : 2,1,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y],empty]&[q : 1,0,1,1,[0,'X];[
    1,'Y];[2,'Z],[0,'C],[0,'C];[1,'B]],{'send} }
{ [p : 2,1,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y],empty]&[q : 1,0,1,1,[0,'X];[
    1,'Y];[2,'Z],[0,'C],[0,'C];[1,'B];[2,'A]],{'send} }
{ [p : 2,1,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y],[1,'Y]]&[q : 1,0,1,1,[0,'X];[
    1,'Y];[2,'Z],[0,'C],[0,'C];[1,'B];[2,'A]],{'recv} }
{ [p : 2,1,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y],[1,'Y]]&[q : 1,0,1,1,[0,'X];[
    1,'Y];[2,'Z],[0,'C],[1,'B];[2,'A]],{'recv} }
{ [p : 2,1,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y],[1,'Y]]&[q : 2,1,1,1,[0,'X];[
    1,'Y];[2,'Z],[0,'C];[1,'B],[2,'A]],{'send} }
{ [p : 2,1,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y],[1,'Y];[2,'Z]]&[q : 2,1,1,1,[
    0,'X];[1,'Y];[2,'Z],[0,'C];[1,'B],[2,'A]],{'recv} }
{ [p : 3,2,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y];[2,'Z],[1,'Y]]&[q : 2,1,1,1,[
    0,'X];[1,'Y];[2,'Z],[0,'C];[1,'B],[2,'A]],{'send} }
{ [p : 3,2,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y];[2,'Z],[1,'Y];[2,'Z]]&[q : 2,
    1,1,1,[0,'X];[1,'Y];[2,'Z],[0,'C];[1,'B],[2,'A]],{'loss} },
{ [p : 3,2,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y];[2,'Z],[1,'Y];[2,'Z]]&[q : 2,
    1,1,1,[0,'X];[1,'Y];[2,'Z],[0,'C];[1,'B],empty],{'recv} }
{ [p : 3,2,1,1,[0,'C];[1,'B];[2,'A],[0,'X];[1,'Y];[2,'Z],[2,'Z]]&[q : 2,1,1,1,[
    0,'X];[1,'Y];[2,'Z],[0,'C];[1,'B],empty],{'send} })

ModelChecker: a system graph may compute state, event, and enabled
    propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the Streett algorithm with a gen-Buchi automaton (1 states).
ModelChecker: Examined 420 system states and 4232 transitions.
ltlr model check in SLIDING-WINDOW-ABSTRACTION-CHECK :
  initial(1,3) |= <> success
under fairness :
  just(send(P:Pid,I:Nat,W:Qid)); fair(recv(P:Pid,I:Nat,W:Qid))
result Bool :
  true

ModelChecker: a system graph may compute state, event, and enabled
    propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the Streett algorithm with a gen-Buchi automaton (1 states).
ModelChecker: Examined 420 system states and 4232 transitions.
ltlr model check under localized fairness in SLIDING-WINDOW-ABSTRACTION-CHECK :
  initial(1,3) |= <> success
result Bool :
  true

ModelChecker: a system graph may compute state, event, and enabled
    propositions..
ModelChecker: LTL model checking with a state-based algorithm.
ModelChecker: Use the Streett algorithm with a gen-Buchi automaton (1 states).
ModelChecker: Examined 32256 system states and 596122 transitions.
ltlr model check under localized fairness in SLIDING-WINDOW-ABSTRACTION-CHECK :
  initial(2,5) |= <> success
result Bool :
  true

Bye.
