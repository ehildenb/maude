load ../../../../contrib/systems/bakery.maude
load ../../../../contrib/tools/lmc/symbolic-interface.maude

--- Atomic propositions for whether any processes are waiting/critical
--- ------------------------------------------------------------------

--- prop definitions for bakery
(mod BAKERY-SATISFACTION1 is
  pr BAKERY .
  pr SYMBOLIC-CHECKER .

  subsort Conf < State .

  ops ever-wait? ever-crit? : -> Prop .

  vars N M : Name . vars PS : ProcSet .

  eq s N ; M   ; PS |= ever-wait? = true  [variant] .
  eq 0   ; M   ; PS |= ever-wait? = false [variant] .
  eq N   ; s M ; PS |= ever-crit? = true  [variant] .
  eq N   ; 0   ; PS |= ever-crit? = false [variant] .
endm)

set verbose on .

*** true
(lfmc N ; N ; [idle] [idle] |= [] (ever-wait? -> <> ever-crit?) .)

*** deadlock counterexample
(lfmc N ; M ; IS:ProcIdleSet |= [] (ever-wait? -> <> ever-crit?) .)

*** spurious counterexample
(lfmc N ; M ; WS:ProcWaitSet |= [] (ever-wait? -> <> ever-crit?) .)

--- Atomic propositions for mutual exclusion
--- ----------------------------------------

(mod BAKERY-SATISFACTION2 is
  pr BAKERY .
  pr SYMBOLIC-CHECKER .

  subsort Conf < State .

  ops ex? ini : -> Prop .

  var WS : ProcWaitSet . var IS : ProcIdleSet . var PS : ProcSet .
  vars N M M1 M2 : Name .

--- NOTE: ProcIdleSet < ProcWaitSet
  eq N ; M ; WS                       |= ex? = true  [variant] .
  eq N ; M ; [crit(M1)] WS            |= ex? = true  [variant] .
  eq N ; M ; [crit(M1)] [crit(M2)] PS |= ex? = false [variant] .
endm)

*** no counterexample
(lmc [10] N:Name ; N:Name ; [idle] [idle] |= [] ex? .)

*** true
(lfmc N:Name ; N:Name ; [idle] [idle] |= [] ex? .)

*** false
(lfmc N ; M ; WS |= [] ex?  .)

*** false (infinite graph, but a counterexample exists)
(lfmc N ; N ; WS |= [] ex?  .)

--- Equational abstraction: extra waiting processes mean nothing
--- ------------------------------------------------------------

(mod BAKERY-SATISFACTION2-ABS is
  pr BAKERY-SATISFACTION2 .

  var PS : ProcSet .  vars N M L : Name . var IS : ProcIdleSet .

--- bisimilar equational abstraction
  eq s s s N M ; M ; PS [wait(s N M)] [wait(s s N M)]
   =   s s N M ; M ; PS [wait(s N M)]
  [variant] .
endm)

*** true
(lfmc N ; N ; IS |= [] ex?  .)
