load ../../../contrib/systems/thermostat.maude
load ../../../contrib/tools/lmc/lgraph-search.maude
load ../../../contrib/tools/meta/variables.maude

set include BOOL off .

mod THERMOSTAT-NARROWING-GRAPH is
   protecting NAT .
    extending CONDITIONAL-NARROWING-GRAPH + GRAPH-ANALYSIS .
    extending UNCONDITIONALIZE-FVP-BOOL .

    vars N M : Nat . var L : Label .
    vars TMP T T' C : Term . var TS : TermSet . vars NeTS NeTS' : NeTermSet .
    var SUB : Substitution . vars RL Q : Qid . vars V V' : Variant . var VS : VariantSet .
    var P : Parent . var B : Bool .

    eq #tSort = 'Conf .
    eq #MO    = upModule('THERMOSTAT-INT-COMFORTABLE, true) .

   ceq prune(< label(RL, SUB) , state(Q[T, C]) >) = .TransitionSet if Q = #cTerm /\ isUnsat(C) .

    op isUnsat : Term -> [Bool] .
    -----------------------------
   ceq isUnsat(T) = false                       if T == #cTrue .
   ceq isUnsat(T) = true                        if T == #cFalse .
   ceq isUnsat(T) = filterFalse(TS) == .TermSet if not T == #cTrue /\ not T == #cFalse
                                                /\ TS := getTerms(filterRenaming(variants(#M, renameTmpVar(#M, T)))) .

    op filterFalse : TermSet -> [TermSet] .
    ---------------------------------------
    eq filterFalse(T) = if T == #cFalse then .TermSet else T fi .

    eq filterFalse(.TermSet)     = .TermSet .
    eq filterFalse(NeTS | NeTS') = filterFalse(NeTS) | filterFalse(NeTS') .

    op 20 : -> Term .
    -----------------
    eq 20 = '_+_['10.NzNat, '10.NzNat] .

   ops lt le : Term Term -> [Term] .
   ---------------------------------
    eq lt(T, T') = '_?=_['_<_[T, T'], 'true.Bool] .
    eq le(T, T') = '_?=_['_<=_[T, T'], 'true.Bool] .

    op init : Nat Term -> [Term] .
    ------------------------------
    eq init(0, TMP) = '`{_`,_`,_`}[ '0.Nat , TMP , 'on.InMode          ] .
    eq init(1, TMP) = '`{_`,_`,_`}[ '0.Nat , TMP , 'off.InMode         ] .
    eq init(2, TMP) = '`{_`,_`,_`}[ '0.Nat , TMP , 'delay['off.InMode] ] .
    eq init(3, TMP) = '`{_`,_`,_`}[ '0.Nat , TMP , 'delay['on.InMode]  ] .

    eq init(4, TMP) = '`{_`,_`,_`}[ 'TIME:Nat , TMP , 'IM:InMode    ] .
    eq init(5, TMP) = '`{_`,_`,_`}[ 'TIME:Nat , TMP , 'DM:DelayMode ] .
    eq init(6, TMP) = '`{_`,_`,_`}[ 'TIME:Nat , TMP , 'M:Mode       ] .

    eq init(7, TMP) = '`{_`,_`,_`}['_+_['1.NzNat,'1.NzNat],'_+_[20,'1.NzNat,'1.NzNat,TMP],'delay['off.InMode]] .

    op cond : Nat Term -> [Term] .
    ------------------------------
    eq cond(0, TMP) = '_/\_[lt('min.Nat, TMP), lt(TMP, 'max.Nat)] .

    eq cond(1, TMP) = '_/\_[lt(TMP,'_+_['1.NzNat,'1.NzNat,'1.NzNat,'1.NzNat,'1.NzNat])
                           ,le('_+_['1.NzNat,'1.NzNat,'1.NzNat,TMP],'_+_['1.NzNat,'1.NzNat,'1.NzNat,'1.NzNat,'1.NzNat,'1.NzNat])] .

    eq cond(2, TMP) = '_/\_[lt(TMP, 20), lt(20, TMP)] .

    op cinit : Nat Nat Term -> [Term] .
    -----------------------------------
    eq cinit(N, M, T) = '_st_[init(N, T), cond(M, T)] .
endm

reduce wellFormed(#M, init(0, 20)) .
reduce wellFormed(#M, init(1, 20)) .
reduce wellFormed(#M, init(2, 20)) .
reduce wellFormed(#M, init(3, 20)) .
reduce wellFormed(#M, init(4, 20)) .
reduce wellFormed(#M, init(5, 20)) .
reduce wellFormed(#M, init(6, 20)) .

reduce wellFormed(#M, cond(0, 'TMP:Nat)) .
reduce wellFormed(#M, cond(0, '_+_['TMP:Nat, '1.NzNat])) .

reduce wellFormed(#M, cinit(0, 0, 'TMP:Nat)) .
reduce wellFormed(#M, cinit(1, 0, '_+_['TMP:Nat, '1.NzNat])) .

reduce isUnsat(cond(0, 'TMP:Nat)) .
reduce isUnsat(cond(2, 'TMP:Nat)) .

reduce step(state(cinit(0,0,'TMP:Nat))) .

reduce bfs(state(cinit(0,0,20)), 5) .
reduce bfs(state(cinit(0,0,'TMP:Nat)), 1) .
reduce bfs(state(cinit(0,1,'TMP:Nat)), 2) .

reduce state(init(0, 20)) <= state(init(4, 20)) .
reduce state(init(2, 20)) <= state(init(4, 20)) .
