load ../../../contrib/systems/thermostat.maude
load ../../../contrib/tools/lmc/lgraph-search.maude
load ../../../contrib/tools/meta/variables.maude

set include BOOL off .

--- ### Thermostat Search Instantiation

mod THERMOSTAT-COMMON-INIT is
   protecting META-TERM .
   protecting RENAME-METAVARS .
    extending CONDITIONAL-NARROWING-GRAPH + FOLDING-LABELED-GRAPH-SEARCH .

    vars TIME TMP TMP' TMP'' T C : Term .
    vars RL Q : Qid . var SUB : Substitution .

    op #nSort : -> Qid .
    op #nTrue : -> Qid .
    --------------------

--- In all cases, the top-sort of the Thermostat parameterized module will be `Conf`, which we instantiate here.

    eq #tSort = 'Conf .
    -------------------

--- Operators `lt`, `le`, `min`, `max`, and `inRange` are macros for specifying meta-level side-conditions compactly/easily for this theory.

   ops lt le : Term Term -> [Term] .
   ---------------------------------
    eq lt(TMP, TMP') = '_?=_[ '_<_[TMP, TMP'], #nTrue] .
    eq le(TMP, TMP') = '_?=_['_<=_[TMP, TMP'], #nTrue] .

   ops min max : -> Term .
   -----------------------
    eq min = qid("min." + string(#nSort)) .
    eq max = qid("max." + string(#nSort)) .

    op inRange : Term Term Term -> [Term] .
    ---------------------------------------
    eq inRange(TMP, TMP', TMP'') = #cConjunct[le(TMP', TMP), le(TMP, TMP'')] .

--- These states capture "good" and "bad" states for the thermostat; `goodConf` has the temperature within bounds, while `badConf` has the temperature out of bounds.

    op goodConf : -> [Term] .
    op  badConf : -> [Term] .
    -------------------------
    eq goodConf = #cTerm['`{_`,_`,_`}[qid("T:" + string(#nSort)) , qid("TMP:" + string(#nSort)) , 'off.Mode ],     inRange(qid("TMP:" + string(#nSort)), min, max)] .
    eq badConf  = #cTerm['`{_`,_`,_`}[qid("T:" + string(#nSort)) , qid("TMP:" + string(#nSort)) , 'M:Mode   ], '~_[inRange(qid("TMP:" + string(#nSort)), min, max)]] .

--- **TODO**: Move this equation to somewhere more generic.
--- In order to take advantage of our ability to prune infeasible states, we extend the definition of `prune` to check if the side-condition is unsatisfiable.
--- For a specific theory, one can specify `isUnsat` so that it simplifies to `true` if you can prove infeasibility.

   ceq prune(< label(RL, SUB) , state(Q[T, C]) >) = .TransitionSet if Q = #cTerm /\ isUnsat(C) .
   ---------------------------------------------------------------------------------------------

    op isUnsat : Term -> [Bool] .
    -----------------------------
endm

--- ### Thermostat Search modulo FVP-INT

--- By importing `UNCONDITIONALIZE-FVP-BOOL`, we already have the relevant instantiation for the `FVP-BOOL` side-condition theory.
--- In addition, we tell the tool that the top sort in the original theory `#MO` is `Conf`.

mod THERMOSTAT-INT-NARROWING-GRAPH is
    extending THERMOSTAT-COMMON-INIT .
    extending UNCONDITIONALIZE-FVP-BOOL .

    var T : Term . var TS : TermSet . vars NeTS NeTS' : NeTermSet .
    vars V V' : Variant . var VS : VariantSet .
    var N : Nat . var P : Parent . var B : Bool . var SUB : Substitution .

    eq #nSort = 'Int .
    eq #nTrue = 'true.Bool .
    ------------------------

    eq #MO = upModule('THERMOSTAT-INT-COMFORTABLE, true) .
    ------------------------------------------------------

--- Here we check that a given constraint `isUnsat` by generating variants and checking whether they are all false or exactly a renaming.
--- **TODO**: Invoke varsat.

   ceq isUnsat(T) = false                       if T == #cTrue .
   ceq isUnsat(T) = true                        if T == #cFalse .
   ceq isUnsat(T) = filterFalse(TS) == .TermSet if not T == #cTrue /\ not T == #cFalse
                                                /\ TS := getTerms(filterRenaming(variants(#M, renameTmpVar(#M, T)))) .
   -------------------------------------------------------------------------------------------------------------------

    op filterFalse : TermSet -> [TermSet] .
    ---------------------------------------
    eq filterFalse(T) = if T == #cFalse then .TermSet else T fi .

    eq filterFalse(.TermSet)     = .TermSet .
    eq filterFalse(NeTS | NeTS') = filterFalse(NeTS) | filterFalse(NeTS') .
endm

reduce wellFormed(#M) .
reduce wellFormed(#M, goodConf) .
reduce wellFormed(#M, badConf) .

reduce bfs(state(goodConf), 2) .
reduce state(goodConf) =>[5] state(badConf) .

--- ### Thermostat Search modulo REAL

view Boolean from TRIV to REAL is sort Elt to Boolean . endv

fmod EQFORM-SMT-BOOLEAN is
   protecting EQFORM-IMPL{Boolean} + REAL .
   protecting META-LEVEL * ( sort Nat to NatP
                           , op _+_             to _+P_
                           , op _=/=_           to _=/=P_
                           , op _==_            to _==P_
                           , op if_then_else_fi to if_then_else_fiP
                           , op min             to minP
                           , op max             to maxP
                           , op sd              to sdP
                           ) .

    vars NTFB NTFB' : NoTrueForm{Boolean} . vars NFFB NFFB' : NoFalseForm{Boolean} .
    vars FB FB' : Form{Boolean} . vars B B' : Boolean .

--- **TODO**: `git log` indicates that the behaviour of `metaCheck` is that { sat } => true { unsat unknown } => false.
---           This could make this simplification unsound in the case of `{ unknown } => false`

    op simplify : Form{Boolean} -> Form{Boolean} .
    ----------------------------------------------
    eq simplify(FB) = FB [owise] .
   ceq simplify(FB) = tt if B := toBoolean(~ FB) /\ false = metaCheck(upModule('REAL, true), upTerm(B)) .
   ceq simplify(FB) = ff if B := toBoolean(  FB) /\ false = metaCheck(upModule('REAL, true), upTerm(B)) .

    op toBoolean : Form{Boolean} -> Boolean .
    -----------------------------------------
    eq toBoolean(B ?= B') = B  === B' .
    eq toBoolean(B != B') = B =/== B' .
    eq toBoolean(~ FB)    = not toBoolean(FB) .

    eq toBoolean(NTFB /\ NTFB') = toBoolean(NTFB) and toBoolean(NTFB') .
    eq toBoolean(NTFB /\ NTFB') = toBoolean(NTFB) and toBoolean(NTFB') .
    eq toBoolean(NFFB \/ NFFB') = toBoolean(NFFB) or  toBoolean(NFFB') .
    eq toBoolean(NFFB \/ NFFB') = toBoolean(NFFB) or  toBoolean(NFFB') .

    eq toBoolean(FB => FB') = toBoolean(FB) implies toBoolean(FB') .
endfm

reduce simplify(false ?= 0/1 < 1/1) .
reduce simplify(true  ?= 0/1 < 1/1) .

reduce simplify((true ?= X:Real <= Y:Real) => (true ?= X:Real <  Y:Real)) .
reduce simplify((true ?= X:Real <  Y:Real) => (true ?= X:Real <= Y:Real)) .

reduce simplify((true ?= X:Real <= Y:Real) => (true ?= X:Real <= (Y:Real + 2/1))) .

--- For the real-numbered thermostat, we instantiat the parameter theory `#cModule` to `EQFORM-SMT-BOOLEAN` instead.
--- The top sort of the module remains the same (`Conf`), as it comes from the same parametric theory.

fmod UNCONDITIONALIZE-REAL is
   protecting DETERMINISTIC-VARIABLES .
    including UNCONDITIONALIZE .

    vars T T' : Term . var S : Sort . vars EqC EqC' : EqCondition .

    eq #cModule   = 'EQFORM-SMT-BOOLEAN .
    eq #cSort     = 'Form`{Boolean`} .
    eq #cTrue     = 'tt.TrueLit`{Boolean`} .
    eq #cFalse    = 'ff.FalseLit`{Boolean`} .
    eq #cConjunct = '_/\_ .
    -----------------------

    eq #mkCondition(T  = T') = '_?=_[T, T'] .
    eq #mkCondition(T := T') = '_?=_[T, T'] .
    eq #mkCondition(T : S)   = '_?=_[T, #var(T, S)] .
    -------------------------------------------------
endfm

mod THERMOSTAT-REAL-NARROWING-GRAPH is
    including UNCONDITIONALIZE-REAL .
    including THERMOSTAT-COMMON-INIT .

    vars T T' : Term . var TYPE : Type .

    eq #nSort = 'Real .
    eq #nTrue = 'true.Boolean .
    ---------------------------

    eq #MO = upModule('THERMOSTAT-REAL-COMFORTABLE, true) .
    -------------------------------------------------------

--- For the real numbers, we check `isUnsat` via Maude's meta-level hookup to an SMT solver.

   ceq isUnsat(T) = T' == #cFalse if { T' , TYPE } := metaReduce(upModule(#cModule, true), 'simplify[T]) .
   -------------------------------------------------------------------------------------------------------

   ceq implies?(T, T') = T' == #cTrue if { T' , TYPE } := metaReduce(upModule(#cModule, true), 'simplify['_=>_[T, T']]) .
   ----------------------------------------------------------------------------------------------------------------------
endm

reduce wellFormed(#M) .
reduce wellFormed(#M, goodConf) .
reduce wellFormed(#M, badConf) .

reduce isUnsat(lt('X:Real, 'Y:Real)) == false .
reduce isUnsat(lt('X:Real, 'X:Real)) == true .
reduce isUnsat(le('X:Real, 'Y:Real)) == false .
reduce isUnsat(le('X:Real, 'X:Real)) == false .

reduce isUnsat(#cConjunct[lt('X:Real, 'Y:Real), #cTrue]) == false .
reduce isUnsat(#cConjunct[lt('X:Real, 'X:Real), #cTrue]) == true .
reduce isUnsat(#cConjunct[le('X:Real, 'Y:Real), #cTrue]) == false .
reduce isUnsat(#cConjunct[le('X:Real, 'X:Real), #cTrue]) == false .

reduce isUnsat(#cConjunct[lt('X:Real, 'Y:Real), #cFalse]) == true .
reduce isUnsat(#cConjunct[lt('X:Real, 'X:Real), #cFalse]) == true .
reduce isUnsat(#cConjunct[le('X:Real, 'Y:Real), #cFalse]) == true .
reduce isUnsat(#cConjunct[le('X:Real, 'X:Real), #cFalse]) == true .

reduce isUnsat(#cConjunct[lt('X:Real, 'Y:Real), lt('Y:Real, 'X:Real)]) == true .
reduce isUnsat(#cConjunct[le('X:Real, 'Y:Real), le('Y:Real, 'X:Real)]) == false .

reduce implies?(lt('X:Real, 'Y:Real), le('X:Real, 'Y:Real)) .

reduce bfs(state(goodConf), 12) .
reduce state(goodConf) =>[5] state(badConf) .

--- ### Thermostat Search modulo REAL with RAT Concrete Represenattion

fmod EQFORM-RAT is protecting EQFORM-IMPL{Bool} + RAT . endfm

fmod UNCONDITIONALIZE-RAT is
   protecting DETERMINISTIC-VARIABLES .
    including UNCONDITIONALIZE .

    vars T T' : Term . var S : Sort . vars EqC EqC' : EqCondition .

    eq #cModule   = 'EQFORM-RAT .
    eq #cSort     = 'Form`{Bool`} .
    eq #cTrue     = 'tt.TrueLit`{Bool`} .
    eq #cFalse    = 'ff.FalseLit`{Bool`} .
    eq #cConjunct = '_/\_ .
    -----------------------

    eq #mkCondition(T  = T') = '_?=_[T, T'] .
    eq #mkCondition(T := T') = '_?=_[T, T'] .
    eq #mkCondition(T : S)   = '_?=_[T, #var(T, S)] .
    -------------------------------------------------
endfm

mod THERMOSTAT-RAT-NARROWING-GRAPH is
   protecting RAT-REAL-CONVERSION .
    including UNCONDITIONALIZE-RAT .
    including THERMOSTAT-COMMON-INIT .

    vars T T' : Term . var TYPE : Type .

    eq #nSort = 'Rat .
    eq #nTrue = 'true.Bool .
    ------------------------

    eq #MO = upModule('THERMOSTAT-RAT-COMFORTABLE, true) .
    ------------------------------------------------------

   ceq isUnsat(T) = T' == #cFalse if { T' , TYPE } := metaReduce(upModule('EQFORM-SMT-BOOLEAN, true), 'simplify[#Rat2Real(T)]) .
   -----------------------------------------------------------------------------------------------------------------------------

   ceq implies?(T, T') = T' == #cTrue if { T' , TYPE } := metaReduce(upModule('EQFORM-SMT-BOOLEAN, true), 'simplify['_=>_[#Rat2Real(T), #Rat2Real(T')]]) .
   -------------------------------------------------------------------------------------------------------------------------------------------------------
endm

reduce wellFormed(#M) .
reduce wellFormed(#M, goodConf) .
reduce wellFormed(#M, badConf) .

reduce isUnsat(lt('X:Rat, 'X:Rat)) == true .
reduce isUnsat(le('X:Rat, 'Y:Rat)) == false .
reduce isUnsat(le('X:Rat, 'X:Rat)) == false .

reduce isUnsat(#cConjunct[lt('X:Rat, 'Y:Rat), #cTrue]) == false .
reduce isUnsat(#cConjunct[lt('X:Rat, 'X:Rat), #cTrue]) == true .
reduce isUnsat(#cConjunct[le('X:Rat, 'Y:Rat), #cTrue]) == false .
reduce isUnsat(#cConjunct[le('X:Rat, 'X:Rat), #cTrue]) == false .

reduce isUnsat(#cConjunct[lt('X:Rat, 'Y:Rat), #cFalse]) == true .
reduce isUnsat(#cConjunct[lt('X:Rat, 'X:Rat), #cFalse]) == true .
reduce isUnsat(#cConjunct[le('X:Rat, 'Y:Rat), #cFalse]) == true .
reduce isUnsat(#cConjunct[le('X:Rat, 'X:Rat), #cFalse]) == true .

reduce isUnsat(#cConjunct[lt('X:Rat, 'Y:Rat), lt('Y:Rat, 'X:Rat)]) == true .
reduce isUnsat(#cConjunct[le('X:Rat, 'Y:Rat), le('Y:Rat, 'X:Rat)]) == false .

reduce implies?(lt('X:Real, 'Y:Real), le('X:Real, 'Y:Real)) .

reduce bfs(state(goodConf), 2) .
reduce state(goodConf) =>[5] state(badConf) .
