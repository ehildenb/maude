Warning: sort declarations for operator resolveNames failed preregularity check
    on 6 out of 39 sort tuples. First such tuple is (Type).
Warning: sort declarations for operator resolveNames failed preregularity check
    on 1 out of 28 sort tuples. First such tuple is (NullDeclSet).
==========================================
reduce in MODULE-CONSTRUCTION : forall sorts var<Sort>('X) . exists sorts
    var<Sort>('X) . .
rewrites: 6
result ModuleConstruction: .ModuleConstruction
==========================================
reduce in MODULE-CONSTRUCTION : FUNCTOR(var<Sort>('X), var<Sort>('X)) .
rewrites: 42
result ModuleConstruction: .ModuleConstruction
==========================================
reduce in MODULE-CONSTRUCTION : FUNCTOR(var<Sort>('X), 'F{var<Sort>('X)}) .
rewrites: 41
result NeModuleConstruction: forall sorts X . exists sorts 'F{X} .
; forall (sorts X ; X' ; 'F{X} ; 'F{X'} .)
subsort X < X' . exists subsort 'F{X} < 'F{X'} .
==========================================
reduce in MODULE-CONSTRUCTION : FUNCTOR(var<Sort>('X), ('F{var<Sort>('X)} < 'G{
    var<Sort>('X)})) .
rewrites: 79
result NeModuleConstruction: (forall sorts X . exists sorts 'F{X} .
; forall (sorts X ; X' ; 'F{X} ; 'F{X'} .)
subsort X < X' . exists subsort 'F{X} < 'F{X'} .
| forall sorts X . exists sorts 'G{X} .
; forall (sorts X ; X' ; 'G{X} ; 'G{X'} .)
subsort X < X' . exists subsort 'G{X} < 'G{X'} .)
; forall sorts 'F{X} ; 'G{X} . exists subsort 'F{X} < 'G{X} .
==========================================
reduce in MODULE-CONSTRUCTION : FUNCTOR(var<Sort>('X), (var<Sort>('X) < 'F{
    var<Sort>('X)} < 'G{var<Sort>('X)})) .
rewrites: 118
result NeModuleConstruction: (forall sorts X . exists sorts 'F{X} .
; forall (sorts X ; X' ; 'F{X} ; 'F{X'} .)
subsort X < X' . exists subsort 'F{X} < 'F{X'} .
| forall sorts X . exists sorts 'G{X} .
; forall (sorts X ; X' ; 'G{X} ; 'G{X'} .)
subsort X < X' . exists subsort 'G{X} < 'G{X'} .)
; forall sorts 'F{X} ; 'G{X} . exists subsort 'F{X} < 'G{X} .
; forall sorts X ; 'F{X} . exists subsort X < 'F{X} .
==========================================
reduce in MODULE-CONSTRUCTION : FUNCTOR(var<Sort>('X), (var<Sort>('X) < 'F{
    var<Sort>('X)} < 'G{var<Sort>('X)} < 'H{var<Sort>('X)})) .
rewrites: 156
result NeModuleConstruction: (forall sorts X . exists sorts 'F{X} .
; forall (sorts X ; X' ; 'F{X} ; 'F{X'} .)
subsort X < X' . exists subsort 'F{X} < 'F{X'} .
| (forall sorts X . exists sorts 'G{X} .
; forall (sorts X ; X' ; 'G{X} ; 'G{X'} .)
subsort X < X' . exists subsort 'G{X} < 'G{X'} .
| forall sorts X . exists sorts 'H{X} .
; forall (sorts X ; X' ; 'H{X} ; 'H{X'} .)
subsort X < X' . exists subsort 'H{X} < 'H{X'} .)
; forall sorts 'G{X} ; 'H{X} . exists subsort 'G{X} < 'H{X} .)
; forall sorts 'F{X} ; 'G{X} . exists subsort 'F{X} < 'G{X} .
; forall sorts X ; 'F{X} . exists subsort X < 'F{X} .
==========================================
reduce in MODULE-CONSTRUCTION : FUNCTOR(var<Sort>('X), var<Sort>('F){var<Sort>(
    'X)}) .
rewrites: 46
result NeModuleConstruction: forall sorts X . exists sorts F{X} .
; forall (sorts X ; X' ; F{X} ; F{X'} .)
subsort X < X' . exists subsort F{X} < F{X'} .
==========================================
reduce in MODULE-CONSTRUCTION : COFUNCTOR(var<Sort>('X), 'F{var<Sort>('X)}) .
rewrites: 41
result NeModuleConstruction: forall sorts X . exists sorts 'F{X} .
; forall (sorts X ; X' ; 'F{X} ; 'F{X'} .)
subsort X < X' . exists subsort 'F{X'} < 'F{X} .
==========================================
reduce in MODULE-CONSTRUCTION : COFUNCTOR(var<Sort>('X), ('F{var<Sort>('X)} <
    'G{var<Sort>('X)})) .
rewrites: 79
result NeModuleConstruction: (forall sorts X . exists sorts 'F{X} .
; forall (sorts X ; X' ; 'F{X} ; 'F{X'} .)
subsort X < X' . exists subsort 'F{X'} < 'F{X} .
| forall sorts X . exists sorts 'G{X} .
; forall (sorts X ; X' ; 'G{X} ; 'G{X'} .)
subsort X < X' . exists subsort 'G{X'} < 'G{X} .)
; forall sorts 'F{X} ; 'G{X} . exists subsort 'F{X} < 'G{X} .
==========================================
reduce in MODULE-CONSTRUCTION : COFUNCTOR(var<Sort>('X), ('F{var<Sort>('X)} <
    'G{var<Sort>('X)} < 'H{var<Sort>('X)})) .
rewrites: 117
result NeModuleConstruction: (forall sorts X . exists sorts 'F{X} .
; forall (sorts X ; X' ; 'F{X} ; 'F{X'} .)
subsort X < X' . exists subsort 'F{X'} < 'F{X} .
| (forall sorts X . exists sorts 'G{X} .
; forall (sorts X ; X' ; 'G{X} ; 'G{X'} .)
subsort X < X' . exists subsort 'G{X'} < 'G{X} .
| forall sorts X . exists sorts 'H{X} .
; forall (sorts X ; X' ; 'H{X} ; 'H{X'} .)
subsort X < X' . exists subsort 'H{X'} < 'H{X} .)
; forall sorts 'G{X} ; 'H{X} . exists subsort 'G{X} < 'H{X} .)
; forall sorts 'F{X} ; 'G{X} . exists subsort 'F{X} < 'G{X} .
==========================================
reduce in MODULE-CONSTRUCTION : COFUNCTOR(var<Sort>('X), var<Sort>('F){
    var<Sort>('X)}) .
rewrites: 46
result NeModuleConstruction: forall sorts X . exists sorts F{X} .
; forall (sorts X ; X' ; F{X} ; F{X'} .)
subsort X < X' . exists subsort F{X'} < F{X} .
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving FUNCTOR(
    var<Sort>('X), 'F{var<Sort>('X)}) .
Warning: sort declarations for operator resolveNames failed preregularity check
    on 6 out of 39 sort tuples. First such tuple is (Type).
Warning: sort declarations for operator resolveNames failed preregularity check
    on 1 out of 26 sort tuples. First such tuple is (NullDeclSet).
Warning: sort declarations for operator resolveNames failed preregularity check
    on 1 out of 26 sort tuples. First such tuple is (NullDeclSet).
Warning: sort declarations for operator resolveNames failed preregularity check
    on 6 out of 39 sort tuples. First such tuple is (Type).
rewrites: 138
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'F{'A} ; 'F{'B} .
  subsort 'A < 'B .
  subsort 'F{'A} < 'F{'B} .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving
    COFUNCTOR(var<Sort>('X), 'F{var<Sort>('X)}) .
rewrites: 138
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'F{'A} ; 'F{'B} .
  subsort 'A < 'B .
  subsort 'F{'B} < 'F{'A} .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving FUNCTOR(
    var<Sort>('X), 'F{var<Sort>('X)})
| COFUNCTOR(var<Sort>('X), 'G{var<Sort>('X)}) .
rewrites: 273
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'F{'A} ; 'F{'B} ; 'G{'A} ; 'G{'B} .
  subsort 'A < 'B .
  subsort 'F{'A} < 'F{'B} .
  subsort 'G{'B} < 'G{'A} .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving FUNCTOR(
    var<Sort>('X), 'F{var<Sort>('X)})
; COFUNCTOR(var<Sort>('X), 'G{var<Sort>('X)}) .
rewrites: 307
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'F{'A} ; 'F{'B} ; 'G{'A} ; 'G{'B} ; 'G{'F{'A}} ; 'G{'F{'B}} .
  subsort 'A < 'B .
  subsort 'F{'A} < 'F{'B} .
  subsort 'G{'B} < 'G{'A} .
  subsort 'G{'F{'B}} < 'G{'F{'A}} .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving FUNCTOR(
    var<Sort>('X), var<Sort>('F){var<Sort>('X)})
; FUNCTOR(var<Sort>('X), var<Sort>('G){var<Sort>('X)}) .
rewrites: 333
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; F{'A} ; F{'B} ; G:Sort{'A} ; G:Sort{'B} ; G:Sort{F{'A}} ;
    G:Sort{F{'B}} .
  subsort 'A < 'B .
  subsort F{'A} < F{'B} .
  subsort G:Sort{'A} < G:Sort{'B} .
  subsort G:Sort{F{'A}} < G:Sort{F{'B}} .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving LIST .
rewrites: 629
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'List{'A} ; 'List{'B} ; 'NeList{'A} ; 'NeList{'B} .
  subsort 'A < 'B .
  subsort 'A < 'NeList{'A} .
  subsort 'B < 'NeList{'B} .
  subsort 'List{'A} < 'List{'B} .
  subsort 'NeList{'A} < 'List{'A} .
  subsort 'NeList{'A} < 'NeList{'B} .
  subsort 'NeList{'B} < 'List{'B} .
  op '.List : nil -> 'List{'A} [ctor] .
  op '.List : nil -> 'List{'B} [ctor] .
  op '_`,_ : ('List{'A}) ('List{'A}) -> 'List{'A} [assoc ctor id(const('.List,
    'List{'A}))] .
  op '_`,_ : ('List{'A}) ('NeList{'A}) -> 'NeList{'A} [assoc ctor id(const(
    '.List, 'List{'A}))] .
  op '_`,_ : ('List{'B}) ('List{'B}) -> 'List{'B} [assoc ctor id(const('.List,
    'List{'B}))] .
  op '_`,_ : ('List{'B}) ('NeList{'B}) -> 'NeList{'B} [assoc ctor id(const(
    '.List, 'List{'B}))] .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving SET .
rewrites: 740
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'NeSet{'A} ; 'NeSet{'B} ; 'Set{'A} ; 'Set{'B} .
  subsort 'A < 'B .
  subsort 'A < 'NeSet{'A} .
  subsort 'B < 'NeSet{'B} .
  subsort 'NeSet{'A} < 'NeSet{'B} .
  subsort 'NeSet{'A} < 'Set{'A} .
  subsort 'NeSet{'B} < 'Set{'B} .
  subsort 'Set{'A} < 'Set{'B} .
  op '.Set : nil -> 'Set{'A} [ctor] .
  op '.Set : nil -> 'Set{'B} [ctor] .
  op '_;_ : ('Set{'A}) ('NeSet{'A}) -> 'NeSet{'A} [assoc comm ctor id(const(
    '.Set, 'Set{'A}))] .
  op '_;_ : ('Set{'A}) ('Set{'A}) -> 'Set{'A} [assoc comm ctor id(const('.Set,
    'Set{'A}))] .
  op '_;_ : ('Set{'B}) ('NeSet{'B}) -> 'NeSet{'B} [assoc comm ctor id(const(
    '.Set, 'Set{'B}))] .
  op '_;_ : ('Set{'B}) ('Set{'B}) -> 'Set{'B} [assoc comm ctor id(const('.Set,
    'Set{'B}))] .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq '_;_[var('NeS, 'NeSet{'A}),var('NeS, 'NeSet{'A})] = var('NeS, 'NeSet{'A})
    [none] .
  eq '_;_[var('NeS, 'NeSet{'B}),var('NeS, 'NeSet{'B})] = var('NeS, 'NeSet{'B})
    [none] .
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving MSET .
rewrites: 637
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'MSet{'A} ; 'MSet{'B} ; 'NeMSet{'A} ; 'NeMSet{'B} .
  subsort 'A < 'B .
  subsort 'A < 'NeMSet{'A} .
  subsort 'B < 'NeMSet{'B} .
  subsort 'MSet{'A} < 'MSet{'B} .
  subsort 'NeMSet{'A} < 'MSet{'A} .
  subsort 'NeMSet{'A} < 'NeMSet{'B} .
  subsort 'NeMSet{'B} < 'MSet{'B} .
  op '.MSet : nil -> 'MSet{'A} [ctor] .
  op '.MSet : nil -> 'MSet{'B} [ctor] .
  op '_;_ : ('MSet{'A}) ('MSet{'A}) -> 'MSet{'A} [assoc comm ctor id(const(
    '.MSet, 'MSet{'A}))] .
  op '_;_ : ('MSet{'A}) ('NeMSet{'A}) -> 'NeMSet{'A} [assoc comm ctor id(const(
    '.MSet, 'MSet{'A}))] .
  op '_;_ : ('MSet{'B}) ('MSet{'B}) -> 'MSet{'B} [assoc comm ctor id(const(
    '.MSet, 'MSet{'B}))] .
  op '_;_ : ('MSet{'B}) ('NeMSet{'B}) -> 'NeMSet{'B} [assoc comm ctor id(const(
    '.MSet, 'MSet{'B}))] .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE2, false) deriving LIST .
rewrites: 627
result FModule: fmod 'TEST-MODULE2 is
  nil
  sorts 'C ; 'D ; 'List{'C} ; 'List{'D} ; 'NeList{'C} ; 'NeList{'D} .
  subsort 'C < 'D .
  subsort 'C < 'NeList{'C} .
  subsort 'D < 'NeList{'D} .
  subsort 'List{'C} < 'List{'D} .
  subsort 'NeList{'C} < 'List{'C} .
  subsort 'NeList{'C} < 'NeList{'D} .
  subsort 'NeList{'D} < 'List{'D} .
  op '.List : nil -> 'List{'C} [ctor] .
  op '.List : nil -> 'List{'D} [ctor] .
  op '_`,_ : ('List{'C}) ('List{'C}) -> 'List{'C} [assoc ctor id(const('.List,
    'List{'C}))] .
  op '_`,_ : ('List{'C}) ('NeList{'C}) -> 'NeList{'C} [assoc ctor id(const(
    '.List, 'List{'C}))] .
  op '_`,_ : ('List{'D}) ('List{'D}) -> 'List{'D} [assoc ctor id(const('.List,
    'List{'D}))] .
  op '_`,_ : ('List{'D}) ('NeList{'D}) -> 'NeList{'D} [assoc ctor id(const(
    '.List, 'List{'D}))] .
  op 'c : nil -> 'C [none] .
  op 'd : nil -> 'D [none] .
  op 'g : 'C -> 'D [none] .
  none
  eq 'g['c.C] = 'd.D [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('EMPTY, false) deriving LIST .
rewrites: 172
result FModule: fmod 'EMPTY is
  nil
  sorts none .
  none
  none
  none
  none
endfm
==========================================
reduce in MODULE-CONSTRUCTION : wellFormed(resolveNames(upModule('TEST-MODULE,
    false) deriving LIST)) .
rewrites: 1090
result Bool: true
==========================================
reduce in MODULE-CONSTRUCTION : wellFormed(resolveNames(upModule('TEST-MODULE,
    false) deriving SET)) .
rewrites: 1327
result Bool: true
==========================================
reduce in MODULE-CONSTRUCTION : wellFormed(resolveNames(upModule('TEST-MODULE,
    false) deriving MSET)) .
rewrites: 1110
result Bool: true
==========================================
reduce in MODULE-CONSTRUCTION : wellFormed(resolveNames(upModule('TEST-MODULE2,
    false) deriving LIST)) .
rewrites: 1075
result Bool: true
==========================================
reduce in MODULE-CONSTRUCTION : wellFormed(resolveNames(upModule('EMPTY, false)
    deriving LIST)) .
rewrites: 182
result Bool: true
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving
    PROFUNCTOR(var<Sort>('X), var<Sort>('Y), var<Sort>('Y) ==> var<Sort>('X)) .
rewrites: 195
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'A ==> 'B ; 'B ==> 'A .
  subsort 'A < 'B .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : upModule('TEST-MODULE, false) deriving LIST
; PROFUNCTOR(var<Sort>('X), var<Sort>('Y), var<Sort>('Y) ==> var<Sort>('X)) .
rewrites: 2103
result FModule: fmod 'TEST-MODULE is
  nil
  sorts 'A ; 'B ; 'List{'A} ; 'List{'B} ; 'NeList{'A} ; 'NeList{'B} ; 'A ==> 'B
    ; 'A ==> ('List{'A}) ; 'A ==> ('List{'B}) ; 'A ==> ('NeList{'A}) ; 'A ==> (
    'NeList{'B}) ; 'B ==> 'A ; 'B ==> ('List{'A}) ; 'B ==> ('List{'B}) ; 'B ==>
    ('NeList{'A}) ; 'B ==> ('NeList{'B}) ; ('List{'A}) ==> 'A ; ('List{'A}) ==>
    'B ; ('List{'A}) ==> ('List{'B}) ; ('List{'A}) ==> ('NeList{'A}) ; ('List{
    'A}) ==> ('NeList{'B}) ; ('List{'B}) ==> 'A ; ('List{'B}) ==> 'B ; ('List{
    'B}) ==> ('List{'A}) ; ('List{'B}) ==> ('NeList{'A}) ; ('List{'B}) ==> (
    'NeList{'B}) ; ('NeList{'A}) ==> 'A ; ('NeList{'A}) ==> 'B ; ('NeList{'A})
    ==> ('List{'A}) ; ('NeList{'A}) ==> ('List{'B}) ; ('NeList{'A}) ==> (
    'NeList{'B}) ; ('NeList{'B}) ==> 'A ; ('NeList{'B}) ==> 'B ; ('NeList{'B})
    ==> ('List{'A}) ; ('NeList{'B}) ==> ('List{'B}) ; ('NeList{'B}) ==> (
    'NeList{'A}) .
  subsort 'A < 'B .
  subsort 'A < 'NeList{'A} .
  subsort 'B < 'NeList{'B} .
  subsort 'List{'A} < 'List{'B} .
  subsort 'NeList{'A} < 'List{'A} .
  subsort 'NeList{'A} < 'NeList{'B} .
  subsort 'NeList{'B} < 'List{'B} .
  subsort 'A ==> 'B < 'A ==> ('NeList{'B}) .
  subsort 'A ==> ('List{'A}) < 'A ==> ('List{'B}) .
  subsort 'A ==> ('NeList{'A}) < 'A ==> ('List{'A}) .
  subsort 'A ==> ('NeList{'A}) < 'A ==> ('NeList{'B}) .
  subsort 'A ==> ('NeList{'B}) < 'A ==> ('List{'B}) .
  subsort 'B ==> 'A < 'B ==> ('NeList{'A}) .
  subsort 'B ==> ('List{'A}) < 'A ==> ('List{'A}) .
  subsort 'B ==> ('List{'A}) < 'B ==> ('List{'B}) .
  subsort 'B ==> ('List{'B}) < 'A ==> ('List{'B}) .
  subsort 'B ==> ('NeList{'A}) < 'A ==> ('NeList{'A}) .
  subsort 'B ==> ('NeList{'A}) < 'B ==> ('List{'A}) .
  subsort 'B ==> ('NeList{'A}) < 'B ==> ('NeList{'B}) .
  subsort 'B ==> ('NeList{'B}) < 'A ==> ('NeList{'B}) .
  subsort 'B ==> ('NeList{'B}) < 'B ==> ('List{'B}) .
  subsort ('List{'A}) ==> 'A < ('List{'A}) ==> 'B .
  subsort ('List{'A}) ==> 'A < ('List{'A}) ==> ('NeList{'A}) .
  subsort ('List{'A}) ==> 'A < ('NeList{'A}) ==> 'A .
  subsort ('List{'A}) ==> 'B < ('List{'A}) ==> ('NeList{'B}) .
  subsort ('List{'A}) ==> 'B < ('NeList{'A}) ==> 'B .
  subsort ('List{'A}) ==> ('List{'B}) < ('NeList{'A}) ==> ('List{'B}) .
  subsort ('List{'A}) ==> ('NeList{'A}) < ('List{'A}) ==> ('NeList{'B}) .
  subsort ('List{'A}) ==> ('NeList{'B}) < ('List{'A}) ==> ('List{'B}) .
  subsort ('List{'A}) ==> ('NeList{'B}) < ('NeList{'A}) ==> ('NeList{'B}) .
  subsort ('List{'B}) ==> 'A < ('List{'A}) ==> 'A .
  subsort ('List{'B}) ==> 'A < ('List{'B}) ==> 'B .
  subsort ('List{'B}) ==> 'A < ('List{'B}) ==> ('NeList{'A}) .
  subsort ('List{'B}) ==> 'A < ('NeList{'B}) ==> 'A .
  subsort ('List{'B}) ==> 'B < ('List{'A}) ==> 'B .
  subsort ('List{'B}) ==> 'B < ('List{'B}) ==> ('NeList{'B}) .
  subsort ('List{'B}) ==> 'B < ('NeList{'B}) ==> 'B .
  subsort ('List{'B}) ==> ('List{'A}) < ('NeList{'B}) ==> ('List{'A}) .
  subsort ('List{'B}) ==> ('NeList{'A}) < ('List{'A}) ==> ('NeList{'A}) .
  subsort ('List{'B}) ==> ('NeList{'A}) < ('List{'B}) ==> ('List{'A}) .
  subsort ('List{'B}) ==> ('NeList{'A}) < ('List{'B}) ==> ('NeList{'B}) .
  subsort ('List{'B}) ==> ('NeList{'A}) < ('NeList{'B}) ==> ('NeList{'A}) .
  subsort ('List{'B}) ==> ('NeList{'B}) < ('List{'A}) ==> ('NeList{'B}) .
  subsort ('NeList{'A}) ==> 'A < ('NeList{'A}) ==> 'B .
  subsort ('NeList{'A}) ==> 'B < 'A ==> 'B .
  subsort ('NeList{'A}) ==> 'B < ('NeList{'A}) ==> ('NeList{'B}) .
  subsort ('NeList{'A}) ==> ('List{'A}) < 'A ==> ('List{'A}) .
  subsort ('NeList{'A}) ==> ('List{'A}) < ('NeList{'A}) ==> ('List{'B}) .
  subsort ('NeList{'A}) ==> ('List{'B}) < 'A ==> ('List{'B}) .
  subsort ('NeList{'A}) ==> ('NeList{'B}) < 'A ==> ('NeList{'B}) .
  subsort ('NeList{'A}) ==> ('NeList{'B}) < ('NeList{'A}) ==> ('List{'B}) .
  subsort ('NeList{'B}) ==> 'A < 'B ==> 'A .
  subsort ('NeList{'B}) ==> 'A < ('NeList{'A}) ==> 'A .
  subsort ('NeList{'B}) ==> 'A < ('NeList{'B}) ==> 'B .
  subsort ('NeList{'B}) ==> 'A < ('NeList{'B}) ==> ('NeList{'A}) .
  subsort ('NeList{'B}) ==> 'B < ('NeList{'A}) ==> 'B .
  subsort ('NeList{'B}) ==> ('List{'A}) < 'B ==> ('List{'A}) .
  subsort ('NeList{'B}) ==> ('List{'A}) < ('NeList{'A}) ==> ('List{'A}) .
  subsort ('NeList{'B}) ==> ('List{'A}) < ('NeList{'B}) ==> ('List{'B}) .
  subsort ('NeList{'B}) ==> ('List{'B}) < 'B ==> ('List{'B}) .
  subsort ('NeList{'B}) ==> ('List{'B}) < ('NeList{'A}) ==> ('List{'B}) .
  subsort ('NeList{'B}) ==> ('NeList{'A}) < 'B ==> ('NeList{'A}) .
  subsort ('NeList{'B}) ==> ('NeList{'A}) < ('NeList{'B}) ==> ('List{'A}) .
  op '.List : nil -> 'List{'A} [ctor] .
  op '.List : nil -> 'List{'B} [ctor] .
  op '_`,_ : ('List{'A}) ('List{'A}) -> 'List{'A} [assoc ctor id(const('.List,
    'List{'A}))] .
  op '_`,_ : ('List{'A}) ('NeList{'A}) -> 'NeList{'A} [assoc ctor id(const(
    '.List, 'List{'A}))] .
  op '_`,_ : ('List{'B}) ('List{'B}) -> 'List{'B} [assoc ctor id(const('.List,
    'List{'B}))] .
  op '_`,_ : ('List{'B}) ('NeList{'B}) -> 'NeList{'B} [assoc ctor id(const(
    '.List, 'List{'B}))] .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : wellFormed(resolveNames(upModule('TEST-MODULE,
    false) deriving LIST
; PROFUNCTOR(var<Sort>('X), var<Sort>('Y), var<Sort>('Y) ==> var<Sort>('X)))) .
rewrites: 5555
result Bool: true
==========================================
reduce in MODULE-CONSTRUCTION : #upModule('TEST-MODULE deriving DOWN-TERM <
    'TEST-MODULE >) .
rewrites: 522
result FModule: fmod 'TEST-MODULE is
  protecting 'META-LEVEL .
  protecting 'TEST-MODULE .
  sorts 'A ; 'B ; 'A ? ; 'B ? .
  subsort 'A < 'B .
  subsort 'A < 'A ? .
  subsort 'B < 'B ? .
  subsort 'A ? < 'B ? .
  op 'a : nil -> 'A [none] .
  op 'b : nil -> 'B [none] .
  op 'f : 'B -> 'A [none] .
  op 'g : 'B -> 'B [none] .
  op 'downTerm < 'A > : 'Term -> 'A ? [none] .
  op 'downTerm < 'B > : 'Term -> 'B ? [none] .
  op 'downTermError < 'A > : nil -> 'A ? [ctor] .
  op 'downTermError < 'B > : nil -> 'B ? [ctor] .
  op 'wellFormed < 'A > : 'Term -> 'Bool [none] .
  op 'wellFormed < 'B > : 'Term -> 'Bool [none] .
  none
  eq 'f['b.B] = 'a.A [none] .
  eq 'g['a.A] = 'a.A [none] .
  ceq 'downTerm < 'A >[var('T, 'Term)] = var('X, 'A) if var('X, 'A) :=
    'downTerm[var('T, 'Term),const('downTermError < 'A >, 'A ?)] [none] .
  ceq 'downTerm < 'B >[var('T, 'Term)] = var('X, 'B) if var('X, 'B) :=
    'downTerm[var('T, 'Term),const('downTermError < 'B >, 'B ?)] [none] .
  ceq 'wellFormed < 'A >[var('T, 'Term)] = 'true.Bool if var('X, 'A) :=
    'downTerm < 'A >[var('T, 'Term)] [none] .
  ceq 'wellFormed < 'B >[var('T, 'Term)] = 'true.Bool if var('X, 'B) :=
    'downTerm < 'B >[var('T, 'Term)] [none] .
endfm
==========================================
reduce in MODULE-CONSTRUCTION : wellFormed(resolveNames(#upModule('TEST-MODULE
    deriving DOWN-TERM < 'TEST-MODULE >))) .
rewrites: 534
result Bool: true
Bye.
