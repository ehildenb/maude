Warning: sort declarations for operator resolveNames failed preregularity check
    on 6 out of 39 sort tuples. First such tuple is (Type).
Warning: sort declarations for operator resolveNames failed preregularity check
    on 1 out of 26 sort tuples. First such tuple is (NullDeclSet).
==========================================
reduce in MODULE-DECLARATION : sortSet(none) .
rewrites: 1
result EmptyTypeSet: (none).EmptyTypeSet
==========================================
reduce in MODULE-DECLARATION : sortSet(sorts none .) .
rewrites: 2
result EmptyTypeSet: (none).EmptyTypeSet
==========================================
reduce in MODULE-DECLARATION : sortSet(sorts 'S ; 'R ; 'T .) .
rewrites: 1
result NeSortSet: 'R ; 'S ; 'T
==========================================
reduce in MODULE-DECLARATION : sortSet((sorts 'Q ; 'R .)
(sorts 'S ; 'T .)) .
rewrites: 2
result NeSortSet: 'Q ; 'R ; 'S ; 'T
==========================================
reduce in MODULE-DECLARATION : sortSet((sorts 'Q ; 'T .)
(sorts 'S ; 'T .)) .
rewrites: 3
result NeSortSet: 'Q ; 'S ; 'T
Warning: sort declarations for operator resolveNames failed preregularity check
    on 6 out of 39 sort tuples. First such tuple is (Type).
Warning: sort declarations for operator resolveNames failed preregularity check
    on 1 out of 28 sort tuples. First such tuple is (NullDeclSet).
==========================================
reduce in MODULE-TEMPLATE : asTemplate(fmod 'TEST is
  nil
  sorts none .
  none
  none
  none
  none
endfm) .
rewrites: 3
result NullDeclSet: (none).NullDeclSet
==========================================
reduce in MODULE-TEMPLATE : asTemplate(upModule('BOOL, true)) .
rewrites: 3
result NeModuleDeclSet: (sorts 'Bool .)
eq '_and_['A:Bool,'A:Bool] = 'A:Bool [none] .
eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]] = '_xor_['_and_['A:Bool,'B:Bool],
    '_and_['A:Bool,'C:Bool]] [none] .
eq '_and_['false.Bool,'A:Bool] = 'false.Bool [none] .
eq '_and_['true.Bool,'A:Bool] = 'A:Bool [none] .
eq '_implies_['A:Bool,'B:Bool] = 'not_['_xor_['A:Bool,'_and_['A:Bool,'B:Bool]]]
    [none] .
eq '_or_['A:Bool,'B:Bool] = '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,
    'B:Bool]] [none] .
eq '_xor_['A:Bool,'A:Bool] = 'false.Bool [none] .
eq '_xor_['false.Bool,'A:Bool] = 'A:Bool [none] .
eq 'not_['A:Bool] = '_xor_['true.Bool,'A:Bool] [none] .
op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51) poly(1 2) special(
    id-hook('EqualitySymbol, nil) 
    term-hook('equalTerm, 'false.Bool) 
    term-hook('notEqualTerm, 'true.Bool))] .
op '_==_ : 'Universal 'Universal -> 'Bool [prec(51) poly(1 2) special(
    id-hook('EqualitySymbol, nil) 
    term-hook('equalTerm, 'true.Bool) 
    term-hook('notEqualTerm, 'false.Bool))] .
op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61) gather('e 'E)] .
op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
op 'false : nil -> 'Bool [ctor special(
    id-hook('SystemFalse, nil))] .
op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3 0)
    special(
    id-hook('BranchSymbol, nil) 
    term-hook('1, 'true.Bool) 
    term-hook('2, 'false.Bool))] .
op 'not_ : 'Bool -> 'Bool [prec(53)] .
op 'true : nil -> 'Bool [ctor special(
    id-hook('SystemTrue, nil))] .
==========================================
reduce in MODULE-TEMPLATE : asTemplate(upModule('BOOL, false)) .
rewrites: 7
result NeImportDeclSet: pr 'BOOL-OPS .
pr 'TRUTH .
==========================================
reduce in MODULE-TEMPLATE : asTemplate(upModule('DIJKSTRA, true)) .
rewrites: 5
result NeModuleDeclSet: (sorts '2Proc ; '2ProcSet ; 'Bool* ; 'CProc ; 'Conf ;
    'NCProc ; 'NCProcSet ; 'Proc ; 'ProcSet ; 'State ; 'WProc ; 'WProcSet .)
subsort '2Proc < '2ProcSet .
subsort '2Proc < 'NCProc .
subsort '2ProcSet < 'NCProcSet .
subsort 'CProc < 'Proc .
subsort 'NCProc < 'NCProcSet .
subsort 'NCProc < 'Proc .
subsort 'NCProcSet < 'ProcSet .
subsort 'Proc < 'ProcSet .
subsort 'WProc < 'NCProc .
subsort 'WProc < 'WProcSet .
subsort 'WProcSet < 'NCProcSet .
eq '_and*_['B:Bool*,'ff.Bool*] = 'ff.Bool* [variant] .
eq '_and*_['B:Bool*,'tt.Bool*] = 'B:Bool* [variant] .
eq '_or*_['B:Bool*,'ff.Bool*] = 'B:Bool* [variant] .
eq '_or*_['B:Bool*,'tt.Bool*] = 'tt.Bool* [variant] .
eq 'not*_['ff.Bool*] = 'tt.Bool* [variant] .
eq 'not*_['tt.Bool*] = 'ff.Bool* [variant] .
eq 'safe?['P:2ProcSet] = 'ff.Bool* [none] .
eq 'safe?['P:WProcSet] = 'tt.Bool* [none] .
eq 'safe?['__['C:Proc,'P:ProcSet]] = 'ff.Bool* [none] .
rl '<_>['_|_['P:Proc,'PS:ProcSet]] => '`[_`]['_|_['P:Proc,'PS:ProcSet]] [label(
    'stop)] .
rl '<_>['_|_['P:Proc,'__['`{0`,try`}.WProc,'PS:ProcSet]]] => '<_>['_|_['P:Proc,
    '__['`{1`,try`}.WProc,'PS:ProcSet]]] [label('start1)] .
rl '<_>['_|_['P:Proc,'__['`{1`,upf`}.WProc,'PS:ProcSet]]] => '<_>['_|_['P:Proc,
    '__['`{2`,chf`}.2Proc,'PS:ProcSet]]] [label('set-flag1)] .
rl '<_>['_|_['P:Proc,'__['`{1`,upt`}.WProc,'PS:ProcSet]]] => '<_>['_|_[
    '`{1`,upf`}.WProc,'__['P:Proc,'PS:ProcSet]]] [label('set-turn1)] .
rl '<_>['_|_['P:Proc,'__['`{2`,crt`}.CProc,'PS:ProcSet]]] => '<_>['_|_['P:Proc,
    '__['`{2`,ext`}.2Proc,'PS:ProcSet]]] [label('done-crit1)] .
rl '<_>['_|_['P:Proc,'__['`{2`,ext`}.2Proc,'PS:ProcSet]]] => '<_>['_|_['P:Proc,
    '__['`{0`,try`}.WProc,'PS:ProcSet]]] [label('exit-crit1)] .
rl '<_>['_|_['`{0`,try`}.WProc,'PS:ProcSet]] => '<_>['_|_['`{1`,try`}.WProc,
    'PS:ProcSet]] [label('start2)] .
rl '<_>['_|_['`{0`,try`}.WProc,'__['`{1`,try`}.WProc,'PS:ProcSet]]] => '<_>[
    '_|_['`{0`,try`}.WProc,'__['`{1`,upt`}.WProc,'PS:ProcSet]]] [label(
    'chk-turn1)] .
rl '<_>['_|_['`{1`,try`}.WProc,'PS:ProcSet]] => '<_>['_|_['`{1`,upf`}.WProc,
    'PS:ProcSet]] [label('chk-turn2)] .
rl '<_>['_|_['`{1`,upf`}.WProc,'PS:ProcSet]] => '<_>['_|_['`{2`,chf`}.2Proc,
    'PS:ProcSet]] [label('set-flag2)] .
rl '<_>['_|_['`{2`,chf`}.2Proc,'2PS:2ProcSet]] => '<_>['_|_['`{2`,ext`}.2Proc,
    '2PS:2ProcSet]] [label('fail-crit2)] .
rl '<_>['_|_['`{2`,chf`}.2Proc,'WPS:WProcSet]] => '<_>['_|_['`{2`,crt`}.CProc,
    'WPS:WProcSet]] [label('go-crit2)] .
rl '<_>['_|_['`{2`,crt`}.CProc,'PS:ProcSet]] => '<_>['_|_['`{2`,ext`}.2Proc,
    'PS:ProcSet]] [label('done-crit2)] .
rl '<_>['_|_['`{2`,ext`}.2Proc,'PS:ProcSet]] => '<_>['_|_['`{0`,try`}.WProc,
    'PS:ProcSet]] [label('exit-crit2)] .
op '<_> : 'Conf -> 'State [ctor] .
op '_==_ : 'Bool* 'Bool* -> 'Bool* [none] .
op '__ : '2ProcSet '2ProcSet -> '2ProcSet [assoc comm ctor id('mt.WProcSet)] .
op '__ : '2ProcSet 'WProcSet -> '2ProcSet [assoc comm ctor id('mt.WProcSet)] .
op '__ : 'NCProcSet 'NCProcSet -> 'NCProcSet [assoc comm ctor id('mt.WProcSet)]
    .
op '__ : 'ProcSet 'ProcSet -> 'ProcSet [assoc comm ctor id('mt.WProcSet)] .
op '__ : 'WProcSet 'WProcSet -> 'WProcSet [assoc comm ctor id('mt.WProcSet)] .
op '_and*_ : 'Bool* 'Bool* -> 'Bool* [none] .
op '_or*_ : 'Bool* 'Bool* -> 'Bool* [none] .
op '_|_ : 'Proc 'ProcSet -> 'Conf [ctor] .
op '`[_`] : 'Conf -> 'State [ctor] .
op '`{0`,try`} : nil -> 'WProc [ctor] .
op '`{1`,try`} : nil -> 'WProc [ctor] .
op '`{1`,upf`} : nil -> 'WProc [ctor] .
op '`{1`,upt`} : nil -> 'WProc [ctor] .
op '`{2`,chf`} : nil -> '2Proc [ctor] .
op '`{2`,crt`} : nil -> 'CProc [ctor] .
op '`{2`,ext`} : nil -> '2Proc [ctor] .
op 'ff : nil -> 'Bool* [ctor] .
op 'mt : nil -> 'WProcSet [none] .
op 'not*_ : 'Bool* -> 'Bool* [none] .
op 'safe? : 'ProcSet -> 'Bool* [none] .
op 'tt : nil -> 'Bool* [ctor] .
crl '<_>['_|_['P:Proc,'__['`{2`,chf`}.2Proc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{2`,crt`}.CProc,'PS:ProcSet]]] if '_==_['safe?['__['P:Proc,
    'PS:ProcSet]],'tt.Bool*] = 'tt.Bool* [label('go-crit1)] .
crl '<_>['_|_['P:Proc,'__['`{2`,chf`}.2Proc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{2`,ext`}.2Proc,'PS:ProcSet]]] if '_==_['safe?['__['P:Proc,
    'PS:ProcSet]],'ff.Bool*] = 'tt.Bool* [label('fail-crit1)] .
==========================================
reduce in MODULE-TEMPLATE : asTemplate(upModule('BAKERY-FVP, true)) .
rewrites: 3
result NeModuleDeclSet: (sorts 'BState ; 'Bool> ; 'Mode ; 'Nat> ; 'NcMode ;
    'NzNat> ; 'Zero> .)
subsort 'NcMode < 'Mode .
subsort 'NzNat> < 'Nat> .
subsort 'Zero> < 'Nat> .
eq '_>_['n:Nat>,'_+_['n:Nat>,'m:Nat>]] = 'ff.Bool> [variant] .
eq '_>_['_+_['n:Nat>,'n':NzNat>],'n:Nat>] = 'tt.Bool> [variant] .
rl '<_`,_`,_`,_>['P:Mode,'0.Zero>,'wait.NcMode,'Y:Nat>] => '<_`,_`,_`,_>[
    'P:Mode,'0.Zero>,'crit.Mode,'Y:Nat>] [label('p2_wait)] .
rl '<_`,_`,_`,_>['P:Mode,'X:Nat>,'crit.Mode,'Y:Nat>] => '<_`,_`,_`,_>['P:Mode,
    'X:Nat>,'sleep.NcMode,'0.Zero>] [label('p2_crit)] .
rl '<_`,_`,_`,_>['P:Mode,'X:Nat>,'sleep.NcMode,'Y:Nat>] => '<_`,_`,_`,_>[
    'P:Mode,'X:Nat>,'wait.NcMode,'_+_['1.NzNat>,'X:Nat>]] [label('p2_sleep)] .
rl '<_`,_`,_`,_>['crit.Mode,'X:Nat>,'Q:Mode,'Y:Nat>] => '<_`,_`,_`,_>[
    'sleep.NcMode,'0.Zero>,'Q:Mode,'Y:Nat>] [label('p1_crit)] .
rl '<_`,_`,_`,_>['sleep.NcMode,'X:Nat>,'Q:Mode,'Y:Nat>] => '<_`,_`,_`,_>[
    'wait.NcMode,'_+_['1.NzNat>,'Y:Nat>],'Q:Mode,'Y:Nat>] [label('p1_sleep)] .
rl '<_`,_`,_`,_>['wait.NcMode,'X:Nat>,'Q:Mode,'0.Zero>] => '<_`,_`,_`,_>[
    'crit.Mode,'X:Nat>,'Q:Mode,'0.Zero>] [label('p1_wait)] .
op '0 : nil -> 'Zero> [ctor] .
op '1 : nil -> 'NzNat> [ctor] .
op '<_`,_`,_`,_> : 'Mode 'Nat> 'Mode 'Nat> -> 'BState [ctor] .
op '_+_ : 'Nat> 'Nat> -> 'Nat> [assoc comm ctor id('0.Zero>)] .
op '_+_ : 'Nat> 'NzNat> -> 'NzNat> [assoc comm ctor id('0.Zero>)] .
op '_+_ : 'NzNat> 'Nat> -> 'NzNat> [assoc comm ctor id('0.Zero>)] .
op '_+_ : 'NzNat> 'NzNat> -> 'NzNat> [assoc comm ctor id('0.Zero>)] .
op '_>_ : 'Nat> 'Nat> -> 'Bool> [none] .
op 'crit : nil -> 'Mode [ctor] .
op 'ff : nil -> 'Bool> [ctor] .
op 'sleep : nil -> 'NcMode [ctor] .
op 'tt : nil -> 'Bool> [ctor] .
op 'wait : nil -> 'NcMode [ctor] .
crl '<_`,_`,_`,_>['P:Mode,'X:Nat>,'wait.NcMode,'Y:Nat>] => '<_`,_`,_`,_>[
    'P:Mode,'X:Nat>,'crit.Mode,'Y:Nat>] if '_>_['X:Nat>,'Y:Nat>] = 'tt.Bool> [
    label('p2_wait)] .
crl '<_`,_`,_`,_>['wait.NcMode,'X:Nat>,'Q:Mode,'Y:Nat>] => '<_`,_`,_`,_>[
    'crit.Mode,'X:Nat>,'Q:Mode,'Y:Nat>] if '_>_['X:Nat>,'Y:Nat>] = 'ff.Bool> [
    label('p1_wait)] .
==========================================
reduce in MODULE-TEMPLATE : fromTemplate('TEST, none) .
rewrites: 3
result FModule: fmod 'TEST is
  nil
  sorts none .
  none
  none
  none
  none
endfm
==========================================
reduce in MODULE-TEMPLATE : fromTemplate('TEST, asTemplate(upModule('BOOL,
    false))) .
rewrites: 12
result FModule: fmod 'TEST is
  protecting 'BOOL-OPS .
  protecting 'TRUTH .
  sorts none .
  none
  none
  none
  none
endfm
==========================================
reduce in MODULE-TEMPLATE : fromTemplate('DIJKSTRA, asTemplate(upModule(
    'DIJKSTRA, true))) .
rewrites: 8
result SModule: mod 'DIJKSTRA is
  nil
  sorts '2Proc ; '2ProcSet ; 'Bool* ; 'CProc ; 'Conf ; 'NCProc ; 'NCProcSet ;
    'Proc ; 'ProcSet ; 'State ; 'WProc ; 'WProcSet .
  subsort '2Proc < '2ProcSet .
  subsort '2Proc < 'NCProc .
  subsort '2ProcSet < 'NCProcSet .
  subsort 'CProc < 'Proc .
  subsort 'NCProc < 'NCProcSet .
  subsort 'NCProc < 'Proc .
  subsort 'NCProcSet < 'ProcSet .
  subsort 'Proc < 'ProcSet .
  subsort 'WProc < 'NCProc .
  subsort 'WProc < 'WProcSet .
  subsort 'WProcSet < 'NCProcSet .
  op '<_> : 'Conf -> 'State [ctor] .
  op '_==_ : 'Bool* 'Bool* -> 'Bool* [none] .
  op '__ : '2ProcSet '2ProcSet -> '2ProcSet [assoc comm ctor id('mt.WProcSet)]
    .
  op '__ : '2ProcSet 'WProcSet -> '2ProcSet [assoc comm ctor id('mt.WProcSet)]
    .
  op '__ : 'NCProcSet 'NCProcSet -> 'NCProcSet [assoc comm ctor id(
    'mt.WProcSet)] .
  op '__ : 'ProcSet 'ProcSet -> 'ProcSet [assoc comm ctor id('mt.WProcSet)] .
  op '__ : 'WProcSet 'WProcSet -> 'WProcSet [assoc comm ctor id('mt.WProcSet)]
    .
  op '_and*_ : 'Bool* 'Bool* -> 'Bool* [none] .
  op '_or*_ : 'Bool* 'Bool* -> 'Bool* [none] .
  op '_|_ : 'Proc 'ProcSet -> 'Conf [ctor] .
  op '`[_`] : 'Conf -> 'State [ctor] .
  op '`{0`,try`} : nil -> 'WProc [ctor] .
  op '`{1`,try`} : nil -> 'WProc [ctor] .
  op '`{1`,upf`} : nil -> 'WProc [ctor] .
  op '`{1`,upt`} : nil -> 'WProc [ctor] .
  op '`{2`,chf`} : nil -> '2Proc [ctor] .
  op '`{2`,crt`} : nil -> 'CProc [ctor] .
  op '`{2`,ext`} : nil -> '2Proc [ctor] .
  op 'ff : nil -> 'Bool* [ctor] .
  op 'mt : nil -> 'WProcSet [none] .
  op 'not*_ : 'Bool* -> 'Bool* [none] .
  op 'safe? : 'ProcSet -> 'Bool* [none] .
  op 'tt : nil -> 'Bool* [ctor] .
  none
  eq '_and*_['B:Bool*,'ff.Bool*] = 'ff.Bool* [variant] .
  eq '_and*_['B:Bool*,'tt.Bool*] = 'B:Bool* [variant] .
  eq '_or*_['B:Bool*,'ff.Bool*] = 'B:Bool* [variant] .
  eq '_or*_['B:Bool*,'tt.Bool*] = 'tt.Bool* [variant] .
  eq 'not*_['ff.Bool*] = 'tt.Bool* [variant] .
  eq 'not*_['tt.Bool*] = 'ff.Bool* [variant] .
  eq 'safe?['P:2ProcSet] = 'ff.Bool* [none] .
  eq 'safe?['P:WProcSet] = 'tt.Bool* [none] .
  eq 'safe?['__['C:Proc,'P:ProcSet]] = 'ff.Bool* [none] .
  rl '<_>['_|_['P:Proc,'PS:ProcSet]] => '`[_`]['_|_['P:Proc,'PS:ProcSet]] [
    label('stop)] .
  rl '<_>['_|_['P:Proc,'__['`{0`,try`}.WProc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{1`,try`}.WProc,'PS:ProcSet]]] [label('start1)] .
  rl '<_>['_|_['P:Proc,'__['`{1`,upf`}.WProc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{2`,chf`}.2Proc,'PS:ProcSet]]] [label('set-flag1)] .
  rl '<_>['_|_['P:Proc,'__['`{1`,upt`}.WProc,'PS:ProcSet]]] => '<_>['_|_[
    '`{1`,upf`}.WProc,'__['P:Proc,'PS:ProcSet]]] [label('set-turn1)] .
  rl '<_>['_|_['P:Proc,'__['`{2`,crt`}.CProc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{2`,ext`}.2Proc,'PS:ProcSet]]] [label('done-crit1)] .
  rl '<_>['_|_['P:Proc,'__['`{2`,ext`}.2Proc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{0`,try`}.WProc,'PS:ProcSet]]] [label('exit-crit1)] .
  rl '<_>['_|_['`{0`,try`}.WProc,'PS:ProcSet]] => '<_>['_|_['`{1`,try`}.WProc,
    'PS:ProcSet]] [label('start2)] .
  rl '<_>['_|_['`{0`,try`}.WProc,'__['`{1`,try`}.WProc,'PS:ProcSet]]] => '<_>[
    '_|_['`{0`,try`}.WProc,'__['`{1`,upt`}.WProc,'PS:ProcSet]]] [label(
    'chk-turn1)] .
  rl '<_>['_|_['`{1`,try`}.WProc,'PS:ProcSet]] => '<_>['_|_['`{1`,upf`}.WProc,
    'PS:ProcSet]] [label('chk-turn2)] .
  rl '<_>['_|_['`{1`,upf`}.WProc,'PS:ProcSet]] => '<_>['_|_['`{2`,chf`}.2Proc,
    'PS:ProcSet]] [label('set-flag2)] .
  rl '<_>['_|_['`{2`,chf`}.2Proc,'2PS:2ProcSet]] => '<_>['_|_[
    '`{2`,ext`}.2Proc,'2PS:2ProcSet]] [label('fail-crit2)] .
  rl '<_>['_|_['`{2`,chf`}.2Proc,'WPS:WProcSet]] => '<_>['_|_[
    '`{2`,crt`}.CProc,'WPS:WProcSet]] [label('go-crit2)] .
  rl '<_>['_|_['`{2`,crt`}.CProc,'PS:ProcSet]] => '<_>['_|_['`{2`,ext`}.2Proc,
    'PS:ProcSet]] [label('done-crit2)] .
  rl '<_>['_|_['`{2`,ext`}.2Proc,'PS:ProcSet]] => '<_>['_|_['`{0`,try`}.WProc,
    'PS:ProcSet]] [label('exit-crit2)] .
  crl '<_>['_|_['P:Proc,'__['`{2`,chf`}.2Proc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{2`,crt`}.CProc,'PS:ProcSet]]] if '_==_['safe?['__['P:Proc,
    'PS:ProcSet]],'tt.Bool*] = 'tt.Bool* [label('go-crit1)] .
  crl '<_>['_|_['P:Proc,'__['`{2`,chf`}.2Proc,'PS:ProcSet]]] => '<_>['_|_[
    'P:Proc,'__['`{2`,ext`}.2Proc,'PS:ProcSet]]] if '_==_['safe?['__['P:Proc,
    'PS:ProcSet]],'ff.Bool*] = 'tt.Bool* [label('fail-crit1)] .
endm
==========================================
reduce in MODULE-TEMPLATE : fromTemplate('BAKERY-FVP, asTemplate(upModule(
    'BAKERY-FVP, true))) .
rewrites: 6
result SModule: mod 'BAKERY-FVP is
  nil
  sorts 'BState ; 'Bool> ; 'Mode ; 'Nat> ; 'NcMode ; 'NzNat> ; 'Zero> .
  subsort 'NcMode < 'Mode .
  subsort 'NzNat> < 'Nat> .
  subsort 'Zero> < 'Nat> .
  op '0 : nil -> 'Zero> [ctor] .
  op '1 : nil -> 'NzNat> [ctor] .
  op '<_`,_`,_`,_> : 'Mode 'Nat> 'Mode 'Nat> -> 'BState [ctor] .
  op '_+_ : 'Nat> 'Nat> -> 'Nat> [assoc comm ctor id('0.Zero>)] .
  op '_+_ : 'Nat> 'NzNat> -> 'NzNat> [assoc comm ctor id('0.Zero>)] .
  op '_+_ : 'NzNat> 'Nat> -> 'NzNat> [assoc comm ctor id('0.Zero>)] .
  op '_+_ : 'NzNat> 'NzNat> -> 'NzNat> [assoc comm ctor id('0.Zero>)] .
  op '_>_ : 'Nat> 'Nat> -> 'Bool> [none] .
  op 'crit : nil -> 'Mode [ctor] .
  op 'ff : nil -> 'Bool> [ctor] .
  op 'sleep : nil -> 'NcMode [ctor] .
  op 'tt : nil -> 'Bool> [ctor] .
  op 'wait : nil -> 'NcMode [ctor] .
  none
  eq '_>_['n:Nat>,'_+_['n:Nat>,'m:Nat>]] = 'ff.Bool> [variant] .
  eq '_>_['_+_['n:Nat>,'n':NzNat>],'n:Nat>] = 'tt.Bool> [variant] .
  rl '<_`,_`,_`,_>['P:Mode,'0.Zero>,'wait.NcMode,'Y:Nat>] => '<_`,_`,_`,_>[
    'P:Mode,'0.Zero>,'crit.Mode,'Y:Nat>] [label('p2_wait)] .
  rl '<_`,_`,_`,_>['P:Mode,'X:Nat>,'crit.Mode,'Y:Nat>] => '<_`,_`,_`,_>[
    'P:Mode,'X:Nat>,'sleep.NcMode,'0.Zero>] [label('p2_crit)] .
  rl '<_`,_`,_`,_>['P:Mode,'X:Nat>,'sleep.NcMode,'Y:Nat>] => '<_`,_`,_`,_>[
    'P:Mode,'X:Nat>,'wait.NcMode,'_+_['1.NzNat>,'X:Nat>]] [label('p2_sleep)] .
  rl '<_`,_`,_`,_>['crit.Mode,'X:Nat>,'Q:Mode,'Y:Nat>] => '<_`,_`,_`,_>[
    'sleep.NcMode,'0.Zero>,'Q:Mode,'Y:Nat>] [label('p1_crit)] .
  rl '<_`,_`,_`,_>['sleep.NcMode,'X:Nat>,'Q:Mode,'Y:Nat>] => '<_`,_`,_`,_>[
    'wait.NcMode,'_+_['1.NzNat>,'Y:Nat>],'Q:Mode,'Y:Nat>] [label('p1_sleep)] .
  rl '<_`,_`,_`,_>['wait.NcMode,'X:Nat>,'Q:Mode,'0.Zero>] => '<_`,_`,_`,_>[
    'crit.Mode,'X:Nat>,'Q:Mode,'0.Zero>] [label('p1_wait)] .
  crl '<_`,_`,_`,_>['P:Mode,'X:Nat>,'wait.NcMode,'Y:Nat>] => '<_`,_`,_`,_>[
    'P:Mode,'X:Nat>,'crit.Mode,'Y:Nat>] if '_>_['X:Nat>,'Y:Nat>] = 'tt.Bool> [
    label('p2_wait)] .
  crl '<_`,_`,_`,_>['wait.NcMode,'X:Nat>,'Q:Mode,'Y:Nat>] => '<_`,_`,_`,_>[
    'crit.Mode,'X:Nat>,'Q:Mode,'Y:Nat>] if '_>_['X:Nat>,'Y:Nat>] = 'ff.Bool> [
    label('p1_wait)] .
endm
==========================================
reduce in MODULE-TEMPLATE : wellFormed(fromTemplate('TEST, none)) .
rewrites: 4
result Bool: true
==========================================
reduce in MODULE-TEMPLATE : wellFormed(fromTemplate('TEST, asTemplate(upModule(
    'BOOL, false)))) .
rewrites: 13
result Bool: true
==========================================
reduce in MODULE-TEMPLATE : wellFormed(fromTemplate('DIJKSTRA, asTemplate(
    upModule('DIJKSTRA, true)))) .
rewrites: 9
result Bool: true
==========================================
reduce in MODULE-TEMPLATE : wellFormed(fromTemplate('BAKERY-FVP, asTemplate(
    upModule('BAKERY-FVP, true)))) .
rewrites: 7
result Bool: true
Bye.
