load ../../../contrib/tools/meta/nelson-oppen-combination.maude
load ../../../contrib/tools/varsat/numbers.maude

--- We need purification to put `0` and `s` into the `Nat*` theory,
--- while at the same time have enough constructors to convince
--- `var-sat` that the `Nat*` sort is infinite

fmod MYLISTNAT* is
  protecting BOOL* .
  sort Nat* .

  op fake-zero : -> Nat*      [ctor] .
  op fake-succ : Nat* -> Nat* [ctor] .

  sort NeNatList* NatList* .
  subsort Nat* < NeNatList* < NatList* .
  op __  : NeNatList* NeNatList* -> NeNatList* [ctor assoc] .
  op nil : -> NatList* [ctor] .

  op head : NeNatList* -> Nat* .
  var N : Nat* . var L : NeNatList* .
  eq head(N)   = N [variant] .
  eq head(N L) = N [variant] .
endfm

fmod TEST-NO-NAT-LIST is
    protecting NAT* .
    protecting MYLISTNAT* .
    protecting NELSON-OPPEN-COMBINATION .
    protecting META-LEVEL .

    op natMod     : -> Module   . eq natMod       = upModule('NAT*, true) .
    op natListMod : -> Module   . eq natListMod   = upModule('MYLISTNAT*, true) .
endfm

reduce nelson-oppen-sat(( tagged(tt, (('mod > 'MYLISTNAT*); 'check-sat > 'var-sat))
                        , tagged(tt, (('mod > 'NAT*      ); 'check-sat > 'var-sat))),
       ('tt.Bool* ?= ('_<Nat_ [ '_:+_['head['L':NeNatList*] , 'head['L':NeNatList*]]
                              , '_:+_['head[ 'L:NeNatList*] , 'head['L:NeNatList* ]]
                              ]))
        => (  'L:NeNatList* != 'L':NeNatList*
           /\ 'tt.Bool*     ?= '_<Nat_ ['head['L':NeNatList*] , 'head['L:NeNatList*]]
           )
       )
    == true
    .

reduce nelson-oppen-sat(( tagged(tt, (('mod > 'MYLISTNAT*); 'check-sat > 'var-sat))
                        , tagged(tt, (('mod > 'NAT*      ); 'check-sat > 'var-sat))),
       (  'L:NeNatList* ?= 'L':NeNatList*
       /\ 'tt.Bool*     ?= '_<Nat_ ['head['L':NeNatList*] , 'head['L:NeNatList*]]
       ))
    == false
    .

fmod INTEGER-LIST is
    protecting BOOLEAN .
    sort Integer .
    --- Convince var-sat we are infinite
    op fake-0 :         -> Integer [ctor] .
    op fake-s : Integer -> Integer [ctor] .

    sort IntegerList NeIntegerList .
    subsort Integer < NeIntegerList < IntegerList .
    op _ _ :    NeIntegerList NeIntegerList -> NeIntegerList [ctor assoc] .
    op nil : -> IntegerList [ctor] .

    op head : NeIntegerList -> Integer .
    var N : Integer . var L : NeIntegerList .
    eq head(N)   = N [variant] .
    eq head(N L) = N [variant] .
endfm

fmod TEST-NO-SMT-LIST is
    protecting REAL-INTEGER .
    protecting INTEGER-LIST .
    protecting NELSON-OPPEN-COMBINATION .
    protecting META-LEVEL .
endfm

reduce nelson-oppen-sat(( tagged(tt, ('mod > 'INTEGER-LIST); ('check-sat > 'var-sat))
                        , tagged(tt, ('mod > 'INTEGER     ); ('check-sat > 'smt-sat))),
           '_-_ [ '_*_ [ '2.Integer , 'head[ 'L:NeIntegerList ] ]
                , '_*_ [ '2.Integer , 'head[ 'M:NeIntegerList ] ] ]
        ?= '1.Integer)
     == false
     .
reduce nelson-oppen-sat(( tagged(tt, ('mod > 'INTEGER-LIST); 'check-sat > 'var-sat)
                        , tagged(tt, ('mod > 'INTEGER     ); 'check-sat > 'smt-sat)),
           '_-_ [ '_*_ [ '2.Integer , 'head[ 'L:NeIntegerList ] ]
                , '_*_ [ '2.Integer , 'head[ 'M:NeIntegerList ] ] ]
        ?= '0.Integer)
     == true
     .

reduce nelson-oppen-sat(( tagged(tt, ('mod > 'INTEGER-LIST); 'check-sat > 'var-sat)
                        , tagged(tt, ('mod > 'INTEGER     ); 'check-sat > 'smt-sat)),
           '_-_ [ 'head[ 'L:NeIntegerList ]
                , '_*_ [ '2.Integer , 'head[ 'M:NeIntegerList ] ] ]
        ?= '0.Integer)
     == true
     .

--- UNSAT, but requires split to prove
reduce nelson-oppen-sat(( tagged(tt, (('mod > 'INTEGER-LIST); 'check-sat > 'var-sat))
                        , tagged(tt, (('mod > 'INTEGER     ); 'check-sat > 'smt-sat))),
          '_<=_ [ '1.Integer , 'head[ 'L:NeIntegerList ] ] ?= 'true.Boolean
       /\ '_<=_ [ 'head[ 'L:NeIntegerList ] , '2.Integer ] ?= 'true.Boolean
       /\ 'X:Integer ?= '1.Integer
       /\ 'Y:Integer ?= '2.Integer
       /\ 'X:Integer != 'head[ 'L:NeIntegerList ]
       /\ 'Y:Integer != 'head[ 'L:NeIntegerList ])
    == false
    .
