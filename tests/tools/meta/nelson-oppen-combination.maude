load ../../../contrib/tools/meta/nelson-oppen-combination.maude
load ../../../contrib/tools/varsat/numbers.maude

--- We need purification to put `0` and `s` into the `Nat*` theory,
--- while at the same time have enough constructors to convince
--- `var-sat` that the `Nat*` sort is infinite

fmod MYLISTNAT* is
  protecting BOOL* .
  sort Nat* .

  op fake-zero : -> Nat*      [ctor] .
  op fake-succ : Nat* -> Nat* [ctor] .

  sort NeNatList* NatList* .
  subsort Nat* < NeNatList* < NatList* .
  op __  : NeNatList* NeNatList* -> NeNatList* [ctor assoc] .
  op nil : -> NatList* [ctor] .

  op head : NeNatList* -> Nat* .
  var N : Nat* . var L : NeNatList* .
  eq head(N)   = N [variant] .
  eq head(N L) = N [variant] .
endfm

fmod TEST-NO-NAT-LIST is
    protecting NAT* .
    protecting MYLISTNAT* .
    protecting NELSON-OPPEN-COMBINATION .
    protecting META-LEVEL .

    op natMod     : -> Module   . eq natMod       = upModule('NAT*, true) .
    op natListMod : -> Module   . eq natListMod   = upModule('MYLISTNAT*, true) .
endfm

reduce nelson-oppen-sat(( tagged(tt, (('mod > 'MYLISTNAT*); 'check-sat > 'var-sat))
                        , tagged(tt, (('mod > 'NAT*      ); 'check-sat > 'var-sat))),
       ('tt.Bool* ?= ('_<Nat_ [ '_:+_['head['L':NeNatList*] , 'head['L':NeNatList*]]
                              , '_:+_['head[ 'L:NeNatList*] , 'head['L:NeNatList* ]]
                              ]))
        => (  'L:NeNatList* != 'L':NeNatList*
           /\ 'tt.Bool*     ?= '_<Nat_ ['head['L':NeNatList*] , 'head['L:NeNatList*]]
           )
       )
    == true
    .

reduce nelson-oppen-sat(( tagged(tt, (('mod > 'MYLISTNAT*); 'check-sat > 'var-sat))
                        , tagged(tt, (('mod > 'NAT*      ); 'check-sat > 'var-sat))),
       (  'L:NeNatList* ?= 'L':NeNatList*
       /\ 'tt.Bool*     ?= '_<Nat_ ['head['L':NeNatList*] , 'head['L:NeNatList*]]
       ))
    == false
    .

